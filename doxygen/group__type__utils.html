<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="author" content="Matus Chochlik"/>
<meta name="copyright" content="Copyright 2015-2021 Matus Chochlik"/>
<meta name="keywords" content="C++ EGL OpenGL OpenAL Graphics Rendering"/>
<meta name="description" content="C++ wrapper for rendering C APIs"/>
<title>Type utilities</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="oglplus.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="oglplus-frame">
<div id="oglplus-bar">
	<div id="oglplus-top">
	<div id="oglplus-top-content">
		<div id="oglplus-caption">
	   		<div id="oglplus-brief">
					<span id="oglplus-name">OGLplus&#160;</span>
					<span id="oglplus-version">(0.59.0)</span> a C++ wrapper for rendering APIs
				</div>
		</div>
		<hr/>
	</div>
	</div>
	<div id="oglplus-icon">
		<a href="http://oglplus.org/"><img src="../oglplus_circular.png"/></a>
	</div>
</div>
<div id="oglplus-content">
<div id="top">
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Type utilities</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1any__forward__iterator.html">eagine::any_forward_iterator&lt; VT, RT, PT, DT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type erasure for forward iterators.  <a href="classeagine_1_1any__forward__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1any__random__engine.html">eagine::any_random_engine&lt; Result &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erasing reference for standard random engine types.  <a href="classeagine_1_1any__random__engine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeagine_1_1anything.html">eagine::anything</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that can by constructed from single argument of any other type.  <a href="structeagine_1_1anything.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1biteset__value__proxy.html">eagine::biteset_value_proxy&lt; BiS &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy class that can be used to access elements in a biteset.  <a href="classeagine_1_1biteset__value__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1biteset__value__proxy__base.html">eagine::biteset_value_proxy_base&lt; BiS &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for biteset value proxy.  <a href="classeagine_1_1biteset__value__proxy__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1biteset__value__proxy_3_01const_01biteset_3_01N_00_01B_00_01T_01_4_01_4.html">eagine::biteset_value_proxy&lt; const biteset&lt; N, B, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of biteset proxy for const biteset values.  <a href="classeagine_1_1biteset__value__proxy_3_01const_01biteset_3_01N_00_01B_00_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1biteset__value__proxy_3_01biteset_3_01N_00_01B_00_01T_01_4_01_4.html">eagine::biteset_value_proxy&lt; biteset&lt; N, B, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of biteset proxy for mutable biteset values.  <a href="classeagine_1_1biteset__value__proxy_3_01biteset_3_01N_00_01B_00_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1biteset__iterator_3_01biteset_3_01N_00_01B_00_01T_01_4_01_4.html">eagine::biteset_iterator&lt; biteset&lt; N, B, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type for biteset.  <a href="classeagine_1_1biteset__iterator_3_01biteset_3_01N_00_01B_00_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1biteset.html">eagine::biteset&lt; N, B, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence of unsigned integer values with specified number bits.  <a href="classeagine_1_1biteset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1bitfield.html">eagine::bitfield&lt; Bit &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for manipulating and testing a group of enumeration-based bits.  <a href="classeagine_1_1bitfield.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1some__true.html">eagine::some_true</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class storing initially false value and logically or-ing other values.  <a href="classeagine_1_1some__true.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1byteset.html">eagine::byteset&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class storing a sequence of bytes converting them to and from unsigned integer.  <a href="classeagine_1_1byteset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1double__buffer.html">eagine::double_buffer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class holding two instances of type <code>T</code> and allows to switch them.  <a href="classeagine_1_1double__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1static__enum__map.html">eagine::static_enum_map&lt; Enum, Unit, Keys &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class mapping from an enumerator of an instantiation of a template.  <a href="classeagine_1_1static__enum__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1integer__range.html">eagine::integer_range&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer range type template usable in range-based loops.  <a href="classeagine_1_1integer__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1interface.html">eagine::interface&lt; Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for abstract interfaces, implements common functionality.  <a href="classeagine_1_1interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1abstract.html">eagine::abstract&lt; Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for polymorphic classes, implements common functionality.  <a href="classeagine_1_1abstract.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1basic__iterable__type.html">eagine::basic_iterable_type&lt; T, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template used in implementation of some iterators.  <a href="classeagine_1_1basic__iterable__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1basic__selfref__iterator.html">eagine::basic_selfref_iterator&lt; T, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator referencing the wrapped iterable type.  <a href="classeagine_1_1basic__selfref__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeagine_1_1selfref__iterator.html">eagine::selfref_iterator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default instantiation of <a class="el" href="classeagine_1_1basic__selfref__iterator.html" title="Iterator referencing the wrapped iterable type.">basic_selfref_iterator</a>.  <a href="structeagine_1_1selfref__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1basic__transforming__iterator.html">eagine::basic_transforming_iterator&lt; Iterator, T, S, Transform, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator transforming the referenced elements.  <a href="classeagine_1_1basic__transforming__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeagine_1_1transforming__iterator.html">eagine::transforming_iterator&lt; Iterator, T, S, Transform &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default instantiation of <a class="el" href="classeagine_1_1basic__transforming__iterator.html" title="Iterator transforming the referenced elements.">basic_transforming_iterator</a>.  <a href="structeagine_1_1transforming__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1basic__noexcept__casting__iterator.html">eagine::basic_noexcept_casting_iterator&lt; Iterator, T, S, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type-casting the referenced elements.  <a href="classeagine_1_1basic__noexcept__casting__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeagine_1_1noexcept__casting__iterator.html">eagine::noexcept_casting_iterator&lt; Iterator, T, S &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default instantiation of <a class="el" href="classeagine_1_1basic__noexcept__casting__iterator.html" title="Iterator type-casting the referenced elements.">basic_noexcept_casting_iterator</a>.  <a href="structeagine_1_1noexcept__casting__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeagine_1_1key__value__list__element.html">eagine::key_value_list_element&lt; Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single key/value pair for a key/value list.  <a href="structeagine_1_1key__value__list__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1key__value__list.html">eagine::key_value_list&lt; Traits, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for classes wrapping static key/value typically attribute lists.  <a href="classeagine_1_1key__value__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1main__ctx__log__backend__getter.html">eagine::main_ctx_log_backend_getter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class used in the implementation of logging in main context object.  <a href="classeagine_1_1main__ctx__log__backend__getter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeagine_1_1memory_1_1typed__nullptr__t.html">eagine::memory::typed_nullptr_t&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for doing pointer arithmetic on null pointers.  <a href="structeagine_1_1memory_1_1typed__nullptr__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeagine_1_1memory_1_1has__span__size__member.html">eagine::memory::has_span_size_member&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class detecting if type T has x.size() member function.  <a href="structeagine_1_1memory_1_1has__span__size__member.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeagine_1_1memory_1_1has__span__data__member.html">eagine::memory::has_span_data_member&lt; T, E &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class detecting if type T has x.data() member function.  <a href="structeagine_1_1memory_1_1has__span__data__member.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">eagine::memory::basic_span&lt; ValueType, Pointer, SizeType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning view of a contiguous range of memory with ValueType elements.  <a href="classeagine_1_1memory_1_1basic__span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeagine_1_1nothing__t.html">eagine::nothing_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing "none" / "nothing" values.  <a href="structeagine_1_1nothing__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1protected__member.html">eagine::protected_member&lt; T, Selector &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class holding a single tagged data member.  <a href="classeagine_1_1protected__member.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga69d3f9c0caccb011593de874009873ce"><td class="memTemplParams" colspan="2"><a id="ga69d3f9c0caccb011593de874009873ce"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga69d3f9c0caccb011593de874009873ce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga69d3f9c0caccb011593de874009873ce">eagine::any_std_forward_iterator</a> = <a class="el" href="classeagine_1_1any__forward__iterator.html">any_forward_iterator</a>&lt; T, const T &amp;, const T *, std::ptrdiff_t &gt;</td></tr>
<tr class="memdesc:ga69d3f9c0caccb011593de874009873ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for type erased STL forward iterators. <br /></td></tr>
<tr class="separator:ga69d3f9c0caccb011593de874009873ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5c7c5d04307871d98a76686b17ebba4"><td class="memTemplParams" colspan="2">template&lt;typename std::size_t B&gt; </td></tr>
<tr class="memitem:gad5c7c5d04307871d98a76686b17ebba4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gad5c7c5d04307871d98a76686b17ebba4">eagine::biteset_cell_type</a> = std::conditional_t&lt;(B&lt;=8), std::uint_least8_t, std::conditional_t&lt;(B&lt;=16), std::uint_least16_t, std::conditional_t&lt;(B&lt;=32), std::uint_least32_t, std::conditional_t&lt;(B&lt;=64), std::uint_least64_t, void &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:gad5c7c5d04307871d98a76686b17ebba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the appropriate type for biteset element representation.  <a href="group__type__utils.html#gad5c7c5d04307871d98a76686b17ebba4">More...</a><br /></td></tr>
<tr class="separator:gad5c7c5d04307871d98a76686b17ebba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda8aac5370bd7ae56cb5a16defd16f4"><td class="memTemplParams" colspan="2"><a id="gadda8aac5370bd7ae56cb5a16defd16f4"></a>
template&lt;bool B&gt; </td></tr>
<tr class="memitem:gadda8aac5370bd7ae56cb5a16defd16f4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gadda8aac5370bd7ae56cb5a16defd16f4">eagine::bool_constant</a> = std::integral_constant&lt; bool, B &gt;</td></tr>
<tr class="memdesc:gadda8aac5370bd7ae56cb5a16defd16f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for boolean constant type. <br /></td></tr>
<tr class="separator:gadda8aac5370bd7ae56cb5a16defd16f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga870c8270c3b77a0da93f276783d2f8f1"><td class="memTemplParams" colspan="2"><a id="ga870c8270c3b77a0da93f276783d2f8f1"></a>
template&lt;int I&gt; </td></tr>
<tr class="memitem:ga870c8270c3b77a0da93f276783d2f8f1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga870c8270c3b77a0da93f276783d2f8f1">eagine::int_constant</a> = std::integral_constant&lt; int, I &gt;</td></tr>
<tr class="memdesc:ga870c8270c3b77a0da93f276783d2f8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for signed int constant type. <br /></td></tr>
<tr class="separator:ga870c8270c3b77a0da93f276783d2f8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60a0b020f0b6a0616a07c71440000c06"><td class="memTemplParams" colspan="2"><a id="ga60a0b020f0b6a0616a07c71440000c06"></a>
template&lt;unsigned U&gt; </td></tr>
<tr class="memitem:ga60a0b020f0b6a0616a07c71440000c06"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga60a0b020f0b6a0616a07c71440000c06">eagine::unsigned_constant</a> = std::integral_constant&lt; unsigned, U &gt;</td></tr>
<tr class="memdesc:ga60a0b020f0b6a0616a07c71440000c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for unsigned int constant type. <br /></td></tr>
<tr class="separator:ga60a0b020f0b6a0616a07c71440000c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf4e8677167f3bbf423c824b1847e66f"><td class="memTemplParams" colspan="2"><a id="gacf4e8677167f3bbf423c824b1847e66f"></a>
template&lt;std::size_t S&gt; </td></tr>
<tr class="memitem:gacf4e8677167f3bbf423c824b1847e66f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gacf4e8677167f3bbf423c824b1847e66f">eagine::size_constant</a> = std::integral_constant&lt; std::size_t, S &gt;</td></tr>
<tr class="memdesc:gacf4e8677167f3bbf423c824b1847e66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for size_t constant type. <br /></td></tr>
<tr class="separator:gacf4e8677167f3bbf423c824b1847e66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbe944538990f9399b4ba44485e823fe"><td class="memTemplParams" colspan="2">template&lt;identifier_t Id&gt; </td></tr>
<tr class="memitem:gafbe944538990f9399b4ba44485e823fe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gafbe944538990f9399b4ba44485e823fe">eagine::id_constant</a> = std::integral_constant&lt; <a class="el" href="group__identifiers.html#ga95fc7f47f20633e9563dcaa76d1bce4b">identifier_t</a>, Id &gt;</td></tr>
<tr class="memdesc:gafbe944538990f9399b4ba44485e823fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for identifier_t constant type.  <a href="group__type__utils.html#gafbe944538990f9399b4ba44485e823fe">More...</a><br /></td></tr>
<tr class="separator:gafbe944538990f9399b4ba44485e823fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8da7f49dadf801add5106aeaaf050f7b"><td class="memTemplParams" colspan="2"><a id="ga8da7f49dadf801add5106aeaaf050f7b"></a>
template&lt;bool IsConst&gt; </td></tr>
<tr class="memitem:ga8da7f49dadf801add5106aeaaf050f7b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga8da7f49dadf801add5106aeaaf050f7b">eagine::memory::basic_block</a> = <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; std::conditional_t&lt; IsConst, const <a class="el" href="group__type__utils.html#ga973e3bb89ea2c57a0e9204e9ffc0167e">byte</a>, <a class="el" href="group__type__utils.html#ga973e3bb89ea2c57a0e9204e9ffc0167e">byte</a> &gt; &gt;</td></tr>
<tr class="memdesc:ga8da7f49dadf801add5106aeaaf050f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for byte spans. <br /></td></tr>
<tr class="separator:ga8da7f49dadf801add5106aeaaf050f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbd294528813ac25d56decb0e5194089"><td class="memTemplParams" colspan="2"><a id="gadbd294528813ac25d56decb0e5194089"></a>
template&lt;bool IsConst&gt; </td></tr>
<tr class="memitem:gadbd294528813ac25d56decb0e5194089"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gadbd294528813ac25d56decb0e5194089">eagine::memory::basic_split_block</a> = <a class="el" href="classeagine_1_1memory_1_1basic__split__span.html">basic_split_span</a>&lt; std::conditional_t&lt; IsConst, const <a class="el" href="group__type__utils.html#ga973e3bb89ea2c57a0e9204e9ffc0167e">byte</a>, <a class="el" href="group__type__utils.html#ga973e3bb89ea2c57a0e9204e9ffc0167e">byte</a> &gt; &gt;</td></tr>
<tr class="memdesc:gadbd294528813ac25d56decb0e5194089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for split span of bytes. <br /></td></tr>
<tr class="separator:gadbd294528813ac25d56decb0e5194089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga973e3bb89ea2c57a0e9204e9ffc0167e"><td class="memItemLeft" align="right" valign="top"><a id="ga973e3bb89ea2c57a0e9204e9ffc0167e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga973e3bb89ea2c57a0e9204e9ffc0167e">eagine::byte</a> = unsigned char</td></tr>
<tr class="memdesc:ga973e3bb89ea2c57a0e9204e9ffc0167e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte type alias. <br /></td></tr>
<tr class="separator:ga973e3bb89ea2c57a0e9204e9ffc0167e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99d0d8a7358b42ac745edd78ca686f7b"><td class="memItemLeft" align="right" valign="top"><a id="ga99d0d8a7358b42ac745edd78ca686f7b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga99d0d8a7358b42ac745edd78ca686f7b">eagine::std_align_t</a> = std::size_t</td></tr>
<tr class="memdesc:ga99d0d8a7358b42ac745edd78ca686f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alignment type used by std. <br /></td></tr>
<tr class="separator:ga99d0d8a7358b42ac745edd78ca686f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2c466d5e3bc1c923488ba79fd191363"><td class="memItemLeft" align="right" valign="top"><a id="gaa2c466d5e3bc1c923488ba79fd191363"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gaa2c466d5e3bc1c923488ba79fd191363">eagine::std_size_t</a> = std::size_t</td></tr>
<tr class="memdesc:gaa2c466d5e3bc1c923488ba79fd191363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type used by std. <br /></td></tr>
<tr class="separator:gaa2c466d5e3bc1c923488ba79fd191363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45c24c96dddc1fd15429ed38f016d1ef"><td class="memItemLeft" align="right" valign="top"><a id="ga45c24c96dddc1fd15429ed38f016d1ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">eagine::span_size_t</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:ga45c24c96dddc1fd15429ed38f016d1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed span size type used by eagine. <br /></td></tr>
<tr class="separator:ga45c24c96dddc1fd15429ed38f016d1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbaa82e72e4244fec591e7e012cf949a"><td class="memItemLeft" align="right" valign="top"><a id="gafbaa82e72e4244fec591e7e012cf949a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gafbaa82e72e4244fec591e7e012cf949a">eagine::valid_span_size</a> = <a class="el" href="group__valid__if.html#gaef2dc21d2639e5ce20214e987a407ebc">valid_if_nonnegative</a>&lt; <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> &gt;</td></tr>
<tr class="memdesc:gafbaa82e72e4244fec591e7e012cf949a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valid size type. <br /></td></tr>
<tr class="separator:gafbaa82e72e4244fec591e7e012cf949a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8a72fe43272bd6f8f7e0cdbb41b3bce5"><td class="memTemplParams" colspan="2"><a id="ga8a72fe43272bd6f8f7e0cdbb41b3bce5"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga8a72fe43272bd6f8f7e0cdbb41b3bce5"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga8a72fe43272bd6f8f7e0cdbb41b3bce5">eagine::array_size</a> (const T(&amp;)[N]) noexcept</td></tr>
<tr class="memdesc:ga8a72fe43272bd6f8f7e0cdbb41b3bce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the array passed as argument. <br /></td></tr>
<tr class="separator:ga8a72fe43272bd6f8f7e0cdbb41b3bce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1df5cd1d4985695be84740fe5583811f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1df5cd1d4985695be84740fe5583811f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga1df5cd1d4985695be84740fe5583811f">eagine::from_string</a> (<a class="el" href="group__string__utils.html#gae76dd3f0edeca37e438f5bbc2374e1b9">string_view</a> src) noexcept</td></tr>
<tr class="memdesc:ga1df5cd1d4985695be84740fe5583811f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the string representation in <code>src</code> to a value of type <code>T</code>.  <a href="group__type__utils.html#ga1df5cd1d4985695be84740fe5583811f">More...</a><br /></td></tr>
<tr class="separator:ga1df5cd1d4985695be84740fe5583811f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5e9906b0f231cc91e5e26b53b676aaa"><td class="memTemplParams" colspan="2">template&lt;typename T , identifier_t V&gt; </td></tr>
<tr class="memitem:gaa5e9906b0f231cc91e5e26b53b676aaa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gaa5e9906b0f231cc91e5e26b53b676aaa">eagine::from_string</a> (<a class="el" href="group__string__utils.html#gae76dd3f0edeca37e438f5bbc2374e1b9">string_view</a> src, <a class="el" href="structeagine_1_1selector.html">selector</a>&lt; V &gt; sel) noexcept</td></tr>
<tr class="memdesc:gaa5e9906b0f231cc91e5e26b53b676aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the string representation in <code>src</code> to a value of type <code>T</code>.  <a href="group__type__utils.html#gaa5e9906b0f231cc91e5e26b53b676aaa">More...</a><br /></td></tr>
<tr class="separator:gaa5e9906b0f231cc91e5e26b53b676aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8be5f9b2eb2da5ba476bfb360643ad96"><td class="memTemplParams" colspan="2"><a id="ga8be5f9b2eb2da5ba476bfb360643ad96"></a>
template&lt;typename H , typename I &gt; </td></tr>
<tr class="memitem:ga8be5f9b2eb2da5ba476bfb360643ad96"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga8be5f9b2eb2da5ba476bfb360643ad96">eagine::integer_hash</a> (I x, <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; H &gt; hid={}, <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; I &gt; iid={}) -&gt; H</td></tr>
<tr class="memdesc:ga8be5f9b2eb2da5ba476bfb360643ad96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a hash value with type <code>H</code> from an integer value of type <code>I</code>. <br /></td></tr>
<tr class="separator:ga8be5f9b2eb2da5ba476bfb360643ad96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga276d503ab92116642830c65da0ce07b1"><td class="memTemplParams" colspan="2"><a id="ga276d503ab92116642830c65da0ce07b1"></a>
template&lt;typename B , typename E &gt; </td></tr>
<tr class="memitem:ga276d503ab92116642830c65da0ce07b1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga276d503ab92116642830c65da0ce07b1">eagine::integer_range</a> (B, E) -&gt; <a class="el" href="classeagine_1_1integer__range.html">integer_range</a>&lt; std::common_type_t&lt; B, E &gt;&gt;</td></tr>
<tr class="memdesc:ga276d503ab92116642830c65da0ce07b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for <a class="el" href="classeagine_1_1integer__range.html" title="Integer range type template usable in range-based loops.">integer_range</a>. <br /></td></tr>
<tr class="separator:ga276d503ab92116642830c65da0ce07b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd89bedd5b7fb3c4294c2829223766e"><td class="memTemplParams" colspan="2">template&lt;typename Dst , typename Src &gt; </td></tr>
<tr class="memitem:ga3dd89bedd5b7fb3c4294c2829223766e"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga3dd89bedd5b7fb3c4294c2829223766e">eagine::is_within_limits</a> (Src value) noexcept</td></tr>
<tr class="memdesc:ga3dd89bedd5b7fb3c4294c2829223766e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if <code>value</code> fits into the specified Dst type.  <a href="group__type__utils.html#ga3dd89bedd5b7fb3c4294c2829223766e">More...</a><br /></td></tr>
<tr class="separator:ga3dd89bedd5b7fb3c4294c2829223766e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c66b4787a419a350ef1bf0a66eabe7d"><td class="memTemplParams" colspan="2">template&lt;typename Dst , typename Src &gt; </td></tr>
<tr class="memitem:ga7c66b4787a419a350ef1bf0a66eabe7d"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga7c66b4787a419a350ef1bf0a66eabe7d">eagine::limit_cast</a> (Src value) noexcept -&gt; std::enable_if_t&lt; std::is_convertible_v&lt; Src, Dst &gt;, Dst &gt;</td></tr>
<tr class="memdesc:ga7c66b4787a419a350ef1bf0a66eabe7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>value</code> to Dst type if the value fits in that type.  <a href="group__type__utils.html#ga7c66b4787a419a350ef1bf0a66eabe7d">More...</a><br /></td></tr>
<tr class="separator:ga7c66b4787a419a350ef1bf0a66eabe7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd261bbb0d91893dee41a1580bde20ae"><td class="memTemplParams" colspan="2">template&lt;typename Dst , typename Src &gt; </td></tr>
<tr class="memitem:gafd261bbb0d91893dee41a1580bde20ae"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gafd261bbb0d91893dee41a1580bde20ae">eagine::convert_if_fits</a> (Src value) noexcept -&gt; std::enable_if_t&lt; std::is_convertible_v&lt; Src, Dst &gt;, <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt; Dst &gt;&gt;</td></tr>
<tr class="memdesc:gafd261bbb0d91893dee41a1580bde20ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optionally converts <code>value</code> to Dst type if the value fits in that type.  <a href="group__type__utils.html#gafd261bbb0d91893dee41a1580bde20ae">More...</a><br /></td></tr>
<tr class="separator:gafd261bbb0d91893dee41a1580bde20ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7a7597fb36b9bcc718b233d805765e4"><td class="memTemplParams" colspan="2"><a id="gab7a7597fb36b9bcc718b233d805765e4"></a>
template&lt;typename T , typename N &gt; </td></tr>
<tr class="memitem:gab7a7597fb36b9bcc718b233d805765e4"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gab7a7597fb36b9bcc718b233d805765e4">eagine::memory::operator+</a> (<a class="el" href="structeagine_1_1memory_1_1typed__nullptr__t.html">typed_nullptr_t</a>&lt; T &gt;, N n) noexcept -&gt; T *</td></tr>
<tr class="memdesc:gab7a7597fb36b9bcc718b233d805765e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer arithmetic addition operator for null pointers. <br /></td></tr>
<tr class="separator:gab7a7597fb36b9bcc718b233d805765e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga862a146389d4686c7c2c5fed724500b0"><td class="memTemplParams" colspan="2"><a id="ga862a146389d4686c7c2c5fed724500b0"></a>
template&lt;typename T , typename B , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga862a146389d4686c7c2c5fed724500b0"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga862a146389d4686c7c2c5fed724500b0">eagine::memory::can_accomodate</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; B, P, S &gt; blk, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> count, <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt; tid={}) noexcept</td></tr>
<tr class="memdesc:ga862a146389d4686c7c2c5fed724500b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the specified memory block can accomodate count elements of T. <br /></td></tr>
<tr class="separator:ga862a146389d4686c7c2c5fed724500b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga048c122d27429b74e07b1bbfabef6f47"><td class="memTemplParams" colspan="2"><a id="ga048c122d27429b74e07b1bbfabef6f47"></a>
template&lt;typename T , typename B , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga048c122d27429b74e07b1bbfabef6f47"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga048c122d27429b74e07b1bbfabef6f47">eagine::memory::can_accomodate</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; B, P, S &gt; blk, <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt; tid={}) noexcept</td></tr>
<tr class="memdesc:ga048c122d27429b74e07b1bbfabef6f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the specified memory block can accomodate one element of T. <br /></td></tr>
<tr class="separator:ga048c122d27429b74e07b1bbfabef6f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c92cebf9d392d2db6c932e2c314a966"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Predicate &gt; </td></tr>
<tr class="memitem:ga2c92cebf9d392d2db6c932e2c314a966"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga2c92cebf9d392d2db6c932e2c314a966">eagine::memory::all_of</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Predicate predicate) -&gt; bool</td></tr>
<tr class="memdesc:ga2c92cebf9d392d2db6c932e2c314a966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if all elements in a span satisfy <code>predicate</code>.  <a href="group__type__utils.html#ga2c92cebf9d392d2db6c932e2c314a966">More...</a><br /></td></tr>
<tr class="separator:ga2c92cebf9d392d2db6c932e2c314a966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae764815a88419c94d5b8876380b1fa39"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Predicate &gt; </td></tr>
<tr class="memitem:gae764815a88419c94d5b8876380b1fa39"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gae764815a88419c94d5b8876380b1fa39">eagine::memory::any_of</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Predicate predicate) -&gt; bool</td></tr>
<tr class="memdesc:gae764815a88419c94d5b8876380b1fa39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if any elements in a span satisfy <code>predicate</code>.  <a href="group__type__utils.html#gae764815a88419c94d5b8876380b1fa39">More...</a><br /></td></tr>
<tr class="separator:gae764815a88419c94d5b8876380b1fa39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d39d993fcd8bb0d02eb099085830728"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Predicate &gt; </td></tr>
<tr class="memitem:ga5d39d993fcd8bb0d02eb099085830728"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga5d39d993fcd8bb0d02eb099085830728">eagine::memory::none_of</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Predicate predicate) -&gt; bool</td></tr>
<tr class="memdesc:ga5d39d993fcd8bb0d02eb099085830728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if no elements in a span satisfy <code>predicate</code>.  <a href="group__type__utils.html#ga5d39d993fcd8bb0d02eb099085830728">More...</a><br /></td></tr>
<tr class="separator:ga5d39d993fcd8bb0d02eb099085830728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga286bbf2c9da85f3783a1c647a5307dd6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:ga286bbf2c9da85f3783a1c647a5307dd6"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga286bbf2c9da85f3783a1c647a5307dd6">eagine::memory::for_each_delimited</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; delim, UnaryOperation unary_op)</td></tr>
<tr class="memdesc:ga286bbf2c9da85f3783a1c647a5307dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans span for parts split by delimiter, calls a function for each part.  <a href="group__type__utils.html#ga286bbf2c9da85f3783a1c647a5307dd6">More...</a><br /></td></tr>
<tr class="separator:ga286bbf2c9da85f3783a1c647a5307dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae35e9ec5c2a721f696b50d75990ea8a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:gaae35e9ec5c2a721f696b50d75990ea8a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gaae35e9ec5c2a721f696b50d75990ea8a">eagine::memory::for_each_chunk</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> len, UnaryOperation unary_op)</td></tr>
<tr class="memdesc:gaae35e9ec5c2a721f696b50d75990ea8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits span into parts of equal length, calls a function for each part.  <a href="group__type__utils.html#gaae35e9ec5c2a721f696b50d75990ea8a">More...</a><br /></td></tr>
<tr class="separator:gaae35e9ec5c2a721f696b50d75990ea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1172d637c9c9b4a51d0d569622296f61"><td class="memTemplParams" colspan="2"><a id="ga1172d637c9c9b4a51d0d569622296f61"></a>
template&lt;typename Result , typename T , typename P1 , typename S1 , typename P2 , typename S2 , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga1172d637c9c9b4a51d0d569622296f61"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga1172d637c9c9b4a51d0d569622296f61">eagine::memory::basic_edit_distance</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; const T, P1, S1 &gt; s1, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; const T, P2, S2 &gt; s2, BinaryFunction get_distance) -&gt; Result</td></tr>
<tr class="memdesc:ga1172d637c9c9b4a51d0d569622296f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the edit distance of <code>s1</code> and <code>s2</code> according to get_distance. <br /></td></tr>
<tr class="separator:ga1172d637c9c9b4a51d0d569622296f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d5bfddc9b8e49e175b1a40f9e6f72f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4d5bfddc9b8e49e175b1a40f9e6f72f6"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga4d5bfddc9b8e49e175b1a40f9e6f72f6">eagine::type_name</a> (const T &amp;) noexcept -&gt; std::string</td></tr>
<tr class="memdesc:ga4d5bfddc9b8e49e175b1a40f9e6f72f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the demangled name for type T.  <a href="group__type__utils.html#ga4d5bfddc9b8e49e175b1a40f9e6f72f6">More...</a><br /></td></tr>
<tr class="separator:ga4d5bfddc9b8e49e175b1a40f9e6f72f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4465c961f40f266eef9e3c9453beccac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4465c961f40f266eef9e3c9453beccac"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga4465c961f40f266eef9e3c9453beccac">eagine::type_name</a> () noexcept -&gt; std::string</td></tr>
<tr class="memdesc:ga4465c961f40f266eef9e3c9453beccac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the demangled name for type T.  <a href="group__type__utils.html#ga4465c961f40f266eef9e3c9453beccac">More...</a><br /></td></tr>
<tr class="separator:ga4465c961f40f266eef9e3c9453beccac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96ffe8eee5d3204fc133c05c1dbbae02"><td class="memTemplParams" colspan="2"><a id="ga96ffe8eee5d3204fc133c05c1dbbae02"></a>
template&lt;typename T , typename  = std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga96ffe8eee5d3204fc133c05c1dbbae02"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga96ffe8eee5d3204fc133c05c1dbbae02">eagine::std_align</a> (T v) noexcept</td></tr>
<tr class="memdesc:ga96ffe8eee5d3204fc133c05c1dbbae02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to std alignment type. <br /></td></tr>
<tr class="separator:ga96ffe8eee5d3204fc133c05c1dbbae02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga613b80f5186369d45a7fa4afa6c9b7cf"><td class="memTemplParams" colspan="2"><a id="ga613b80f5186369d45a7fa4afa6c9b7cf"></a>
template&lt;typename T , typename  = std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga613b80f5186369d45a7fa4afa6c9b7cf"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga613b80f5186369d45a7fa4afa6c9b7cf">eagine::std_size</a> (T v) noexcept</td></tr>
<tr class="memdesc:ga613b80f5186369d45a7fa4afa6c9b7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to std size type. <br /></td></tr>
<tr class="separator:ga613b80f5186369d45a7fa4afa6c9b7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3832494f19b0bd1dfe739985e6423824"><td class="memTemplParams" colspan="2"><a id="ga3832494f19b0bd1dfe739985e6423824"></a>
template&lt;typename T , typename  = std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga3832494f19b0bd1dfe739985e6423824"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga3832494f19b0bd1dfe739985e6423824">eagine::span_size</a> (T v) noexcept</td></tr>
<tr class="memdesc:ga3832494f19b0bd1dfe739985e6423824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to span size type. <br /></td></tr>
<tr class="separator:ga3832494f19b0bd1dfe739985e6423824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab46da9ac6255df6ca55cba220c61794"><td class="memTemplParams" colspan="2"><a id="gaab46da9ac6255df6ca55cba220c61794"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaab46da9ac6255df6ca55cba220c61794"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gaab46da9ac6255df6ca55cba220c61794">eagine::span_align_of</a> (<a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt;={}) noexcept</td></tr>
<tr class="memdesc:gaab46da9ac6255df6ca55cba220c61794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the byte alignment of type T as span_size_t. <br /></td></tr>
<tr class="separator:gaab46da9ac6255df6ca55cba220c61794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedb51bc925f4e93cf94a96b25dce1bf4"><td class="memTemplParams" colspan="2"><a id="gaedb51bc925f4e93cf94a96b25dce1bf4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaedb51bc925f4e93cf94a96b25dce1bf4"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gaedb51bc925f4e93cf94a96b25dce1bf4">eagine::span_size_of</a> (<a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt;={}) noexcept</td></tr>
<tr class="memdesc:gaedb51bc925f4e93cf94a96b25dce1bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the byte size of type T as span_size_t. <br /></td></tr>
<tr class="separator:gaedb51bc925f4e93cf94a96b25dce1bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f9d16153376dc870670fb47aa5007a9"><td class="memTemplParams" colspan="2"><a id="ga4f9d16153376dc870670fb47aa5007a9"></a>
template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga4f9d16153376dc870670fb47aa5007a9"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga4f9d16153376dc870670fb47aa5007a9">eagine::span_size_of</a> (S n, <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt;={}) noexcept</td></tr>
<tr class="memdesc:ga4f9d16153376dc870670fb47aa5007a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total byte size of n elements of type T as span_size_t. <br /></td></tr>
<tr class="separator:ga4f9d16153376dc870670fb47aa5007a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad54b928ab6098eacd2ca9ee53c57173a"><td class="memTemplParams" colspan="2">template&lt;typename Traits &gt; </td></tr>
<tr class="memitem:gad54b928ab6098eacd2ca9ee53c57173a"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gad54b928ab6098eacd2ca9ee53c57173a">operator+</a> (const <a class="el" href="structeagine_1_1key__value__list__element.html">key_value_list_element</a>&lt; Traits &gt; &amp;l, const <a class="el" href="structeagine_1_1key__value__list__element.html">key_value_list_element</a>&lt; Traits &gt; &amp;r) noexcept -&gt; <a class="el" href="classeagine_1_1key__value__list.html">key_value_list</a>&lt; Traits, 4 &gt;</td></tr>
<tr class="memdesc:gad54b928ab6098eacd2ca9ee53c57173a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two individual key/value elements into a key/value list.  <a href="group__type__utils.html#gad54b928ab6098eacd2ca9ee53c57173a">More...</a><br /></td></tr>
<tr class="separator:gad54b928ab6098eacd2ca9ee53c57173a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace2b968f08ea49dd986b2f865fef58fe"><td class="memTemplParams" colspan="2">template&lt;typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:gace2b968f08ea49dd986b2f865fef58fe"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gace2b968f08ea49dd986b2f865fef58fe">operator+</a> (const <a class="el" href="classeagine_1_1key__value__list.html">key_value_list</a>&lt; Traits, N &gt; &amp;l, const <a class="el" href="structeagine_1_1key__value__list__element.html">key_value_list_element</a>&lt; Traits &gt; &amp;r) noexcept -&gt; <a class="el" href="classeagine_1_1key__value__list.html">key_value_list</a>&lt; Traits, N+2 &gt;</td></tr>
<tr class="memdesc:gace2b968f08ea49dd986b2f865fef58fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a key/value pair into a key/value list, returns a new list.  <a href="group__type__utils.html#gace2b968f08ea49dd986b2f865fef58fe">More...</a><br /></td></tr>
<tr class="separator:gace2b968f08ea49dd986b2f865fef58fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c98535512962555b502e009479f3ba7"><td class="memTemplParams" colspan="2"><a id="ga0c98535512962555b502e009479f3ba7"></a>
template&lt;typename Selector , typename T &gt; </td></tr>
<tr class="memitem:ga0c98535512962555b502e009479f3ba7"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga0c98535512962555b502e009479f3ba7">get_member</a> (<a class="el" href="classeagine_1_1protected__member.html">protected_member</a>&lt; T, Selector &gt; &amp;pm, Selector <a class="el" href="structeagine_1_1selector.html">selector</a>=Selector()) noexcept -&gt; T &amp;</td></tr>
<tr class="memdesc:ga0c98535512962555b502e009479f3ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the member stored in <a class="el" href="classeagine_1_1protected__member.html" title="Class holding a single tagged data member.">protected_member</a>. <br /></td></tr>
<tr class="separator:ga0c98535512962555b502e009479f3ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9da0d63183fa6309a51fae8694037651"><td class="memTemplParams" colspan="2"><a id="ga9da0d63183fa6309a51fae8694037651"></a>
template&lt;typename Selector , typename T &gt; </td></tr>
<tr class="memitem:ga9da0d63183fa6309a51fae8694037651"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga9da0d63183fa6309a51fae8694037651">get_member</a> (const <a class="el" href="classeagine_1_1protected__member.html">protected_member</a>&lt; T, Selector &gt; &amp;pm, Selector <a class="el" href="structeagine_1_1selector.html">selector</a>=Selector()) noexcept -&gt; const T &amp;</td></tr>
<tr class="memdesc:ga9da0d63183fa6309a51fae8694037651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the member stored in <a class="el" href="classeagine_1_1protected__member.html" title="Class holding a single tagged data member.">protected_member</a>. <br /></td></tr>
<tr class="separator:ga9da0d63183fa6309a51fae8694037651"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga941076769a0bc079cb82bff2d9be7397"><td class="memTemplParams" colspan="2"><a id="ga941076769a0bc079cb82bff2d9be7397"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga941076769a0bc079cb82bff2d9be7397"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structeagine_1_1memory_1_1typed__nullptr__t.html">typed_nullptr_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga941076769a0bc079cb82bff2d9be7397">eagine::memory::typed_nullptr</a></td></tr>
<tr class="memdesc:ga941076769a0bc079cb82bff2d9be7397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template constant for doing pointer arithmetic on null pointers. <br /></td></tr>
<tr class="separator:ga941076769a0bc079cb82bff2d9be7397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4845b1f7afe8748b7761f3229740862e"><td class="memTemplParams" colspan="2"><a id="ga4845b1f7afe8748b7761f3229740862e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4845b1f7afe8748b7761f3229740862e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga4845b1f7afe8748b7761f3229740862e">eagine::memory::has_span_size_member_v</a></td></tr>
<tr class="memdesc:ga4845b1f7afe8748b7761f3229740862e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait indicating if type T has x.size() member function. <br /></td></tr>
<tr class="separator:ga4845b1f7afe8748b7761f3229740862e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f881de38cee58d6b2527ce33e441f30"><td class="memTemplParams" colspan="2"><a id="ga9f881de38cee58d6b2527ce33e441f30"></a>
template&lt;typename T , typename E  = anything&gt; </td></tr>
<tr class="memitem:ga9f881de38cee58d6b2527ce33e441f30"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__utils.html#ga9f881de38cee58d6b2527ce33e441f30">eagine::memory::has_span_data_member_v</a></td></tr>
<tr class="memdesc:ga9f881de38cee58d6b2527ce33e441f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait indicating if type T has x.size() member function. <br /></td></tr>
<tr class="separator:ga9f881de38cee58d6b2527ce33e441f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8d81cd9c527e46b245b6e7d5ef0af12"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="structeagine_1_1nothing__t.html">nothing_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__utils.html#gaa8d81cd9c527e46b245b6e7d5ef0af12">eagine::nothing</a></td></tr>
<tr class="memdesc:gaa8d81cd9c527e46b245b6e7d5ef0af12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant of <a class="el" href="structeagine_1_1nothing__t.html" title="Class representing &quot;none&quot; / &quot;nothing&quot; values.">nothing_t</a> type.  <a href="group__type__utils.html#gaa8d81cd9c527e46b245b6e7d5ef0af12">More...</a><br /></td></tr>
<tr class="separator:gaa8d81cd9c527e46b245b6e7d5ef0af12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad5c7c5d04307871d98a76686b17ebba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5c7c5d04307871d98a76686b17ebba4">&#9670;&nbsp;</a></span>biteset_cell_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename std::size_t B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__type__utils.html#gad5c7c5d04307871d98a76686b17ebba4">eagine::biteset_cell_type</a> = typedef std::conditional_t&lt; (B &lt;= 8), std::uint_least8_t, std::conditional_t&lt; (B &lt;= 16), std::uint_least16_t, std::conditional_t&lt; (B &lt;= 32), std::uint_least32_t, std::conditional_t&lt;(B &lt;= 64), std::uint_least64_t, void&gt; &gt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the appropriate type for biteset element representation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classeagine_1_1biteset.html" title="Sequence of unsigned integer values with specified number bits.">biteset</a> </dd></dl>

</div>
</div>
<a id="gafbe944538990f9399b4ba44485e823fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbe944538990f9399b4ba44485e823fe">&#9670;&nbsp;</a></span>id_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;identifier_t Id&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__type__utils.html#gafbe944538990f9399b4ba44485e823fe">eagine::id_constant</a> = typedef std::integral_constant&lt;<a class="el" href="group__identifiers.html#ga95fc7f47f20633e9563dcaa76d1bce4b">identifier_t</a>, Id&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for identifier_t constant type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__identifiers.html#ga95fc7f47f20633e9563dcaa76d1bce4b" title="The underlying integer type for eagine::identifier.">identifier_t</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2c92cebf9d392d2db6c932e2c314a966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c92cebf9d392d2db6c932e2c314a966">&#9670;&nbsp;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::all_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if all elements in a span satisfy <code>predicate</code>. </p>
<dl class="section see"><dt>See also</dt><dd>any_of </dd>
<dd>
none_of </dd></dl>

</div>
</div>
<a id="gae764815a88419c94d5b8876380b1fa39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae764815a88419c94d5b8876380b1fa39">&#9670;&nbsp;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::any_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if any elements in a span satisfy <code>predicate</code>. </p>
<dl class="section see"><dt>See also</dt><dd>all_of </dd>
<dd>
none_of </dd></dl>

</div>
</div>
<a id="gafd261bbb0d91893dee41a1580bde20ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd261bbb0d91893dee41a1580bde20ae">&#9670;&nbsp;</a></span>convert_if_fits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dst , typename Src &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::convert_if_fits </td>
          <td>(</td>
          <td class="paramtype">Src&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::enable_if_t&lt;std::is_convertible_v&lt;Src, Dst&gt;, <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt;Dst&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optionally converts <code>value</code> to Dst type if the value fits in that type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__type__utils.html#ga3dd89bedd5b7fb3c4294c2829223766e" title="Indicates if value fits into the specified Dst type.">is_within_limits</a> </dd>
<dd>
<a class="el" href="group__type__utils.html#ga7c66b4787a419a350ef1bf0a66eabe7d" title="Casts value to Dst type if the value fits in that type.">limit_cast</a> </dd></dl>

</div>
</div>
<a id="gaae35e9ec5c2a721f696b50d75990ea8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae35e9ec5c2a721f696b50d75990ea8a">&#9670;&nbsp;</a></span>for_each_chunk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename UnaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void eagine::memory::for_each_chunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOperation&#160;</td>
          <td class="paramname"><em>unary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits span into parts of equal length, calls a function for each part. </p>
<dl class="section see"><dt>See also</dt><dd>for_each_delimited </dd></dl>

</div>
</div>
<a id="ga286bbf2c9da85f3783a1c647a5307dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga286bbf2c9da85f3783a1c647a5307dd6">&#9670;&nbsp;</a></span>for_each_delimited()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 , typename UnaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void eagine::memory::for_each_delimited </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOperation&#160;</td>
          <td class="paramname"><em>unary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scans span for parts split by delimiter, calls a function for each part. </p>
<dl class="section see"><dt>See also</dt><dd>for_each_chunk </dd></dl>

</div>
</div>
<a id="ga1df5cd1d4985695be84740fe5583811f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1df5cd1d4985695be84740fe5583811f">&#9670;&nbsp;</a></span>from_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto eagine::from_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__string__utils.html#gae76dd3f0edeca37e438f5bbc2374e1b9">string_view</a>&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the string representation in <code>src</code> to a value of type <code>T</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__type__utils.html#ga3dd89bedd5b7fb3c4294c2829223766e" title="Indicates if value fits into the specified Dst type.">is_within_limits</a> </dd></dl>

</div>
</div>
<a id="gaa5e9906b0f231cc91e5e26b53b676aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5e9906b0f231cc91e5e26b53b676aaa">&#9670;&nbsp;</a></span>from_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , identifier_t V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto eagine::from_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__string__utils.html#gae76dd3f0edeca37e438f5bbc2374e1b9">string_view</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structeagine_1_1selector.html">selector</a>&lt; V &gt;&#160;</td>
          <td class="paramname"><em>sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the string representation in <code>src</code> to a value of type <code>T</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__type__utils.html#ga3dd89bedd5b7fb3c4294c2829223766e" title="Indicates if value fits into the specified Dst type.">is_within_limits</a></dd></dl>
<p>This overload allows to specify a selector that can change the value conversion rules. </p>

</div>
</div>
<a id="ga3dd89bedd5b7fb3c4294c2829223766e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dd89bedd5b7fb3c4294c2829223766e">&#9670;&nbsp;</a></span>is_within_limits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dst , typename Src &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::is_within_limits </td>
          <td>(</td>
          <td class="paramtype">Src&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if <code>value</code> fits into the specified Dst type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__type__utils.html#ga7c66b4787a419a350ef1bf0a66eabe7d" title="Casts value to Dst type if the value fits in that type.">limit_cast</a> </dd>
<dd>
<a class="el" href="group__type__utils.html#gafd261bbb0d91893dee41a1580bde20ae" title="Optionally converts value to Dst type if the value fits in that type.">convert_if_fits</a></dd></dl>
<p>This function tests if the specified argument would fit into another type. For example if a value stored in 64-bit integer can be converted into a 16-bit integer without overflow. </p>

</div>
</div>
<a id="ga7c66b4787a419a350ef1bf0a66eabe7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c66b4787a419a350ef1bf0a66eabe7d">&#9670;&nbsp;</a></span>limit_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dst , typename Src &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::limit_cast </td>
          <td>(</td>
          <td class="paramtype">Src&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; std::enable_if_t&lt;std::is_convertible_v&lt;Src, Dst&gt;, Dst&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts <code>value</code> to Dst type if the value fits in that type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__type__utils.html#ga3dd89bedd5b7fb3c4294c2829223766e" title="Indicates if value fits into the specified Dst type.">is_within_limits</a> </dd>
<dd>
<a class="el" href="group__type__utils.html#gafd261bbb0d91893dee41a1580bde20ae" title="Optionally converts value to Dst type if the value fits in that type.">convert_if_fits</a> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>is_within_limits&lt;Dst&gt;(value) </dd></dl>

</div>
</div>
<a id="ga5d39d993fcd8bb0d02eb099085830728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d39d993fcd8bb0d02eb099085830728">&#9670;&nbsp;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::none_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if no elements in a span satisfy <code>predicate</code>. </p>
<dl class="section see"><dt>See also</dt><dd>all_of </dd>
<dd>
any_of </dd></dl>

</div>
</div>
<a id="gace2b968f08ea49dd986b2f865fef58fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace2b968f08ea49dd986b2f865fef58fe">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeagine_1_1key__value__list.html">key_value_list</a>&lt; Traits, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeagine_1_1key__value__list__element.html">key_value_list_element</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1key__value__list.html">key_value_list</a>&lt;Traits, N + 2&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a key/value pair into a key/value list, returns a new list. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structeagine_1_1key__value__list__element.html" title="A single key/value pair for a key/value list.">key_value_list_element</a> </dd></dl>

</div>
</div>
<a id="gad54b928ab6098eacd2ca9ee53c57173a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad54b928ab6098eacd2ca9ee53c57173a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structeagine_1_1key__value__list__element.html">key_value_list_element</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeagine_1_1key__value__list__element.html">key_value_list_element</a>&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1key__value__list.html">key_value_list</a>&lt;Traits, 4&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates two individual key/value elements into a key/value list. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structeagine_1_1key__value__list__element.html" title="A single key/value pair for a key/value list.">key_value_list_element</a> </dd></dl>

</div>
</div>
<a id="ga4465c961f40f266eef9e3c9453beccac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4465c961f40f266eef9e3c9453beccac">&#9670;&nbsp;</a></span>type_name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; std::string </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the demangled name for type T. </p>
<dl class="section note"><dt>Note</dt><dd>The result is implementation dependent. </dd></dl>

</div>
</div>
<a id="ga4d5bfddc9b8e49e175b1a40f9e6f72f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d5bfddc9b8e49e175b1a40f9e6f72f6">&#9670;&nbsp;</a></span>type_name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::type_name </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; std::string </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the demangled name for type T. </p>
<dl class="section note"><dt>Note</dt><dd>The result is implementation dependent. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gaa8d81cd9c527e46b245b6e7d5ef0af12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8d81cd9c527e46b245b6e7d5ef0af12">&#9670;&nbsp;</a></span>nothing</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structeagine_1_1nothing__t.html">nothing_t</a> eagine::nothing</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant of <a class="el" href="structeagine_1_1nothing__t.html" title="Class representing &quot;none&quot; / &quot;nothing&quot; values.">nothing_t</a> type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structeagine_1_1nothing__t.html" title="Class representing &quot;none&quot; / &quot;nothing&quot; values.">nothing_t</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="eagine_2message_bus_2005_topology_8cpp-example.html#a4">eagine/message_bus/005_topology.cpp</a>, and <a class="el" href="eagine_2message_bus_2007_ping_8cpp-example.html#a2">eagine/message_bus/007_ping.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classeagine_1_1shared__executable__module.html#a0b04607f1d12e3ad65c4b44f1518b690">eagine::shared_executable_module::open_self()</a>, and <a class="el" href="classeagine_1_1shared__executable__module.html#a72533e97c1ba0aaec3a54e04872bef40">eagine::shared_executable_module::shared_executable_module()</a>.</p>

</div>
</div>
</div><!-- contents -->
<br/>
<div id="oglplus-bottom">
<em>Copyright &copy; 2015-2021</em> <strong>Matúš Chochlík</strong>.<br/>
&lt;<a href="mailto:chochlik@gmail.com">chochlik -at -gmail.com</a>&gt;<br/>
Documentation generated on Tue Apr 13 2021 by <a href="http://www.doxygen.org/index.html">Doxygen</a> (version 1.8.17).
</div> <!-- oglplus-bottom -->
</div> <!-- oglplus-content -->
</div> <!-- oglplus-frame -->
</body>
</html>
