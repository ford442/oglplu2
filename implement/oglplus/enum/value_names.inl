//  File implement/oglplus/enum/value_names.inl
//
//  Automatically generated file, DO NOT modify manually.
//  Edit the enumeration source files in 'source/enums/oglplus'
//  or the 'source/enums/make_enum.py' script instead.
//
//  Copyright Matus Chochlik.
//  Distributed under the Boost Software License, Version 1.0.
//  See accompanying file LICENSE_1_0.txt or copy at
//   http://www.boost.org/LICENSE_1_0.txt
//

#include <eagine/maybe_unused.hpp>
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4065)
#endif //_MSC_VER

namespace oglplus {

OGLPLUS_LIB_FUNC
string_view get_enum_value_name( // NOLINT(hicpp-function-size)

  const any_enum_value& aev) noexcept {
#ifdef GL_ACCUM_ADJACENT_PAIRS_NV
    static const char* s_ACCUM_ADJACENT_PAIRS_NV = "ACCUM_ADJACENT_PAIRS_NV";
#endif
#ifdef GL_ACTIVE_ATOMIC_COUNTER_BUFFERS
    static const char* s_ACTIVE_ATOMIC_COUNTER_BUFFERS =
      "ACTIVE_ATOMIC_COUNTER_BUFFERS";
#endif
#ifdef GL_ACTIVE_ATTRIBUTES
    static const char* s_ACTIVE_ATTRIBUTES = "ACTIVE_ATTRIBUTES";
#endif
#ifdef GL_ACTIVE_ATTRIBUTE_MAX_LENGTH
    static const char* s_ACTIVE_ATTRIBUTE_MAX_LENGTH =
      "ACTIVE_ATTRIBUTE_MAX_LENGTH";
#endif
#ifdef GL_ACTIVE_PROGRAM
    static const char* s_ACTIVE_PROGRAM = "ACTIVE_PROGRAM";
#endif
#ifdef GL_ACTIVE_UNIFORMS
    static const char* s_ACTIVE_UNIFORMS = "ACTIVE_UNIFORMS";
#endif
#ifdef GL_ACTIVE_UNIFORM_MAX_LENGTH
    static const char* s_ACTIVE_UNIFORM_MAX_LENGTH =
      "ACTIVE_UNIFORM_MAX_LENGTH";
#endif
#ifdef GL_ACTIVE_VARIABLES
    static const char* s_ACTIVE_VARIABLES = "ACTIVE_VARIABLES";
#endif
#ifdef GL_ADJACENT_PAIRS_NV
    static const char* s_ADJACENT_PAIRS_NV = "ADJACENT_PAIRS_NV";
#endif
#ifdef GL_AFFINE_2D_NV
    static const char* s_AFFINE_2D_NV = "AFFINE_2D_NV";
#endif
#ifdef GL_AFFINE_3D_NV
    static const char* s_AFFINE_3D_NV = "AFFINE_3D_NV";
#endif
#ifdef GL_ALIASED_LINE_WIDTH_RANGE
    static const char* s_ALIASED_LINE_WIDTH_RANGE = "ALIASED_LINE_WIDTH_RANGE";
#endif
#ifdef GL_ALL_BARRIER_BITS
    static const char* s_ALL_BARRIER_BITS = "ALL_BARRIER_BITS";
#endif
#ifdef GL_ALL_SHADER_BITS
    static const char* s_ALL_SHADER_BITS = "ALL_SHADER_BITS";
#endif
#ifdef GL_ALPHA
    static const char* s_ALPHA = "ALPHA";
#endif
#ifdef GL_ALPHA_BIAS
    static const char* s_ALPHA_BIAS = "ALPHA_BIAS";
#endif
#ifdef GL_ALPHA_REF_COMMAND_NV
    static const char* s_ALPHA_REF_COMMAND_NV = "ALPHA_REF_COMMAND_NV";
#endif
#ifdef GL_ALPHA_SCALE
    static const char* s_ALPHA_SCALE = "ALPHA_SCALE";
#endif
#ifdef GL_ALREADY_SIGNALED
    static const char* s_ALREADY_SIGNALED = "ALREADY_SIGNALED";
#endif
#ifdef GL_ALWAYS
    static const char* s_ALWAYS = "ALWAYS";
#endif
#ifdef GL_AND
    static const char* s_AND = "AND";
#endif
#ifdef GL_AND_INVERTED
    static const char* s_AND_INVERTED = "AND_INVERTED";
#endif
#ifdef GL_AND_REVERSE
    static const char* s_AND_REVERSE = "AND_REVERSE";
#endif
#ifdef GL_ANY_SAMPLES_PASSED
    static const char* s_ANY_SAMPLES_PASSED = "ANY_SAMPLES_PASSED";
#endif
#ifdef GL_ANY_SAMPLES_PASSED_CONSERVATIVE
    static const char* s_ANY_SAMPLES_PASSED_CONSERVATIVE =
      "ANY_SAMPLES_PASSED_CONSERVATIVE";
#endif
#ifdef GL_ARC_TO_NV
    static const char* s_ARC_TO_NV = "ARC_TO_NV";
#endif
#ifdef GL_ARRAY_BUFFER
    static const char* s_ARRAY_BUFFER = "ARRAY_BUFFER";
#endif
#ifdef GL_ARRAY_BUFFER_BINDING
    static const char* s_ARRAY_BUFFER_BINDING = "ARRAY_BUFFER_BINDING";
#endif
#ifdef GL_ARRAY_SIZE
    static const char* s_ARRAY_SIZE = "ARRAY_SIZE";
#endif
#ifdef GL_ARRAY_STRIDE
    static const char* s_ARRAY_STRIDE = "ARRAY_STRIDE";
#endif
#ifdef GL_ATOMIC_COUNTER_BARRIER_BIT
    static const char* s_ATOMIC_COUNTER_BARRIER_BIT =
      "ATOMIC_COUNTER_BARRIER_BIT";
#endif
#ifdef GL_ATOMIC_COUNTER_BUFFER
    static const char* s_ATOMIC_COUNTER_BUFFER = "ATOMIC_COUNTER_BUFFER";
#endif
#ifdef GL_ATOMIC_COUNTER_BUFFER_BINDING
    static const char* s_ATOMIC_COUNTER_BUFFER_BINDING =
      "ATOMIC_COUNTER_BUFFER_BINDING";
#endif
#ifdef GL_ATOMIC_COUNTER_BUFFER_INDEX
    static const char* s_ATOMIC_COUNTER_BUFFER_INDEX =
      "ATOMIC_COUNTER_BUFFER_INDEX";
#endif
#ifdef GL_ATTACHED_SHADERS
    static const char* s_ATTACHED_SHADERS = "ATTACHED_SHADERS";
#endif
#ifdef GL_ATTRIBUTE_ADDRESS_COMMAND_NV
    static const char* s_ATTRIBUTE_ADDRESS_COMMAND_NV =
      "ATTRIBUTE_ADDRESS_COMMAND_NV";
#endif
#ifdef GL_AUTO_GENERATE_MIPMAP
    static const char* s_AUTO_GENERATE_MIPMAP = "AUTO_GENERATE_MIPMAP";
#endif
#ifdef GL_BACK
    static const char* s_BACK = "BACK";
#endif
#ifdef GL_BACK_LEFT
    static const char* s_BACK_LEFT = "BACK_LEFT";
#endif
#ifdef GL_BACK_RIGHT
    static const char* s_BACK_RIGHT = "BACK_RIGHT";
#endif
#ifdef GL_BEVEL_NV
    static const char* s_BEVEL_NV = "BEVEL_NV";
#endif
#ifdef GL_BGR
    static const char* s_BGR = "BGR";
#endif
#ifdef GL_BGRA
    static const char* s_BGRA = "BGRA";
#endif
#ifdef GL_BGRA_INTEGER
    static const char* s_BGRA_INTEGER = "BGRA_INTEGER";
#endif
#ifdef GL_BGR_INTEGER
    static const char* s_BGR_INTEGER = "BGR_INTEGER";
#endif
#ifdef GL_BLEND
    static const char* s_BLEND = "BLEND";
#endif
#ifdef GL_BLEND_ADVANCED_COHERENT_KHR
    static const char* s_BLEND_ADVANCED_COHERENT_KHR =
      "BLEND_ADVANCED_COHERENT_KHR";
#endif
#ifdef GL_BLEND_COLOR
    static const char* s_BLEND_COLOR = "BLEND_COLOR";
#endif
#ifdef GL_BLEND_COLOR_COMMAND_NV
    static const char* s_BLEND_COLOR_COMMAND_NV = "BLEND_COLOR_COMMAND_NV";
#endif
#ifdef GL_BLEND_DST_ALPHA
    static const char* s_BLEND_DST_ALPHA = "BLEND_DST_ALPHA";
#endif
#ifdef GL_BLEND_DST_RGB
    static const char* s_BLEND_DST_RGB = "BLEND_DST_RGB";
#endif
#ifdef GL_BLEND_EQUATION_ALPHA
    static const char* s_BLEND_EQUATION_ALPHA = "BLEND_EQUATION_ALPHA";
#endif
#ifdef GL_BLEND_EQUATION_RGB
    static const char* s_BLEND_EQUATION_RGB = "BLEND_EQUATION_RGB";
#endif
#ifdef GL_BLEND_SRC_ALPHA
    static const char* s_BLEND_SRC_ALPHA = "BLEND_SRC_ALPHA";
#endif
#ifdef GL_BLEND_SRC_RGB
    static const char* s_BLEND_SRC_RGB = "BLEND_SRC_RGB";
#endif
#ifdef GL_BLOCK_INDEX
    static const char* s_BLOCK_INDEX = "BLOCK_INDEX";
#endif
#ifdef GL_BLUE
    static const char* s_BLUE = "BLUE";
#endif
#ifdef GL_BLUE_BIAS
    static const char* s_BLUE_BIAS = "BLUE_BIAS";
#endif
#ifdef GL_BLUE_INTEGER
    static const char* s_BLUE_INTEGER = "BLUE_INTEGER";
#endif
#ifdef GL_BLUE_SCALE
    static const char* s_BLUE_SCALE = "BLUE_SCALE";
#endif
#ifdef GL_BOLD_BIT_NV
    static const char* s_BOLD_BIT_NV = "BOLD_BIT_NV";
#endif
#ifdef GL_BOOL
    static const char* s_BOOL = "BOOL";
#endif
#ifdef GL_BOOL_VEC2
    static const char* s_BOOL_VEC2 = "BOOL_VEC2";
#endif
#ifdef GL_BOOL_VEC3
    static const char* s_BOOL_VEC3 = "BOOL_VEC3";
#endif
#ifdef GL_BOOL_VEC4
    static const char* s_BOOL_VEC4 = "BOOL_VEC4";
#endif
#ifdef GL_BOUNDING_BOX_NV
    static const char* s_BOUNDING_BOX_NV = "BOUNDING_BOX_NV";
#endif
#ifdef GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV
    static const char* s_BOUNDING_BOX_OF_BOUNDING_BOXES_NV =
      "BOUNDING_BOX_OF_BOUNDING_BOXES_NV";
#endif
#ifdef GL_BUFFER
    static const char* s_BUFFER = "BUFFER";
#endif
#ifdef GL_BUFFER_ACCESS
    static const char* s_BUFFER_ACCESS = "BUFFER_ACCESS";
#endif
#ifdef GL_BUFFER_ACCESS_FLAGS
    static const char* s_BUFFER_ACCESS_FLAGS = "BUFFER_ACCESS_FLAGS";
#endif
#ifdef GL_BUFFER_BINDING
    static const char* s_BUFFER_BINDING = "BUFFER_BINDING";
#endif
#ifdef GL_BUFFER_DATA_SIZE
    static const char* s_BUFFER_DATA_SIZE = "BUFFER_DATA_SIZE";
#endif
#ifdef GL_BUFFER_IMMUTABLE_STORAGE
    static const char* s_BUFFER_IMMUTABLE_STORAGE = "BUFFER_IMMUTABLE_STORAGE";
#endif
#ifdef GL_BUFFER_MAPPED
    static const char* s_BUFFER_MAPPED = "BUFFER_MAPPED";
#endif
#ifdef GL_BUFFER_MAP_LENGTH
    static const char* s_BUFFER_MAP_LENGTH = "BUFFER_MAP_LENGTH";
#endif
#ifdef GL_BUFFER_MAP_OFFSET
    static const char* s_BUFFER_MAP_OFFSET = "BUFFER_MAP_OFFSET";
#endif
#ifdef GL_BUFFER_SIZE
    static const char* s_BUFFER_SIZE = "BUFFER_SIZE";
#endif
#ifdef GL_BUFFER_STORAGE_FLAGS
    static const char* s_BUFFER_STORAGE_FLAGS = "BUFFER_STORAGE_FLAGS";
#endif
#ifdef GL_BUFFER_UPDATE_BARRIER_BIT
    static const char* s_BUFFER_UPDATE_BARRIER_BIT =
      "BUFFER_UPDATE_BARRIER_BIT";
#endif
#ifdef GL_BUFFER_USAGE
    static const char* s_BUFFER_USAGE = "BUFFER_USAGE";
#endif
#ifdef GL_BUFFER_VARIABLE
    static const char* s_BUFFER_VARIABLE = "BUFFER_VARIABLE";
#endif
#ifdef GL_BYTE
    static const char* s_BYTE = "BYTE";
#endif
#ifdef GL_CAVEAT_SUPPORT
    static const char* s_CAVEAT_SUPPORT = "CAVEAT_SUPPORT";
#endif
#ifdef GL_CCW
    static const char* s_CCW = "CCW";
#endif
#ifdef GL_CIRCULAR_CCW_ARC_TO_NV
    static const char* s_CIRCULAR_CCW_ARC_TO_NV = "CIRCULAR_CCW_ARC_TO_NV";
#endif
#ifdef GL_CIRCULAR_CW_ARC_TO_NV
    static const char* s_CIRCULAR_CW_ARC_TO_NV = "CIRCULAR_CW_ARC_TO_NV";
#endif
#ifdef GL_CIRCULAR_TANGENT_ARC_TO_NV
    static const char* s_CIRCULAR_TANGENT_ARC_TO_NV =
      "CIRCULAR_TANGENT_ARC_TO_NV";
#endif
#ifdef GL_CLAMP_READ_COLOR
    static const char* s_CLAMP_READ_COLOR = "CLAMP_READ_COLOR";
#endif
#ifdef GL_CLAMP_TO_BORDER
    static const char* s_CLAMP_TO_BORDER = "CLAMP_TO_BORDER";
#endif
#ifdef GL_CLAMP_TO_EDGE
    static const char* s_CLAMP_TO_EDGE = "CLAMP_TO_EDGE";
#endif
#ifdef GL_CLEAR
    static const char* s_CLEAR = "CLEAR";
#endif
#ifdef GL_CLEAR_BUFFER
    static const char* s_CLEAR_BUFFER = "CLEAR_BUFFER";
#endif
#ifdef GL_CLEAR_TEXTURE
    static const char* s_CLEAR_TEXTURE = "CLEAR_TEXTURE";
#endif
#ifdef GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT
    static const char* s_CLIENT_MAPPED_BUFFER_BARRIER_BIT =
      "CLIENT_MAPPED_BUFFER_BARRIER_BIT";
#endif
#ifdef GL_CLIENT_STORAGE_BIT
    static const char* s_CLIENT_STORAGE_BIT = "CLIENT_STORAGE_BIT";
#endif
#ifdef GL_CLIPPING_INPUT_PRIMITIVES_ARB
    static const char* s_CLIPPING_INPUT_PRIMITIVES_ARB =
      "CLIPPING_INPUT_PRIMITIVES_ARB";
#endif
#ifdef GL_CLIPPING_OUTPUT_PRIMITIVES_ARB
    static const char* s_CLIPPING_OUTPUT_PRIMITIVES_ARB =
      "CLIPPING_OUTPUT_PRIMITIVES_ARB";
#endif
#ifdef GL_CLIP_DISTANCE0
    static const char* s_CLIP_DISTANCE0 = "CLIP_DISTANCE0";
#endif
#ifdef GL_CLOSE_PATH_NV
    static const char* s_CLOSE_PATH_NV = "CLOSE_PATH_NV";
#endif
#ifdef GL_COLOR
    static const char* s_COLOR = "COLOR";
#endif
#ifdef GL_COLORBURN_KHR
    static const char* s_COLORBURN_KHR = "COLORBURN_KHR";
#endif
#ifdef GL_COLORDODGE_KHR
    static const char* s_COLORDODGE_KHR = "COLORDODGE_KHR";
#endif
#ifdef GL_COLOR_ARRAY
    static const char* s_COLOR_ARRAY = "COLOR_ARRAY";
#endif
#ifdef GL_COLOR_ARRAY_ADDRESS_NV
    static const char* s_COLOR_ARRAY_ADDRESS_NV = "COLOR_ARRAY_ADDRESS_NV";
#endif
#ifdef GL_COLOR_ATTACHMENT0
    static const char* s_COLOR_ATTACHMENT0 = "COLOR_ATTACHMENT0";
#endif
#ifdef GL_COLOR_BUFFER_BIT
    static const char* s_COLOR_BUFFER_BIT = "COLOR_BUFFER_BIT";
#endif
#ifdef GL_COLOR_CLEAR_VALUE
    static const char* s_COLOR_CLEAR_VALUE = "COLOR_CLEAR_VALUE";
#endif
#ifdef GL_COLOR_COMPONENTS
    static const char* s_COLOR_COMPONENTS = "COLOR_COMPONENTS";
#endif
#ifdef GL_COLOR_ENCODING
    static const char* s_COLOR_ENCODING = "COLOR_ENCODING";
#endif
#ifdef GL_COLOR_LOGIC_OP
    static const char* s_COLOR_LOGIC_OP = "COLOR_LOGIC_OP";
#endif
#ifdef GL_COLOR_RENDERABLE
    static const char* s_COLOR_RENDERABLE = "COLOR_RENDERABLE";
#endif
#ifdef GL_COLOR_WRITEMASK
    static const char* s_COLOR_WRITEMASK = "COLOR_WRITEMASK";
#endif
#ifdef GL_COMMAND_BARRIER_BIT
    static const char* s_COMMAND_BARRIER_BIT = "COMMAND_BARRIER_BIT";
#endif
#ifdef GL_COMPARE_REF_TO_TEXTURE
    static const char* s_COMPARE_REF_TO_TEXTURE = "COMPARE_REF_TO_TEXTURE";
#endif
#ifdef GL_COMPATIBLE_SUBROUTINES
    static const char* s_COMPATIBLE_SUBROUTINES = "COMPATIBLE_SUBROUTINES";
#endif
#ifdef GL_COMPILE_STATUS
    static const char* s_COMPILE_STATUS = "COMPILE_STATUS";
#endif
#ifdef GL_COMPRESSED_R11_EAC
    static const char* s_COMPRESSED_R11_EAC = "COMPRESSED_R11_EAC";
#endif
#ifdef GL_COMPRESSED_RED
    static const char* s_COMPRESSED_RED = "COMPRESSED_RED";
#endif
#ifdef GL_COMPRESSED_RED_RGTC1
    static const char* s_COMPRESSED_RED_RGTC1 = "COMPRESSED_RED_RGTC1";
#endif
#ifdef GL_COMPRESSED_RG
    static const char* s_COMPRESSED_RG = "COMPRESSED_RG";
#endif
#ifdef GL_COMPRESSED_RG11_EAC
    static const char* s_COMPRESSED_RG11_EAC = "COMPRESSED_RG11_EAC";
#endif
#ifdef GL_COMPRESSED_RGB
    static const char* s_COMPRESSED_RGB = "COMPRESSED_RGB";
#endif
#ifdef GL_COMPRESSED_RGB8_ETC2
    static const char* s_COMPRESSED_RGB8_ETC2 = "COMPRESSED_RGB8_ETC2";
#endif
#ifdef GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2
    static const char* s_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 =
      "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
#endif
#ifdef GL_COMPRESSED_RGBA
    static const char* s_COMPRESSED_RGBA = "COMPRESSED_RGBA";
#endif
#ifdef GL_COMPRESSED_RGBA8_ETC2_EAC
    static const char* s_COMPRESSED_RGBA8_ETC2_EAC =
      "COMPRESSED_RGBA8_ETC2_EAC";
#endif
#ifdef GL_COMPRESSED_RGBA_BPTC_UNORM
    static const char* s_COMPRESSED_RGBA_BPTC_UNORM =
      "COMPRESSED_RGBA_BPTC_UNORM";
#endif
#ifdef GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT
    static const char* s_COMPRESSED_RGB_BPTC_SIGNED_FLOAT =
      "COMPRESSED_RGB_BPTC_SIGNED_FLOAT";
#endif
#ifdef GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT
    static const char* s_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT =
      "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT";
#endif
#ifdef GL_COMPRESSED_RG_RGTC2
    static const char* s_COMPRESSED_RG_RGTC2 = "COMPRESSED_RG_RGTC2";
#endif
#ifdef GL_COMPRESSED_SIGNED_R11_EAC
    static const char* s_COMPRESSED_SIGNED_R11_EAC =
      "COMPRESSED_SIGNED_R11_EAC";
#endif
#ifdef GL_COMPRESSED_SIGNED_RED_RGTC1
    static const char* s_COMPRESSED_SIGNED_RED_RGTC1 =
      "COMPRESSED_SIGNED_RED_RGTC1";
#endif
#ifdef GL_COMPRESSED_SIGNED_RG11_EAC
    static const char* s_COMPRESSED_SIGNED_RG11_EAC =
      "COMPRESSED_SIGNED_RG11_EAC";
#endif
#ifdef GL_COMPRESSED_SIGNED_RG_RGTC2
    static const char* s_COMPRESSED_SIGNED_RG_RGTC2 =
      "COMPRESSED_SIGNED_RG_RGTC2";
#endif
#ifdef GL_COMPRESSED_SRGB
    static const char* s_COMPRESSED_SRGB = "COMPRESSED_SRGB";
#endif
#ifdef GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
    static const char* s_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC =
      "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
#endif
#ifdef GL_COMPRESSED_SRGB8_ETC2
    static const char* s_COMPRESSED_SRGB8_ETC2 = "COMPRESSED_SRGB8_ETC2";
#endif
#ifdef GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2
    static const char* s_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 =
      "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
#endif
#ifdef GL_COMPRESSED_SRGB_ALPHA
    static const char* s_COMPRESSED_SRGB_ALPHA = "COMPRESSED_SRGB_ALPHA";
#endif
#ifdef GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM
    static const char* s_COMPRESSED_SRGB_ALPHA_BPTC_UNORM =
      "COMPRESSED_SRGB_ALPHA_BPTC_UNORM";
#endif
#ifdef GL_COMPRESSED_TEXTURE_FORMATS
    static const char* s_COMPRESSED_TEXTURE_FORMATS =
      "COMPRESSED_TEXTURE_FORMATS";
#endif
#ifdef GL_COMPUTE_SHADER
    static const char* s_COMPUTE_SHADER = "COMPUTE_SHADER";
#endif
#ifdef GL_COMPUTE_SHADER_BIT
    static const char* s_COMPUTE_SHADER_BIT = "COMPUTE_SHADER_BIT";
#endif
#ifdef GL_COMPUTE_SHADER_INVOCATIONS_ARB
    static const char* s_COMPUTE_SHADER_INVOCATIONS_ARB =
      "COMPUTE_SHADER_INVOCATIONS_ARB";
#endif
#ifdef GL_COMPUTE_SUBROUTINE
    static const char* s_COMPUTE_SUBROUTINE = "COMPUTE_SUBROUTINE";
#endif
#ifdef GL_COMPUTE_SUBROUTINE_UNIFORM
    static const char* s_COMPUTE_SUBROUTINE_UNIFORM =
      "COMPUTE_SUBROUTINE_UNIFORM";
#endif
#ifdef GL_COMPUTE_TEXTURE
    static const char* s_COMPUTE_TEXTURE = "COMPUTE_TEXTURE";
#endif
#ifdef GL_COMPUTE_WORK_GROUP_SIZE
    static const char* s_COMPUTE_WORK_GROUP_SIZE = "COMPUTE_WORK_GROUP_SIZE";
#endif
#ifdef GL_CONDITION_SATISFIED
    static const char* s_CONDITION_SATISFIED = "CONDITION_SATISFIED";
#endif
#ifdef GL_CONSTANT_ALPHA
    static const char* s_CONSTANT_ALPHA = "CONSTANT_ALPHA";
#endif
#ifdef GL_CONSTANT_COLOR
    static const char* s_CONSTANT_COLOR = "CONSTANT_COLOR";
#endif
#ifdef GL_CONTEXT_COMPATIBILITY_PROFILE_BIT
    static const char* s_CONTEXT_COMPATIBILITY_PROFILE_BIT =
      "CONTEXT_COMPATIBILITY_PROFILE_BIT";
#endif
#ifdef GL_CONTEXT_CORE_PROFILE_BIT
    static const char* s_CONTEXT_CORE_PROFILE_BIT = "CONTEXT_CORE_PROFILE_BIT";
#endif
#ifdef GL_CONTEXT_FLAGS
    static const char* s_CONTEXT_FLAGS = "CONTEXT_FLAGS";
#endif
#ifdef GL_CONTEXT_FLAG_DEBUG_BIT
    static const char* s_CONTEXT_FLAG_DEBUG_BIT = "CONTEXT_FLAG_DEBUG_BIT";
#endif
#ifdef GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT
    static const char* s_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT =
      "CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT";
#endif
#ifdef GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB
    static const char* s_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB =
      "CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB";
#endif
#ifdef GL_CONTEXT_LOST
    static const char* s_CONTEXT_LOST = "CONTEXT_LOST";
#endif
#ifdef GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH
    static const char* s_CONTEXT_RELEASE_BEHAVIOR_FLUSH =
      "CONTEXT_RELEASE_BEHAVIOR_FLUSH";
#endif
#ifdef GL_CONVEX_HULL_NV
    static const char* s_CONVEX_HULL_NV = "CONVEX_HULL_NV";
#endif
#ifdef GL_COPY
    static const char* s_COPY = "COPY";
#endif
#ifdef GL_COPY_INVERTED
    static const char* s_COPY_INVERTED = "COPY_INVERTED";
#endif
#ifdef GL_COPY_READ_BUFFER
    static const char* s_COPY_READ_BUFFER = "COPY_READ_BUFFER";
#endif
#ifdef GL_COPY_READ_BUFFER_BINDING
    static const char* s_COPY_READ_BUFFER_BINDING = "COPY_READ_BUFFER_BINDING";
#endif
#ifdef GL_COPY_WRITE_BUFFER
    static const char* s_COPY_WRITE_BUFFER = "COPY_WRITE_BUFFER";
#endif
#ifdef GL_COPY_WRITE_BUFFER_BINDING
    static const char* s_COPY_WRITE_BUFFER_BINDING =
      "COPY_WRITE_BUFFER_BINDING";
#endif
#ifdef GL_COUNT_DOWN_NV
    static const char* s_COUNT_DOWN_NV = "COUNT_DOWN_NV";
#endif
#ifdef GL_COUNT_UP_NV
    static const char* s_COUNT_UP_NV = "COUNT_UP_NV";
#endif
#ifdef GL_CUBIC_CURVE_TO_NV
    static const char* s_CUBIC_CURVE_TO_NV = "CUBIC_CURVE_TO_NV";
#endif
#ifdef GL_CULL_FACE
    static const char* s_CULL_FACE = "CULL_FACE";
#endif
#ifdef GL_CURRENT_PROGRAM
    static const char* s_CURRENT_PROGRAM = "CURRENT_PROGRAM";
#endif
#ifdef GL_CW
    static const char* s_CW = "CW";
#endif
#ifdef GL_DARKEN_KHR
    static const char* s_DARKEN_KHR = "DARKEN_KHR";
#endif
#ifdef GL_DEBUG_GROUP_STACK_DEPTH
    static const char* s_DEBUG_GROUP_STACK_DEPTH = "DEBUG_GROUP_STACK_DEPTH";
#endif
#ifdef GL_DEBUG_OUTPUT
    static const char* s_DEBUG_OUTPUT = "DEBUG_OUTPUT";
#endif
#ifdef GL_DEBUG_OUTPUT_SYNCHRONOUS
    static const char* s_DEBUG_OUTPUT_SYNCHRONOUS = "DEBUG_OUTPUT_SYNCHRONOUS";
#endif
#ifdef GL_DEBUG_SEVERITY_HIGH
    static const char* s_DEBUG_SEVERITY_HIGH = "DEBUG_SEVERITY_HIGH";
#endif
#ifdef GL_DEBUG_SEVERITY_LOW
    static const char* s_DEBUG_SEVERITY_LOW = "DEBUG_SEVERITY_LOW";
#endif
#ifdef GL_DEBUG_SEVERITY_MEDIUM
    static const char* s_DEBUG_SEVERITY_MEDIUM = "DEBUG_SEVERITY_MEDIUM";
#endif
#ifdef GL_DEBUG_SEVERITY_NOTIFICATION
    static const char* s_DEBUG_SEVERITY_NOTIFICATION =
      "DEBUG_SEVERITY_NOTIFICATION";
#endif
#ifdef GL_DEBUG_SOURCE_API
    static const char* s_DEBUG_SOURCE_API = "DEBUG_SOURCE_API";
#endif
#ifdef GL_DEBUG_SOURCE_APPLICATION
    static const char* s_DEBUG_SOURCE_APPLICATION = "DEBUG_SOURCE_APPLICATION";
#endif
#ifdef GL_DEBUG_SOURCE_OTHER
    static const char* s_DEBUG_SOURCE_OTHER = "DEBUG_SOURCE_OTHER";
#endif
#ifdef GL_DEBUG_SOURCE_SHADER_COMPILER
    static const char* s_DEBUG_SOURCE_SHADER_COMPILER =
      "DEBUG_SOURCE_SHADER_COMPILER";
#endif
#ifdef GL_DEBUG_SOURCE_THIRD_PARTY
    static const char* s_DEBUG_SOURCE_THIRD_PARTY = "DEBUG_SOURCE_THIRD_PARTY";
#endif
#ifdef GL_DEBUG_SOURCE_WINDOW_SYSTEM
    static const char* s_DEBUG_SOURCE_WINDOW_SYSTEM =
      "DEBUG_SOURCE_WINDOW_SYSTEM";
#endif
#ifdef GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR
    static const char* s_DEBUG_TYPE_DEPRECATED_BEHAVIOR =
      "DEBUG_TYPE_DEPRECATED_BEHAVIOR";
#endif
#ifdef GL_DEBUG_TYPE_ERROR
    static const char* s_DEBUG_TYPE_ERROR = "DEBUG_TYPE_ERROR";
#endif
#ifdef GL_DEBUG_TYPE_MARKER
    static const char* s_DEBUG_TYPE_MARKER = "DEBUG_TYPE_MARKER";
#endif
#ifdef GL_DEBUG_TYPE_OTHER
    static const char* s_DEBUG_TYPE_OTHER = "DEBUG_TYPE_OTHER";
#endif
#ifdef GL_DEBUG_TYPE_PERFORMANCE
    static const char* s_DEBUG_TYPE_PERFORMANCE = "DEBUG_TYPE_PERFORMANCE";
#endif
#ifdef GL_DEBUG_TYPE_POP_GROUP
    static const char* s_DEBUG_TYPE_POP_GROUP = "DEBUG_TYPE_POP_GROUP";
#endif
#ifdef GL_DEBUG_TYPE_PORTABILITY
    static const char* s_DEBUG_TYPE_PORTABILITY = "DEBUG_TYPE_PORTABILITY";
#endif
#ifdef GL_DEBUG_TYPE_PUSH_GROUP
    static const char* s_DEBUG_TYPE_PUSH_GROUP = "DEBUG_TYPE_PUSH_GROUP";
#endif
#ifdef GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR
    static const char* s_DEBUG_TYPE_UNDEFINED_BEHAVIOR =
      "DEBUG_TYPE_UNDEFINED_BEHAVIOR";
#endif
#ifdef GL_DECR
    static const char* s_DECR = "DECR";
#endif
#ifdef GL_DECR_WRAP
    static const char* s_DECR_WRAP = "DECR_WRAP";
#endif
#ifdef GL_DELETE_STATUS
    static const char* s_DELETE_STATUS = "DELETE_STATUS";
#endif
#ifdef GL_DEPTH
    static const char* s_DEPTH = "DEPTH";
#endif
#ifdef GL_DEPTH24_STENCIL8
    static const char* s_DEPTH24_STENCIL8 = "DEPTH24_STENCIL8";
#endif
#ifdef GL_DEPTH32F_STENCIL8
    static const char* s_DEPTH32F_STENCIL8 = "DEPTH32F_STENCIL8";
#endif
#ifdef GL_DEPTH_ATTACHMENT
    static const char* s_DEPTH_ATTACHMENT = "DEPTH_ATTACHMENT";
#endif
#ifdef GL_DEPTH_BIAS
    static const char* s_DEPTH_BIAS = "DEPTH_BIAS";
#endif
#ifdef GL_DEPTH_BUFFER_BIT
    static const char* s_DEPTH_BUFFER_BIT = "DEPTH_BUFFER_BIT";
#endif
#ifdef GL_DEPTH_CLEAR_VALUE
    static const char* s_DEPTH_CLEAR_VALUE = "DEPTH_CLEAR_VALUE";
#endif
#ifdef GL_DEPTH_COMPONENT
    static const char* s_DEPTH_COMPONENT = "DEPTH_COMPONENT";
#endif
#ifdef GL_DEPTH_COMPONENT16
    static const char* s_DEPTH_COMPONENT16 = "DEPTH_COMPONENT16";
#endif
#ifdef GL_DEPTH_COMPONENT24
    static const char* s_DEPTH_COMPONENT24 = "DEPTH_COMPONENT24";
#endif
#ifdef GL_DEPTH_COMPONENT32
    static const char* s_DEPTH_COMPONENT32 = "DEPTH_COMPONENT32";
#endif
#ifdef GL_DEPTH_COMPONENT32F
    static const char* s_DEPTH_COMPONENT32F = "DEPTH_COMPONENT32F";
#endif
#ifdef GL_DEPTH_COMPONENTS
    static const char* s_DEPTH_COMPONENTS = "DEPTH_COMPONENTS";
#endif
#ifdef GL_DEPTH_FUNC
    static const char* s_DEPTH_FUNC = "DEPTH_FUNC";
#endif
#ifdef GL_DEPTH_RANGE
    static const char* s_DEPTH_RANGE = "DEPTH_RANGE";
#endif
#ifdef GL_DEPTH_RENDERABLE
    static const char* s_DEPTH_RENDERABLE = "DEPTH_RENDERABLE";
#endif
#ifdef GL_DEPTH_SCALE
    static const char* s_DEPTH_SCALE = "DEPTH_SCALE";
#endif
#ifdef GL_DEPTH_STENCIL
    static const char* s_DEPTH_STENCIL = "DEPTH_STENCIL";
#endif
#ifdef GL_DEPTH_STENCIL_ATTACHMENT
    static const char* s_DEPTH_STENCIL_ATTACHMENT = "DEPTH_STENCIL_ATTACHMENT";
#endif
#ifdef GL_DEPTH_STENCIL_TEXTURE_MODE
    static const char* s_DEPTH_STENCIL_TEXTURE_MODE =
      "DEPTH_STENCIL_TEXTURE_MODE";
#endif
#ifdef GL_DEPTH_TEST
    static const char* s_DEPTH_TEST = "DEPTH_TEST";
#endif
#ifdef GL_DEPTH_WRITEMASK
    static const char* s_DEPTH_WRITEMASK = "DEPTH_WRITEMASK";
#endif
#ifdef GL_DIFFERENCE_KHR
    static const char* s_DIFFERENCE_KHR = "DIFFERENCE_KHR";
#endif
#ifdef GL_DISPATCH_INDIRECT_BUFFER
    static const char* s_DISPATCH_INDIRECT_BUFFER = "DISPATCH_INDIRECT_BUFFER";
#endif
#ifdef GL_DISPATCH_INDIRECT_BUFFER_BINDING
    static const char* s_DISPATCH_INDIRECT_BUFFER_BINDING =
      "DISPATCH_INDIRECT_BUFFER_BINDING";
#endif
#ifdef GL_DITHER
    static const char* s_DITHER = "DITHER";
#endif
#ifdef GL_DONT_CARE
    static const char* s_DONT_CARE = "DONT_CARE";
#endif
#ifdef GL_DOUBLE
    static const char* s_DOUBLE = "DOUBLE";
#endif
#ifdef GL_DOUBLEBUFFER
    static const char* s_DOUBLEBUFFER = "DOUBLEBUFFER";
#endif
#ifdef GL_DOUBLE_MAT2
    static const char* s_DOUBLE_MAT2 = "DOUBLE_MAT2";
#endif
#ifdef GL_DOUBLE_MAT2x3
    static const char* s_DOUBLE_MAT2x3 = "DOUBLE_MAT2x3";
#endif
#ifdef GL_DOUBLE_MAT2x4
    static const char* s_DOUBLE_MAT2x4 = "DOUBLE_MAT2x4";
#endif
#ifdef GL_DOUBLE_MAT3
    static const char* s_DOUBLE_MAT3 = "DOUBLE_MAT3";
#endif
#ifdef GL_DOUBLE_MAT3x2
    static const char* s_DOUBLE_MAT3x2 = "DOUBLE_MAT3x2";
#endif
#ifdef GL_DOUBLE_MAT3x4
    static const char* s_DOUBLE_MAT3x4 = "DOUBLE_MAT3x4";
#endif
#ifdef GL_DOUBLE_MAT4
    static const char* s_DOUBLE_MAT4 = "DOUBLE_MAT4";
#endif
#ifdef GL_DOUBLE_MAT4x2
    static const char* s_DOUBLE_MAT4x2 = "DOUBLE_MAT4x2";
#endif
#ifdef GL_DOUBLE_MAT4x3
    static const char* s_DOUBLE_MAT4x3 = "DOUBLE_MAT4x3";
#endif
#ifdef GL_DOUBLE_VEC2
    static const char* s_DOUBLE_VEC2 = "DOUBLE_VEC2";
#endif
#ifdef GL_DOUBLE_VEC3
    static const char* s_DOUBLE_VEC3 = "DOUBLE_VEC3";
#endif
#ifdef GL_DOUBLE_VEC4
    static const char* s_DOUBLE_VEC4 = "DOUBLE_VEC4";
#endif
#ifdef GL_DRAW_ARRAYS_COMMAND_NV
    static const char* s_DRAW_ARRAYS_COMMAND_NV = "DRAW_ARRAYS_COMMAND_NV";
#endif
#ifdef GL_DRAW_ARRAYS_INSTANCED_COMMAND_NV
    static const char* s_DRAW_ARRAYS_INSTANCED_COMMAND_NV =
      "DRAW_ARRAYS_INSTANCED_COMMAND_NV";
#endif
#ifdef GL_DRAW_ARRAYS_STRIP_COMMAND_NV
    static const char* s_DRAW_ARRAYS_STRIP_COMMAND_NV =
      "DRAW_ARRAYS_STRIP_COMMAND_NV";
#endif
#ifdef GL_DRAW_BUFFER
    static const char* s_DRAW_BUFFER = "DRAW_BUFFER";
#endif
#ifdef GL_DRAW_BUFFER0
    static const char* s_DRAW_BUFFER0 = "DRAW_BUFFER0";
#endif
#ifdef GL_DRAW_ELEMENTS_COMMAND_NV
    static const char* s_DRAW_ELEMENTS_COMMAND_NV = "DRAW_ELEMENTS_COMMAND_NV";
#endif
#ifdef GL_DRAW_ELEMENTS_INSTANCED_COMMAND_NV
    static const char* s_DRAW_ELEMENTS_INSTANCED_COMMAND_NV =
      "DRAW_ELEMENTS_INSTANCED_COMMAND_NV";
#endif
#ifdef GL_DRAW_ELEMENTS_STRIP_COMMAND_NV
    static const char* s_DRAW_ELEMENTS_STRIP_COMMAND_NV =
      "DRAW_ELEMENTS_STRIP_COMMAND_NV";
#endif
#ifdef GL_DRAW_FRAMEBUFFER
    static const char* s_DRAW_FRAMEBUFFER = "DRAW_FRAMEBUFFER";
#endif
#ifdef GL_DRAW_FRAMEBUFFER_BINDING
    static const char* s_DRAW_FRAMEBUFFER_BINDING = "DRAW_FRAMEBUFFER_BINDING";
#endif
#ifdef GL_DRAW_INDIRECT_BUFFER
    static const char* s_DRAW_INDIRECT_BUFFER = "DRAW_INDIRECT_BUFFER";
#endif
#ifdef GL_DRAW_INDIRECT_BUFFER_BINDING
    static const char* s_DRAW_INDIRECT_BUFFER_BINDING =
      "DRAW_INDIRECT_BUFFER_BINDING";
#endif
#ifdef GL_DST_ALPHA
    static const char* s_DST_ALPHA = "DST_ALPHA";
#endif
#ifdef GL_DST_COLOR
    static const char* s_DST_COLOR = "DST_COLOR";
#endif
#ifdef GL_DUP_FIRST_CUBIC_CURVE_TO_NV
    static const char* s_DUP_FIRST_CUBIC_CURVE_TO_NV =
      "DUP_FIRST_CUBIC_CURVE_TO_NV";
#endif
#ifdef GL_DUP_LAST_CUBIC_CURVE_TO_NV
    static const char* s_DUP_LAST_CUBIC_CURVE_TO_NV =
      "DUP_LAST_CUBIC_CURVE_TO_NV";
#endif
#ifdef GL_DYNAMIC_COPY
    static const char* s_DYNAMIC_COPY = "DYNAMIC_COPY";
#endif
#ifdef GL_DYNAMIC_DRAW
    static const char* s_DYNAMIC_DRAW = "DYNAMIC_DRAW";
#endif
#ifdef GL_DYNAMIC_READ
    static const char* s_DYNAMIC_READ = "DYNAMIC_READ";
#endif
#ifdef GL_DYNAMIC_STORAGE_BIT
    static const char* s_DYNAMIC_STORAGE_BIT = "DYNAMIC_STORAGE_BIT";
#endif
#ifdef GL_EDGE_FLAG_ARRAY
    static const char* s_EDGE_FLAG_ARRAY = "EDGE_FLAG_ARRAY";
#endif
#ifdef GL_EDGE_FLAG_ARRAY_ADDRESS_NV
    static const char* s_EDGE_FLAG_ARRAY_ADDRESS_NV =
      "EDGE_FLAG_ARRAY_ADDRESS_NV";
#endif
#ifdef GL_ELEMENT_ADDRESS_COMMAND_NV
    static const char* s_ELEMENT_ADDRESS_COMMAND_NV =
      "ELEMENT_ADDRESS_COMMAND_NV";
#endif
#ifdef GL_ELEMENT_ARRAY_ADDRESS_NV
    static const char* s_ELEMENT_ARRAY_ADDRESS_NV = "ELEMENT_ARRAY_ADDRESS_NV";
#endif
#ifdef GL_ELEMENT_ARRAY_BARRIER_BIT
    static const char* s_ELEMENT_ARRAY_BARRIER_BIT =
      "ELEMENT_ARRAY_BARRIER_BIT";
#endif
#ifdef GL_ELEMENT_ARRAY_BUFFER
    static const char* s_ELEMENT_ARRAY_BUFFER = "ELEMENT_ARRAY_BUFFER";
#endif
#ifdef GL_ELEMENT_ARRAY_BUFFER_BINDING
    static const char* s_ELEMENT_ARRAY_BUFFER_BINDING =
      "ELEMENT_ARRAY_BUFFER_BINDING";
#endif
#ifdef GL_ELEMENT_ARRAY_UNIFIED_NV
    static const char* s_ELEMENT_ARRAY_UNIFIED_NV = "ELEMENT_ARRAY_UNIFIED_NV";
#endif
#ifdef GL_EQUAL
    static const char* s_EQUAL = "EQUAL";
#endif
#ifdef GL_EQUIV
    static const char* s_EQUIV = "EQUIV";
#endif
#ifdef GL_EXCLUSION_KHR
    static const char* s_EXCLUSION_KHR = "EXCLUSION_KHR";
#endif
#ifdef GL_EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD
    static const char* s_EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD =
      "EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD";
#endif
#ifdef GL_EYE_LINEAR
    static const char* s_EYE_LINEAR = "EYE_LINEAR";
#endif
#ifdef GL_FALSE
    static const char* s_FALSE = "FALSE";
#endif
#ifdef GL_FASTEST
    static const char* s_FASTEST = "FASTEST";
#endif
#ifdef GL_FILE_NAME_NV
    static const char* s_FILE_NAME_NV = "FILE_NAME_NV";
#endif
#ifdef GL_FILL
    static const char* s_FILL = "FILL";
#endif
#ifdef GL_FILL_RECTANGLE_NV
    static const char* s_FILL_RECTANGLE_NV = "FILL_RECTANGLE_NV";
#endif
#ifdef GL_FILTER
    static const char* s_FILTER = "FILTER";
#endif
#ifdef GL_FIRST_TO_REST_NV
    static const char* s_FIRST_TO_REST_NV = "FIRST_TO_REST_NV";
#endif
#ifdef GL_FIRST_VERTEX_CONVENTION
    static const char* s_FIRST_VERTEX_CONVENTION = "FIRST_VERTEX_CONVENTION";
#endif
#ifdef GL_FIXED
    static const char* s_FIXED = "FIXED";
#endif
#ifdef GL_FLAT
    static const char* s_FLAT = "FLAT";
#endif
#ifdef GL_FLOAT
    static const char* s_FLOAT = "FLOAT";
#endif
#ifdef GL_FLOAT_32_UNSIGNED_INT_24_8_REV
    static const char* s_FLOAT_32_UNSIGNED_INT_24_8_REV =
      "FLOAT_32_UNSIGNED_INT_24_8_REV";
#endif
#ifdef GL_FLOAT_MAT2
    static const char* s_FLOAT_MAT2 = "FLOAT_MAT2";
#endif
#ifdef GL_FLOAT_MAT2x3
    static const char* s_FLOAT_MAT2x3 = "FLOAT_MAT2x3";
#endif
#ifdef GL_FLOAT_MAT2x4
    static const char* s_FLOAT_MAT2x4 = "FLOAT_MAT2x4";
#endif
#ifdef GL_FLOAT_MAT3
    static const char* s_FLOAT_MAT3 = "FLOAT_MAT3";
#endif
#ifdef GL_FLOAT_MAT3x2
    static const char* s_FLOAT_MAT3x2 = "FLOAT_MAT3x2";
#endif
#ifdef GL_FLOAT_MAT3x4
    static const char* s_FLOAT_MAT3x4 = "FLOAT_MAT3x4";
#endif
#ifdef GL_FLOAT_MAT4
    static const char* s_FLOAT_MAT4 = "FLOAT_MAT4";
#endif
#ifdef GL_FLOAT_MAT4x2
    static const char* s_FLOAT_MAT4x2 = "FLOAT_MAT4x2";
#endif
#ifdef GL_FLOAT_MAT4x3
    static const char* s_FLOAT_MAT4x3 = "FLOAT_MAT4x3";
#endif
#ifdef GL_FLOAT_VEC2
    static const char* s_FLOAT_VEC2 = "FLOAT_VEC2";
#endif
#ifdef GL_FLOAT_VEC3
    static const char* s_FLOAT_VEC3 = "FLOAT_VEC3";
#endif
#ifdef GL_FLOAT_VEC4
    static const char* s_FLOAT_VEC4 = "FLOAT_VEC4";
#endif
#ifdef GL_FOG_COORD_ARRAY
    static const char* s_FOG_COORD_ARRAY = "FOG_COORD_ARRAY";
#endif
#ifdef GL_FOG_COORD_ARRAY_ADDRESS_NV
    static const char* s_FOG_COORD_ARRAY_ADDRESS_NV =
      "FOG_COORD_ARRAY_ADDRESS_NV";
#endif
#ifdef GL_FONT_ASCENDER_BIT_NV
    static const char* s_FONT_ASCENDER_BIT_NV = "FONT_ASCENDER_BIT_NV";
#endif
#ifdef GL_FONT_DESCENDER_BIT_NV
    static const char* s_FONT_DESCENDER_BIT_NV = "FONT_DESCENDER_BIT_NV";
#endif
#ifdef GL_FONT_HAS_KERNING_BIT_NV
    static const char* s_FONT_HAS_KERNING_BIT_NV = "FONT_HAS_KERNING_BIT_NV";
#endif
#ifdef GL_FONT_HEIGHT_BIT_NV
    static const char* s_FONT_HEIGHT_BIT_NV = "FONT_HEIGHT_BIT_NV";
#endif
#ifdef GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV
    static const char* s_FONT_MAX_ADVANCE_HEIGHT_BIT_NV =
      "FONT_MAX_ADVANCE_HEIGHT_BIT_NV";
#endif
#ifdef GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV
    static const char* s_FONT_MAX_ADVANCE_WIDTH_BIT_NV =
      "FONT_MAX_ADVANCE_WIDTH_BIT_NV";
#endif
#ifdef GL_FONT_UNDERLINE_POSITION_BIT_NV
    static const char* s_FONT_UNDERLINE_POSITION_BIT_NV =
      "FONT_UNDERLINE_POSITION_BIT_NV";
#endif
#ifdef GL_FONT_UNDERLINE_THICKNESS_BIT_NV
    static const char* s_FONT_UNDERLINE_THICKNESS_BIT_NV =
      "FONT_UNDERLINE_THICKNESS_BIT_NV";
#endif
#ifdef GL_FONT_UNITS_PER_EM_BIT_NV
    static const char* s_FONT_UNITS_PER_EM_BIT_NV = "FONT_UNITS_PER_EM_BIT_NV";
#endif
#ifdef GL_FONT_X_MAX_BOUNDS_BIT_NV
    static const char* s_FONT_X_MAX_BOUNDS_BIT_NV = "FONT_X_MAX_BOUNDS_BIT_NV";
#endif
#ifdef GL_FONT_X_MIN_BOUNDS_BIT_NV
    static const char* s_FONT_X_MIN_BOUNDS_BIT_NV = "FONT_X_MIN_BOUNDS_BIT_NV";
#endif
#ifdef GL_FONT_Y_MAX_BOUNDS_BIT_NV
    static const char* s_FONT_Y_MAX_BOUNDS_BIT_NV = "FONT_Y_MAX_BOUNDS_BIT_NV";
#endif
#ifdef GL_FONT_Y_MIN_BOUNDS_BIT_NV
    static const char* s_FONT_Y_MIN_BOUNDS_BIT_NV = "FONT_Y_MIN_BOUNDS_BIT_NV";
#endif
#ifdef GL_FRACTIONAL_EVEN
    static const char* s_FRACTIONAL_EVEN = "FRACTIONAL_EVEN";
#endif
#ifdef GL_FRACTIONAL_ODD
    static const char* s_FRACTIONAL_ODD = "FRACTIONAL_ODD";
#endif
#ifdef GL_FRAGMENT_COVERAGE_TO_COLOR_NV
    static const char* s_FRAGMENT_COVERAGE_TO_COLOR_NV =
      "FRAGMENT_COVERAGE_TO_COLOR_NV";
#endif
#ifdef GL_FRAGMENT_SHADER
    static const char* s_FRAGMENT_SHADER = "FRAGMENT_SHADER";
#endif
#ifdef GL_FRAGMENT_SHADER_BIT
    static const char* s_FRAGMENT_SHADER_BIT = "FRAGMENT_SHADER_BIT";
#endif
#ifdef GL_FRAGMENT_SHADER_DERIVATIVE_HINT
    static const char* s_FRAGMENT_SHADER_DERIVATIVE_HINT =
      "FRAGMENT_SHADER_DERIVATIVE_HINT";
#endif
#ifdef GL_FRAGMENT_SHADER_INVOCATIONS_ARB
    static const char* s_FRAGMENT_SHADER_INVOCATIONS_ARB =
      "FRAGMENT_SHADER_INVOCATIONS_ARB";
#endif
#ifdef GL_FRAGMENT_SUBROUTINE
    static const char* s_FRAGMENT_SUBROUTINE = "FRAGMENT_SUBROUTINE";
#endif
#ifdef GL_FRAGMENT_SUBROUTINE_UNIFORM
    static const char* s_FRAGMENT_SUBROUTINE_UNIFORM =
      "FRAGMENT_SUBROUTINE_UNIFORM";
#endif
#ifdef GL_FRAGMENT_TEXTURE
    static const char* s_FRAGMENT_TEXTURE = "FRAGMENT_TEXTURE";
#endif
#ifdef GL_FRAMEBUFFER
    static const char* s_FRAMEBUFFER = "FRAMEBUFFER";
#endif
#ifdef GL_FRAMEBUFFER_BARRIER_BIT
    static const char* s_FRAMEBUFFER_BARRIER_BIT = "FRAMEBUFFER_BARRIER_BIT";
#endif
#ifdef GL_FRAMEBUFFER_BLEND
    static const char* s_FRAMEBUFFER_BLEND = "FRAMEBUFFER_BLEND";
#endif
#ifdef GL_FRAMEBUFFER_COMPLETE
    static const char* s_FRAMEBUFFER_COMPLETE = "FRAMEBUFFER_COMPLETE";
#endif
#ifdef GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS
    static const char* s_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS =
      "FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS";
#endif
#ifdef GL_FRAMEBUFFER_DEFAULT_HEIGHT
    static const char* s_FRAMEBUFFER_DEFAULT_HEIGHT =
      "FRAMEBUFFER_DEFAULT_HEIGHT";
#endif
#ifdef GL_FRAMEBUFFER_DEFAULT_LAYERS
    static const char* s_FRAMEBUFFER_DEFAULT_LAYERS =
      "FRAMEBUFFER_DEFAULT_LAYERS";
#endif
#ifdef GL_FRAMEBUFFER_DEFAULT_SAMPLES
    static const char* s_FRAMEBUFFER_DEFAULT_SAMPLES =
      "FRAMEBUFFER_DEFAULT_SAMPLES";
#endif
#ifdef GL_FRAMEBUFFER_DEFAULT_WIDTH
    static const char* s_FRAMEBUFFER_DEFAULT_WIDTH =
      "FRAMEBUFFER_DEFAULT_WIDTH";
#endif
#ifdef GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
    static const char* s_FRAMEBUFFER_INCOMPLETE_ATTACHMENT =
      "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
#endif
#ifdef GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS
    static const char* s_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS =
      "FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS";
#endif
#ifdef GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT
    static const char* s_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT =
      "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
#endif
#ifdef GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE
    static const char* s_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE =
      "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
#endif
#ifdef GL_FRAMEBUFFER_RENDERABLE
    static const char* s_FRAMEBUFFER_RENDERABLE = "FRAMEBUFFER_RENDERABLE";
#endif
#ifdef GL_FRAMEBUFFER_RENDERABLE_LAYERED
    static const char* s_FRAMEBUFFER_RENDERABLE_LAYERED =
      "FRAMEBUFFER_RENDERABLE_LAYERED";
#endif
#ifdef GL_FRAMEBUFFER_SRGB
    static const char* s_FRAMEBUFFER_SRGB = "FRAMEBUFFER_SRGB";
#endif
#ifdef GL_FRAMEBUFFER_UNDEFINED
    static const char* s_FRAMEBUFFER_UNDEFINED = "FRAMEBUFFER_UNDEFINED";
#endif
#ifdef GL_FRAMEBUFFER_UNSUPPORTED
    static const char* s_FRAMEBUFFER_UNSUPPORTED = "FRAMEBUFFER_UNSUPPORTED";
#endif
#ifdef GL_FRONT
    static const char* s_FRONT = "FRONT";
#endif
#ifdef GL_FRONT_AND_BACK
    static const char* s_FRONT_AND_BACK = "FRONT_AND_BACK";
#endif
#ifdef GL_FRONT_FACE_COMMAND_NV
    static const char* s_FRONT_FACE_COMMAND_NV = "FRONT_FACE_COMMAND_NV";
#endif
#ifdef GL_FRONT_LEFT
    static const char* s_FRONT_LEFT = "FRONT_LEFT";
#endif
#ifdef GL_FRONT_RIGHT
    static const char* s_FRONT_RIGHT = "FRONT_RIGHT";
#endif
#ifdef GL_FULL_SUPPORT
    static const char* s_FULL_SUPPORT = "FULL_SUPPORT";
#endif
#ifdef GL_FUNC_ADD
    static const char* s_FUNC_ADD = "FUNC_ADD";
#endif
#ifdef GL_FUNC_REVERSE_SUBTRACT
    static const char* s_FUNC_REVERSE_SUBTRACT = "FUNC_REVERSE_SUBTRACT";
#endif
#ifdef GL_FUNC_SUBTRACT
    static const char* s_FUNC_SUBTRACT = "FUNC_SUBTRACT";
#endif
#ifdef GL_GENERATE_MIPMAP
    static const char* s_GENERATE_MIPMAP = "GENERATE_MIPMAP";
#endif
#ifdef GL_GEOMETRY_INPUT_TYPE
    static const char* s_GEOMETRY_INPUT_TYPE = "GEOMETRY_INPUT_TYPE";
#endif
#ifdef GL_GEOMETRY_OUTPUT_TYPE
    static const char* s_GEOMETRY_OUTPUT_TYPE = "GEOMETRY_OUTPUT_TYPE";
#endif
#ifdef GL_GEOMETRY_SHADER
    static const char* s_GEOMETRY_SHADER = "GEOMETRY_SHADER";
#endif
#ifdef GL_GEOMETRY_SHADER_BIT
    static const char* s_GEOMETRY_SHADER_BIT = "GEOMETRY_SHADER_BIT";
#endif
#ifdef GL_GEOMETRY_SHADER_INVOCATIONS
    static const char* s_GEOMETRY_SHADER_INVOCATIONS =
      "GEOMETRY_SHADER_INVOCATIONS";
#endif
#ifdef GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED_ARB
    static const char* s_GEOMETRY_SHADER_PRIMITIVES_EMITTED_ARB =
      "GEOMETRY_SHADER_PRIMITIVES_EMITTED_ARB";
#endif
#ifdef GL_GEOMETRY_SUBROUTINE
    static const char* s_GEOMETRY_SUBROUTINE = "GEOMETRY_SUBROUTINE";
#endif
#ifdef GL_GEOMETRY_SUBROUTINE_UNIFORM
    static const char* s_GEOMETRY_SUBROUTINE_UNIFORM =
      "GEOMETRY_SUBROUTINE_UNIFORM";
#endif
#ifdef GL_GEOMETRY_TEXTURE
    static const char* s_GEOMETRY_TEXTURE = "GEOMETRY_TEXTURE";
#endif
#ifdef GL_GEOMETRY_VERTICES_OUT
    static const char* s_GEOMETRY_VERTICES_OUT = "GEOMETRY_VERTICES_OUT";
#endif
#ifdef GL_GEQUAL
    static const char* s_GEQUAL = "GEQUAL";
#endif
#ifdef GL_GET_TEXTURE_IMAGE_FORMAT
    static const char* s_GET_TEXTURE_IMAGE_FORMAT = "GET_TEXTURE_IMAGE_FORMAT";
#endif
#ifdef GL_GET_TEXTURE_IMAGE_TYPE
    static const char* s_GET_TEXTURE_IMAGE_TYPE = "GET_TEXTURE_IMAGE_TYPE";
#endif
#ifdef GL_GLYPH_HAS_KERNING_BIT_NV
    static const char* s_GLYPH_HAS_KERNING_BIT_NV = "GLYPH_HAS_KERNING_BIT_NV";
#endif
#ifdef GL_GLYPH_HEIGHT_BIT_NV
    static const char* s_GLYPH_HEIGHT_BIT_NV = "GLYPH_HEIGHT_BIT_NV";
#endif
#ifdef GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV
    static const char* s_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV =
      "GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV";
#endif
#ifdef GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV
    static const char* s_GLYPH_HORIZONTAL_BEARING_X_BIT_NV =
      "GLYPH_HORIZONTAL_BEARING_X_BIT_NV";
#endif
#ifdef GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV
    static const char* s_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV =
      "GLYPH_HORIZONTAL_BEARING_Y_BIT_NV";
#endif
#ifdef GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV
    static const char* s_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV =
      "GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV";
#endif
#ifdef GL_GLYPH_VERTICAL_BEARING_X_BIT_NV
    static const char* s_GLYPH_VERTICAL_BEARING_X_BIT_NV =
      "GLYPH_VERTICAL_BEARING_X_BIT_NV";
#endif
#ifdef GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV
    static const char* s_GLYPH_VERTICAL_BEARING_Y_BIT_NV =
      "GLYPH_VERTICAL_BEARING_Y_BIT_NV";
#endif
#ifdef GL_GLYPH_WIDTH_BIT_NV
    static const char* s_GLYPH_WIDTH_BIT_NV = "GLYPH_WIDTH_BIT_NV";
#endif
#ifdef GL_GREATER
    static const char* s_GREATER = "GREATER";
#endif
#ifdef GL_GREEN
    static const char* s_GREEN = "GREEN";
#endif
#ifdef GL_GREEN_BIAS
    static const char* s_GREEN_BIAS = "GREEN_BIAS";
#endif
#ifdef GL_GREEN_INTEGER
    static const char* s_GREEN_INTEGER = "GREEN_INTEGER";
#endif
#ifdef GL_GREEN_SCALE
    static const char* s_GREEN_SCALE = "GREEN_SCALE";
#endif
#ifdef GL_GUILTY_CONTEXT_RESET
    static const char* s_GUILTY_CONTEXT_RESET = "GUILTY_CONTEXT_RESET";
#endif
#ifdef GL_HALF_FLOAT
    static const char* s_HALF_FLOAT = "HALF_FLOAT";
#endif
#ifdef GL_HARDLIGHT_KHR
    static const char* s_HARDLIGHT_KHR = "HARDLIGHT_KHR";
#endif
#ifdef GL_HIGH_FLOAT
    static const char* s_HIGH_FLOAT = "HIGH_FLOAT";
#endif
#ifdef GL_HIGH_INT
    static const char* s_HIGH_INT = "HIGH_INT";
#endif
#ifdef GL_HORIZONTAL_LINE_TO_NV
    static const char* s_HORIZONTAL_LINE_TO_NV = "HORIZONTAL_LINE_TO_NV";
#endif
#ifdef GL_HSL_COLOR_KHR
    static const char* s_HSL_COLOR_KHR = "HSL_COLOR_KHR";
#endif
#ifdef GL_HSL_HUE_KHR
    static const char* s_HSL_HUE_KHR = "HSL_HUE_KHR";
#endif
#ifdef GL_HSL_LUMINOSITY_KHR
    static const char* s_HSL_LUMINOSITY_KHR = "HSL_LUMINOSITY_KHR";
#endif
#ifdef GL_HSL_SATURATION_KHR
    static const char* s_HSL_SATURATION_KHR = "HSL_SATURATION_KHR";
#endif
#ifdef GL_IMAGE_1D
    static const char* s_IMAGE_1D = "IMAGE_1D";
#endif
#ifdef GL_IMAGE_1D_ARRAY
    static const char* s_IMAGE_1D_ARRAY = "IMAGE_1D_ARRAY";
#endif
#ifdef GL_IMAGE_2D
    static const char* s_IMAGE_2D = "IMAGE_2D";
#endif
#ifdef GL_IMAGE_2D_ARRAY
    static const char* s_IMAGE_2D_ARRAY = "IMAGE_2D_ARRAY";
#endif
#ifdef GL_IMAGE_2D_MULTISAMPLE
    static const char* s_IMAGE_2D_MULTISAMPLE = "IMAGE_2D_MULTISAMPLE";
#endif
#ifdef GL_IMAGE_2D_MULTISAMPLE_ARRAY
    static const char* s_IMAGE_2D_MULTISAMPLE_ARRAY =
      "IMAGE_2D_MULTISAMPLE_ARRAY";
#endif
#ifdef GL_IMAGE_2D_RECT
    static const char* s_IMAGE_2D_RECT = "IMAGE_2D_RECT";
#endif
#ifdef GL_IMAGE_3D
    static const char* s_IMAGE_3D = "IMAGE_3D";
#endif
#ifdef GL_IMAGE_BUFFER
    static const char* s_IMAGE_BUFFER = "IMAGE_BUFFER";
#endif
#ifdef GL_IMAGE_CLASS_10_10_10_2
    static const char* s_IMAGE_CLASS_10_10_10_2 = "IMAGE_CLASS_10_10_10_2";
#endif
#ifdef GL_IMAGE_CLASS_11_11_10
    static const char* s_IMAGE_CLASS_11_11_10 = "IMAGE_CLASS_11_11_10";
#endif
#ifdef GL_IMAGE_CLASS_1_X_16
    static const char* s_IMAGE_CLASS_1_X_16 = "IMAGE_CLASS_1_X_16";
#endif
#ifdef GL_IMAGE_CLASS_1_X_32
    static const char* s_IMAGE_CLASS_1_X_32 = "IMAGE_CLASS_1_X_32";
#endif
#ifdef GL_IMAGE_CLASS_1_X_8
    static const char* s_IMAGE_CLASS_1_X_8 = "IMAGE_CLASS_1_X_8";
#endif
#ifdef GL_IMAGE_CLASS_2_X_16
    static const char* s_IMAGE_CLASS_2_X_16 = "IMAGE_CLASS_2_X_16";
#endif
#ifdef GL_IMAGE_CLASS_2_X_32
    static const char* s_IMAGE_CLASS_2_X_32 = "IMAGE_CLASS_2_X_32";
#endif
#ifdef GL_IMAGE_CLASS_2_X_8
    static const char* s_IMAGE_CLASS_2_X_8 = "IMAGE_CLASS_2_X_8";
#endif
#ifdef GL_IMAGE_CLASS_4_X_16
    static const char* s_IMAGE_CLASS_4_X_16 = "IMAGE_CLASS_4_X_16";
#endif
#ifdef GL_IMAGE_CLASS_4_X_32
    static const char* s_IMAGE_CLASS_4_X_32 = "IMAGE_CLASS_4_X_32";
#endif
#ifdef GL_IMAGE_CLASS_4_X_8
    static const char* s_IMAGE_CLASS_4_X_8 = "IMAGE_CLASS_4_X_8";
#endif
#ifdef GL_IMAGE_COMPATIBILITY_CLASS
    static const char* s_IMAGE_COMPATIBILITY_CLASS =
      "IMAGE_COMPATIBILITY_CLASS";
#endif
#ifdef GL_IMAGE_CUBE
    static const char* s_IMAGE_CUBE = "IMAGE_CUBE";
#endif
#ifdef GL_IMAGE_FORMAT_COMPATIBILITY_TYPE
    static const char* s_IMAGE_FORMAT_COMPATIBILITY_TYPE =
      "IMAGE_FORMAT_COMPATIBILITY_TYPE";
#endif
#ifdef GL_IMAGE_PIXEL_FORMAT
    static const char* s_IMAGE_PIXEL_FORMAT = "IMAGE_PIXEL_FORMAT";
#endif
#ifdef GL_IMAGE_PIXEL_TYPE
    static const char* s_IMAGE_PIXEL_TYPE = "IMAGE_PIXEL_TYPE";
#endif
#ifdef GL_IMAGE_TEXEL_SIZE
    static const char* s_IMAGE_TEXEL_SIZE = "IMAGE_TEXEL_SIZE";
#endif
#ifdef GL_IMPLEMENTATION_COLOR_READ_FORMAT
    static const char* s_IMPLEMENTATION_COLOR_READ_FORMAT =
      "IMPLEMENTATION_COLOR_READ_FORMAT";
#endif
#ifdef GL_IMPLEMENTATION_COLOR_READ_TYPE
    static const char* s_IMPLEMENTATION_COLOR_READ_TYPE =
      "IMPLEMENTATION_COLOR_READ_TYPE";
#endif
#ifdef GL_INCR
    static const char* s_INCR = "INCR";
#endif
#ifdef GL_INCR_WRAP
    static const char* s_INCR_WRAP = "INCR_WRAP";
#endif
#ifdef GL_INDEX_ARRAY
    static const char* s_INDEX_ARRAY = "INDEX_ARRAY";
#endif
#ifdef GL_INDEX_ARRAY_ADDRESS_NV
    static const char* s_INDEX_ARRAY_ADDRESS_NV = "INDEX_ARRAY_ADDRESS_NV";
#endif
#ifdef GL_INDEX_OFFSET
    static const char* s_INDEX_OFFSET = "INDEX_OFFSET";
#endif
#ifdef GL_INDEX_SHIFT
    static const char* s_INDEX_SHIFT = "INDEX_SHIFT";
#endif
#ifdef GL_INFO_LOG_LENGTH
    static const char* s_INFO_LOG_LENGTH = "INFO_LOG_LENGTH";
#endif
#ifdef GL_INNOCENT_CONTEXT_RESET
    static const char* s_INNOCENT_CONTEXT_RESET = "INNOCENT_CONTEXT_RESET";
#endif
#ifdef GL_INT
    static const char* s_INT = "INT";
#endif
#ifdef GL_INTENSITY
    static const char* s_INTENSITY = "INTENSITY";
#endif
#ifdef GL_INTERLEAVED_ATTRIBS
    static const char* s_INTERLEAVED_ATTRIBS = "INTERLEAVED_ATTRIBS";
#endif
#ifdef GL_INTERNALFORMAT_ALPHA_SIZE
    static const char* s_INTERNALFORMAT_ALPHA_SIZE =
      "INTERNALFORMAT_ALPHA_SIZE";
#endif
#ifdef GL_INTERNALFORMAT_ALPHA_TYPE
    static const char* s_INTERNALFORMAT_ALPHA_TYPE =
      "INTERNALFORMAT_ALPHA_TYPE";
#endif
#ifdef GL_INTERNALFORMAT_BLUE_SIZE
    static const char* s_INTERNALFORMAT_BLUE_SIZE = "INTERNALFORMAT_BLUE_SIZE";
#endif
#ifdef GL_INTERNALFORMAT_BLUE_TYPE
    static const char* s_INTERNALFORMAT_BLUE_TYPE = "INTERNALFORMAT_BLUE_TYPE";
#endif
#ifdef GL_INTERNALFORMAT_DEPTH_SIZE
    static const char* s_INTERNALFORMAT_DEPTH_SIZE =
      "INTERNALFORMAT_DEPTH_SIZE";
#endif
#ifdef GL_INTERNALFORMAT_DEPTH_TYPE
    static const char* s_INTERNALFORMAT_DEPTH_TYPE =
      "INTERNALFORMAT_DEPTH_TYPE";
#endif
#ifdef GL_INTERNALFORMAT_GREEN_SIZE
    static const char* s_INTERNALFORMAT_GREEN_SIZE =
      "INTERNALFORMAT_GREEN_SIZE";
#endif
#ifdef GL_INTERNALFORMAT_GREEN_TYPE
    static const char* s_INTERNALFORMAT_GREEN_TYPE =
      "INTERNALFORMAT_GREEN_TYPE";
#endif
#ifdef GL_INTERNALFORMAT_PREFERRED
    static const char* s_INTERNALFORMAT_PREFERRED = "INTERNALFORMAT_PREFERRED";
#endif
#ifdef GL_INTERNALFORMAT_RED_SIZE
    static const char* s_INTERNALFORMAT_RED_SIZE = "INTERNALFORMAT_RED_SIZE";
#endif
#ifdef GL_INTERNALFORMAT_RED_TYPE
    static const char* s_INTERNALFORMAT_RED_TYPE = "INTERNALFORMAT_RED_TYPE";
#endif
#ifdef GL_INTERNALFORMAT_SHARED_SIZE
    static const char* s_INTERNALFORMAT_SHARED_SIZE =
      "INTERNALFORMAT_SHARED_SIZE";
#endif
#ifdef GL_INTERNALFORMAT_STENCIL_SIZE
    static const char* s_INTERNALFORMAT_STENCIL_SIZE =
      "INTERNALFORMAT_STENCIL_SIZE";
#endif
#ifdef GL_INTERNALFORMAT_STENCIL_TYPE
    static const char* s_INTERNALFORMAT_STENCIL_TYPE =
      "INTERNALFORMAT_STENCIL_TYPE";
#endif
#ifdef GL_INTERNALFORMAT_SUPPORTED
    static const char* s_INTERNALFORMAT_SUPPORTED = "INTERNALFORMAT_SUPPORTED";
#endif
#ifdef GL_INT_IMAGE_1D
    static const char* s_INT_IMAGE_1D = "INT_IMAGE_1D";
#endif
#ifdef GL_INT_IMAGE_1D_ARRAY
    static const char* s_INT_IMAGE_1D_ARRAY = "INT_IMAGE_1D_ARRAY";
#endif
#ifdef GL_INT_IMAGE_2D
    static const char* s_INT_IMAGE_2D = "INT_IMAGE_2D";
#endif
#ifdef GL_INT_IMAGE_2D_ARRAY
    static const char* s_INT_IMAGE_2D_ARRAY = "INT_IMAGE_2D_ARRAY";
#endif
#ifdef GL_INT_IMAGE_2D_MULTISAMPLE
    static const char* s_INT_IMAGE_2D_MULTISAMPLE = "INT_IMAGE_2D_MULTISAMPLE";
#endif
#ifdef GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY
    static const char* s_INT_IMAGE_2D_MULTISAMPLE_ARRAY =
      "INT_IMAGE_2D_MULTISAMPLE_ARRAY";
#endif
#ifdef GL_INT_IMAGE_2D_RECT
    static const char* s_INT_IMAGE_2D_RECT = "INT_IMAGE_2D_RECT";
#endif
#ifdef GL_INT_IMAGE_3D
    static const char* s_INT_IMAGE_3D = "INT_IMAGE_3D";
#endif
#ifdef GL_INT_IMAGE_BUFFER
    static const char* s_INT_IMAGE_BUFFER = "INT_IMAGE_BUFFER";
#endif
#ifdef GL_INT_IMAGE_CUBE
    static const char* s_INT_IMAGE_CUBE = "INT_IMAGE_CUBE";
#endif
#ifdef GL_INT_SAMPLER_1D
    static const char* s_INT_SAMPLER_1D = "INT_SAMPLER_1D";
#endif
#ifdef GL_INT_SAMPLER_1D_ARRAY
    static const char* s_INT_SAMPLER_1D_ARRAY = "INT_SAMPLER_1D_ARRAY";
#endif
#ifdef GL_INT_SAMPLER_2D
    static const char* s_INT_SAMPLER_2D = "INT_SAMPLER_2D";
#endif
#ifdef GL_INT_SAMPLER_2D_ARRAY
    static const char* s_INT_SAMPLER_2D_ARRAY = "INT_SAMPLER_2D_ARRAY";
#endif
#ifdef GL_INT_SAMPLER_2D_MULTISAMPLE
    static const char* s_INT_SAMPLER_2D_MULTISAMPLE =
      "INT_SAMPLER_2D_MULTISAMPLE";
#endif
#ifdef GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY
    static const char* s_INT_SAMPLER_2D_MULTISAMPLE_ARRAY =
      "INT_SAMPLER_2D_MULTISAMPLE_ARRAY";
#endif
#ifdef GL_INT_SAMPLER_2D_RECT
    static const char* s_INT_SAMPLER_2D_RECT = "INT_SAMPLER_2D_RECT";
#endif
#ifdef GL_INT_SAMPLER_3D
    static const char* s_INT_SAMPLER_3D = "INT_SAMPLER_3D";
#endif
#ifdef GL_INT_SAMPLER_BUFFER
    static const char* s_INT_SAMPLER_BUFFER = "INT_SAMPLER_BUFFER";
#endif
#ifdef GL_INT_SAMPLER_CUBE
    static const char* s_INT_SAMPLER_CUBE = "INT_SAMPLER_CUBE";
#endif
#ifdef GL_INT_SAMPLER_CUBE_MAP_ARRAY
    static const char* s_INT_SAMPLER_CUBE_MAP_ARRAY =
      "INT_SAMPLER_CUBE_MAP_ARRAY";
#endif
#ifdef GL_INT_VEC2
    static const char* s_INT_VEC2 = "INT_VEC2";
#endif
#ifdef GL_INT_VEC3
    static const char* s_INT_VEC3 = "INT_VEC3";
#endif
#ifdef GL_INT_VEC4
    static const char* s_INT_VEC4 = "INT_VEC4";
#endif
#ifdef GL_INVALID_ENUM
    static const char* s_INVALID_ENUM = "INVALID_ENUM";
#endif
#ifdef GL_INVALID_FRAMEBUFFER_OPERATION
    static const char* s_INVALID_FRAMEBUFFER_OPERATION =
      "INVALID_FRAMEBUFFER_OPERATION";
#endif
#ifdef GL_INVALID_OPERATION
    static const char* s_INVALID_OPERATION = "INVALID_OPERATION";
#endif
#ifdef GL_INVALID_VALUE
    static const char* s_INVALID_VALUE = "INVALID_VALUE";
#endif
#ifdef GL_INVERT
    static const char* s_INVERT = "INVERT";
#endif
#ifdef GL_ISOLINES
    static const char* s_ISOLINES = "ISOLINES";
#endif
#ifdef GL_IS_PER_PATCH
    static const char* s_IS_PER_PATCH = "IS_PER_PATCH";
#endif
#ifdef GL_IS_ROW_MAJOR
    static const char* s_IS_ROW_MAJOR = "IS_ROW_MAJOR";
#endif
#ifdef GL_ITALIC_BIT_NV
    static const char* s_ITALIC_BIT_NV = "ITALIC_BIT_NV";
#endif
#ifdef GL_KEEP
    static const char* s_KEEP = "KEEP";
#endif
#ifdef GL_LARGE_CCW_ARC_TO_NV
    static const char* s_LARGE_CCW_ARC_TO_NV = "LARGE_CCW_ARC_TO_NV";
#endif
#ifdef GL_LARGE_CW_ARC_TO_NV
    static const char* s_LARGE_CW_ARC_TO_NV = "LARGE_CW_ARC_TO_NV";
#endif
#ifdef GL_LAST_VERTEX_CONVENTION
    static const char* s_LAST_VERTEX_CONVENTION = "LAST_VERTEX_CONVENTION";
#endif
#ifdef GL_LAYER_PROVOKING_VERTEX
    static const char* s_LAYER_PROVOKING_VERTEX = "LAYER_PROVOKING_VERTEX";
#endif
#ifdef GL_LEFT
    static const char* s_LEFT = "LEFT";
#endif
#ifdef GL_LEQUAL
    static const char* s_LEQUAL = "LEQUAL";
#endif
#ifdef GL_LESS
    static const char* s_LESS = "LESS";
#endif
#ifdef GL_LIGHTEN_KHR
    static const char* s_LIGHTEN_KHR = "LIGHTEN_KHR";
#endif
#ifdef GL_LINE
    static const char* s_LINE = "LINE";
#endif
#ifdef GL_LINEAR
    static const char* s_LINEAR = "LINEAR";
#endif
#ifdef GL_LINEAR_MIPMAP_LINEAR
    static const char* s_LINEAR_MIPMAP_LINEAR = "LINEAR_MIPMAP_LINEAR";
#endif
#ifdef GL_LINEAR_MIPMAP_NEAREST
    static const char* s_LINEAR_MIPMAP_NEAREST = "LINEAR_MIPMAP_NEAREST";
#endif
#ifdef GL_LINES
    static const char* s_LINES = "LINES";
#endif
#ifdef GL_LINES_ADJACENCY
    static const char* s_LINES_ADJACENCY = "LINES_ADJACENCY";
#endif
#ifdef GL_LINE_LOOP
    static const char* s_LINE_LOOP = "LINE_LOOP";
#endif
#ifdef GL_LINE_SMOOTH
    static const char* s_LINE_SMOOTH = "LINE_SMOOTH";
#endif
#ifdef GL_LINE_SMOOTH_HINT
    static const char* s_LINE_SMOOTH_HINT = "LINE_SMOOTH_HINT";
#endif
#ifdef GL_LINE_STRIP
    static const char* s_LINE_STRIP = "LINE_STRIP";
#endif
#ifdef GL_LINE_STRIP_ADJACENCY
    static const char* s_LINE_STRIP_ADJACENCY = "LINE_STRIP_ADJACENCY";
#endif
#ifdef GL_LINE_TO_NV
    static const char* s_LINE_TO_NV = "LINE_TO_NV";
#endif
#ifdef GL_LINE_WIDTH
    static const char* s_LINE_WIDTH = "LINE_WIDTH";
#endif
#ifdef GL_LINE_WIDTH_COMMAND_NV
    static const char* s_LINE_WIDTH_COMMAND_NV = "LINE_WIDTH_COMMAND_NV";
#endif
#ifdef GL_LINK_STATUS
    static const char* s_LINK_STATUS = "LINK_STATUS";
#endif
#ifdef GL_LOCATION
    static const char* s_LOCATION = "LOCATION";
#endif
#ifdef GL_LOCATION_COMPONENT
    static const char* s_LOCATION_COMPONENT = "LOCATION_COMPONENT";
#endif
#ifdef GL_LOCATION_INDEX
    static const char* s_LOCATION_INDEX = "LOCATION_INDEX";
#endif
#ifdef GL_LOGIC_OP_MODE
    static const char* s_LOGIC_OP_MODE = "LOGIC_OP_MODE";
#endif
#ifdef GL_LOSE_CONTEXT_ON_RESET
    static const char* s_LOSE_CONTEXT_ON_RESET = "LOSE_CONTEXT_ON_RESET";
#endif
#ifdef GL_LOWER_LEFT
    static const char* s_LOWER_LEFT = "LOWER_LEFT";
#endif
#ifdef GL_LOW_FLOAT
    static const char* s_LOW_FLOAT = "LOW_FLOAT";
#endif
#ifdef GL_LOW_INT
    static const char* s_LOW_INT = "LOW_INT";
#endif
#ifdef GL_LUMINANCE
    static const char* s_LUMINANCE = "LUMINANCE";
#endif
#ifdef GL_LUMINANCE_ALPHA
    static const char* s_LUMINANCE_ALPHA = "LUMINANCE_ALPHA";
#endif
#ifdef GL_MAP_COHERENT_BIT
    static const char* s_MAP_COHERENT_BIT = "MAP_COHERENT_BIT";
#endif
#ifdef GL_MAP_COLOR
    static const char* s_MAP_COLOR = "MAP_COLOR";
#endif
#ifdef GL_MAP_FLUSH_EXPLICIT_BIT
    static const char* s_MAP_FLUSH_EXPLICIT_BIT = "MAP_FLUSH_EXPLICIT_BIT";
#endif
#ifdef GL_MAP_INVALIDATE_BUFFER_BIT
    static const char* s_MAP_INVALIDATE_BUFFER_BIT =
      "MAP_INVALIDATE_BUFFER_BIT";
#endif
#ifdef GL_MAP_INVALIDATE_RANGE_BIT
    static const char* s_MAP_INVALIDATE_RANGE_BIT = "MAP_INVALIDATE_RANGE_BIT";
#endif
#ifdef GL_MAP_PERSISTENT_BIT
    static const char* s_MAP_PERSISTENT_BIT = "MAP_PERSISTENT_BIT";
#endif
#ifdef GL_MAP_READ_BIT
    static const char* s_MAP_READ_BIT = "MAP_READ_BIT";
#endif
#ifdef GL_MAP_STENCIL
    static const char* s_MAP_STENCIL = "MAP_STENCIL";
#endif
#ifdef GL_MAP_UNSYNCHRONIZED_BIT
    static const char* s_MAP_UNSYNCHRONIZED_BIT = "MAP_UNSYNCHRONIZED_BIT";
#endif
#ifdef GL_MAP_WRITE_BIT
    static const char* s_MAP_WRITE_BIT = "MAP_WRITE_BIT";
#endif
#ifdef GL_MATRIX_STRIDE
    static const char* s_MATRIX_STRIDE = "MATRIX_STRIDE";
#endif
#ifdef GL_MAX
    static const char* s_MAX = "MAX";
#endif
#ifdef GL_MAX_3D_TEXTURE_SIZE
    static const char* s_MAX_3D_TEXTURE_SIZE = "MAX_3D_TEXTURE_SIZE";
#endif
#ifdef GL_MAX_ARRAY_TEXTURE_LAYERS
    static const char* s_MAX_ARRAY_TEXTURE_LAYERS = "MAX_ARRAY_TEXTURE_LAYERS";
#endif
#ifdef GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS
    static const char* s_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS =
      "MAX_ATOMIC_COUNTER_BUFFER_BINDINGS";
#endif
#ifdef GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE
    static const char* s_MAX_ATOMIC_COUNTER_BUFFER_SIZE =
      "MAX_ATOMIC_COUNTER_BUFFER_SIZE";
#endif
#ifdef GL_MAX_CLIP_DISTANCES
    static const char* s_MAX_CLIP_DISTANCES = "MAX_CLIP_DISTANCES";
#endif
#ifdef GL_MAX_COLOR_ATTACHMENTS
    static const char* s_MAX_COLOR_ATTACHMENTS = "MAX_COLOR_ATTACHMENTS";
#endif
#ifdef GL_MAX_COLOR_TEXTURE_SAMPLES
    static const char* s_MAX_COLOR_TEXTURE_SAMPLES =
      "MAX_COLOR_TEXTURE_SAMPLES";
#endif
#ifdef GL_MAX_COMBINED_ATOMIC_COUNTERS
    static const char* s_MAX_COMBINED_ATOMIC_COUNTERS =
      "MAX_COMBINED_ATOMIC_COUNTERS";
#endif
#ifdef GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS
    static const char* s_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS =
      "MAX_COMBINED_ATOMIC_COUNTER_BUFFERS";
#endif
#ifdef GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES
    static const char* s_MAX_COMBINED_CLIP_AND_CULL_DISTANCES =
      "MAX_COMBINED_CLIP_AND_CULL_DISTANCES";
#endif
#ifdef GL_MAX_COMBINED_DIMENSIONS
    static const char* s_MAX_COMBINED_DIMENSIONS = "MAX_COMBINED_DIMENSIONS";
#endif
#ifdef GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS
    static const char* s_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS =
      "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS";
#endif
#ifdef GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS
    static const char* s_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS =
      "MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS";
#endif
#ifdef GL_MAX_COMBINED_IMAGE_UNIFORMS
    static const char* s_MAX_COMBINED_IMAGE_UNIFORMS =
      "MAX_COMBINED_IMAGE_UNIFORMS";
#endif
#ifdef GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS
    static const char* s_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS =
      "MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS";
#endif
#ifdef GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS
    static const char* s_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS =
      "MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS";
#endif
#ifdef GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS
    static const char* s_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS =
      "MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS";
#endif
#ifdef GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
    static const char* s_MAX_COMBINED_TEXTURE_IMAGE_UNITS =
      "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
#endif
#ifdef GL_MAX_COMBINED_UNIFORM_BLOCKS
    static const char* s_MAX_COMBINED_UNIFORM_BLOCKS =
      "MAX_COMBINED_UNIFORM_BLOCKS";
#endif
#ifdef GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS
    static const char* s_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS =
      "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS";
#endif
#ifdef GL_MAX_COMPUTE_SHARED_MEMORY_SIZE
    static const char* s_MAX_COMPUTE_SHARED_MEMORY_SIZE =
      "MAX_COMPUTE_SHARED_MEMORY_SIZE";
#endif
#ifdef GL_MAX_COMPUTE_WORK_GROUP_COUNT
    static const char* s_MAX_COMPUTE_WORK_GROUP_COUNT =
      "MAX_COMPUTE_WORK_GROUP_COUNT";
#endif
#ifdef GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS
    static const char* s_MAX_COMPUTE_WORK_GROUP_INVOCATIONS =
      "MAX_COMPUTE_WORK_GROUP_INVOCATIONS";
#endif
#ifdef GL_MAX_COMPUTE_WORK_GROUP_SIZE
    static const char* s_MAX_COMPUTE_WORK_GROUP_SIZE =
      "MAX_COMPUTE_WORK_GROUP_SIZE";
#endif
#ifdef GL_MAX_CUBE_MAP_TEXTURE_SIZE
    static const char* s_MAX_CUBE_MAP_TEXTURE_SIZE =
      "MAX_CUBE_MAP_TEXTURE_SIZE";
#endif
#ifdef GL_MAX_CULL_DISTANCES
    static const char* s_MAX_CULL_DISTANCES = "MAX_CULL_DISTANCES";
#endif
#ifdef GL_MAX_DEPTH
    static const char* s_MAX_DEPTH = "MAX_DEPTH";
#endif
#ifdef GL_MAX_DEPTH_TEXTURE_SAMPLES
    static const char* s_MAX_DEPTH_TEXTURE_SAMPLES =
      "MAX_DEPTH_TEXTURE_SAMPLES";
#endif
#ifdef GL_MAX_DRAW_BUFFERS
    static const char* s_MAX_DRAW_BUFFERS = "MAX_DRAW_BUFFERS";
#endif
#ifdef GL_MAX_DUAL_SOURCE_DRAW_BUFFERS
    static const char* s_MAX_DUAL_SOURCE_DRAW_BUFFERS =
      "MAX_DUAL_SOURCE_DRAW_BUFFERS";
#endif
#ifdef GL_MAX_ELEMENTS_INDICES
    static const char* s_MAX_ELEMENTS_INDICES = "MAX_ELEMENTS_INDICES";
#endif
#ifdef GL_MAX_ELEMENTS_VERTICES
    static const char* s_MAX_ELEMENTS_VERTICES = "MAX_ELEMENTS_VERTICES";
#endif
#ifdef GL_MAX_FRAGMENT_ATOMIC_COUNTERS
    static const char* s_MAX_FRAGMENT_ATOMIC_COUNTERS =
      "MAX_FRAGMENT_ATOMIC_COUNTERS";
#endif
#ifdef GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS
    static const char* s_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS =
      "MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS";
#endif
#ifdef GL_MAX_FRAGMENT_IMAGE_UNIFORMS
    static const char* s_MAX_FRAGMENT_IMAGE_UNIFORMS =
      "MAX_FRAGMENT_IMAGE_UNIFORMS";
#endif
#ifdef GL_MAX_FRAGMENT_INPUT_COMPONENTS
    static const char* s_MAX_FRAGMENT_INPUT_COMPONENTS =
      "MAX_FRAGMENT_INPUT_COMPONENTS";
#endif
#ifdef GL_MAX_FRAGMENT_INTERPOLATION_OFFSET
    static const char* s_MAX_FRAGMENT_INTERPOLATION_OFFSET =
      "MAX_FRAGMENT_INTERPOLATION_OFFSET";
#endif
#ifdef GL_MAX_FRAGMENT_UNIFORM_BLOCKS
    static const char* s_MAX_FRAGMENT_UNIFORM_BLOCKS =
      "MAX_FRAGMENT_UNIFORM_BLOCKS";
#endif
#ifdef GL_MAX_FRAGMENT_UNIFORM_COMPONENTS
    static const char* s_MAX_FRAGMENT_UNIFORM_COMPONENTS =
      "MAX_FRAGMENT_UNIFORM_COMPONENTS";
#endif
#ifdef GL_MAX_FRAGMENT_UNIFORM_VECTORS
    static const char* s_MAX_FRAGMENT_UNIFORM_VECTORS =
      "MAX_FRAGMENT_UNIFORM_VECTORS";
#endif
#ifdef GL_MAX_GEOMETRY_ATOMIC_COUNTERS
    static const char* s_MAX_GEOMETRY_ATOMIC_COUNTERS =
      "MAX_GEOMETRY_ATOMIC_COUNTERS";
#endif
#ifdef GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS
    static const char* s_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS =
      "MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS";
#endif
#ifdef GL_MAX_GEOMETRY_IMAGE_UNIFORMS
    static const char* s_MAX_GEOMETRY_IMAGE_UNIFORMS =
      "MAX_GEOMETRY_IMAGE_UNIFORMS";
#endif
#ifdef GL_MAX_GEOMETRY_INPUT_COMPONENTS
    static const char* s_MAX_GEOMETRY_INPUT_COMPONENTS =
      "MAX_GEOMETRY_INPUT_COMPONENTS";
#endif
#ifdef GL_MAX_GEOMETRY_OUTPUT_COMPONENTS
    static const char* s_MAX_GEOMETRY_OUTPUT_COMPONENTS =
      "MAX_GEOMETRY_OUTPUT_COMPONENTS";
#endif
#ifdef GL_MAX_GEOMETRY_OUTPUT_VERTICES
    static const char* s_MAX_GEOMETRY_OUTPUT_VERTICES =
      "MAX_GEOMETRY_OUTPUT_VERTICES";
#endif
#ifdef GL_MAX_GEOMETRY_SHADER_INVOCATIONS
    static const char* s_MAX_GEOMETRY_SHADER_INVOCATIONS =
      "MAX_GEOMETRY_SHADER_INVOCATIONS";
#endif
#ifdef GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS
    static const char* s_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS =
      "MAX_GEOMETRY_TEXTURE_IMAGE_UNITS";
#endif
#ifdef GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS
    static const char* s_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS =
      "MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS";
#endif
#ifdef GL_MAX_GEOMETRY_UNIFORM_BLOCKS
    static const char* s_MAX_GEOMETRY_UNIFORM_BLOCKS =
      "MAX_GEOMETRY_UNIFORM_BLOCKS";
#endif
#ifdef GL_MAX_GEOMETRY_UNIFORM_COMPONENTS
    static const char* s_MAX_GEOMETRY_UNIFORM_COMPONENTS =
      "MAX_GEOMETRY_UNIFORM_COMPONENTS";
#endif
#ifdef GL_MAX_HEIGHT
    static const char* s_MAX_HEIGHT = "MAX_HEIGHT";
#endif
#ifdef GL_MAX_IMAGE_SAMPLES
    static const char* s_MAX_IMAGE_SAMPLES = "MAX_IMAGE_SAMPLES";
#endif
#ifdef GL_MAX_IMAGE_UNITS
    static const char* s_MAX_IMAGE_UNITS = "MAX_IMAGE_UNITS";
#endif
#ifdef GL_MAX_INTEGER_SAMPLES
    static const char* s_MAX_INTEGER_SAMPLES = "MAX_INTEGER_SAMPLES";
#endif
#ifdef GL_MAX_LAYERS
    static const char* s_MAX_LAYERS = "MAX_LAYERS";
#endif
#ifdef GL_MAX_PATCH_VERTICES
    static const char* s_MAX_PATCH_VERTICES = "MAX_PATCH_VERTICES";
#endif
#ifdef GL_MAX_PROGRAM_TEXEL_OFFSET
    static const char* s_MAX_PROGRAM_TEXEL_OFFSET = "MAX_PROGRAM_TEXEL_OFFSET";
#endif
#ifdef GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET
    static const char* s_MAX_PROGRAM_TEXTURE_GATHER_OFFSET =
      "MAX_PROGRAM_TEXTURE_GATHER_OFFSET";
#endif
#ifdef GL_MAX_RECTANGLE_TEXTURE_SIZE
    static const char* s_MAX_RECTANGLE_TEXTURE_SIZE =
      "MAX_RECTANGLE_TEXTURE_SIZE";
#endif
#ifdef GL_MAX_RENDERBUFFER_SIZE
    static const char* s_MAX_RENDERBUFFER_SIZE = "MAX_RENDERBUFFER_SIZE";
#endif
#ifdef GL_MAX_SAMPLES
    static const char* s_MAX_SAMPLES = "MAX_SAMPLES";
#endif
#ifdef GL_MAX_SAMPLE_MASK_WORDS
    static const char* s_MAX_SAMPLE_MASK_WORDS = "MAX_SAMPLE_MASK_WORDS";
#endif
#ifdef GL_MAX_SERVER_WAIT_TIMEOUT
    static const char* s_MAX_SERVER_WAIT_TIMEOUT = "MAX_SERVER_WAIT_TIMEOUT";
#endif
#ifdef GL_MAX_SUBROUTINES
    static const char* s_MAX_SUBROUTINES = "MAX_SUBROUTINES";
#endif
#ifdef GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS
    static const char* s_MAX_SUBROUTINE_UNIFORM_LOCATIONS =
      "MAX_SUBROUTINE_UNIFORM_LOCATIONS";
#endif
#ifdef GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS
    static const char* s_MAX_TESS_CONTROL_ATOMIC_COUNTERS =
      "MAX_TESS_CONTROL_ATOMIC_COUNTERS";
#endif
#ifdef GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS
    static const char* s_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS =
      "MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS";
#endif
#ifdef GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS
    static const char* s_MAX_TESS_CONTROL_IMAGE_UNIFORMS =
      "MAX_TESS_CONTROL_IMAGE_UNIFORMS";
#endif
#ifdef GL_MAX_TESS_CONTROL_INPUT_COMPONENTS
    static const char* s_MAX_TESS_CONTROL_INPUT_COMPONENTS =
      "MAX_TESS_CONTROL_INPUT_COMPONENTS";
#endif
#ifdef GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS
    static const char* s_MAX_TESS_CONTROL_OUTPUT_COMPONENTS =
      "MAX_TESS_CONTROL_OUTPUT_COMPONENTS";
#endif
#ifdef GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS
    static const char* s_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS =
      "MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS";
#endif
#ifdef GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS
    static const char* s_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS =
      "MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS";
#endif
#ifdef GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS
    static const char* s_MAX_TESS_CONTROL_UNIFORM_BLOCKS =
      "MAX_TESS_CONTROL_UNIFORM_BLOCKS";
#endif
#ifdef GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS
    static const char* s_MAX_TESS_CONTROL_UNIFORM_COMPONENTS =
      "MAX_TESS_CONTROL_UNIFORM_COMPONENTS";
#endif
#ifdef GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS
    static const char* s_MAX_TESS_EVALUATION_ATOMIC_COUNTERS =
      "MAX_TESS_EVALUATION_ATOMIC_COUNTERS";
#endif
#ifdef GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS
    static const char* s_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS =
      "MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS";
#endif
#ifdef GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS
    static const char* s_MAX_TESS_EVALUATION_IMAGE_UNIFORMS =
      "MAX_TESS_EVALUATION_IMAGE_UNIFORMS";
#endif
#ifdef GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS
    static const char* s_MAX_TESS_EVALUATION_INPUT_COMPONENTS =
      "MAX_TESS_EVALUATION_INPUT_COMPONENTS";
#endif
#ifdef GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS
    static const char* s_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS =
      "MAX_TESS_EVALUATION_OUTPUT_COMPONENTS";
#endif
#ifdef GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS
    static const char* s_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS =
      "MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS";
#endif
#ifdef GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS
    static const char* s_MAX_TESS_EVALUATION_UNIFORM_BLOCKS =
      "MAX_TESS_EVALUATION_UNIFORM_BLOCKS";
#endif
#ifdef GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS
    static const char* s_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS =
      "MAX_TESS_EVALUATION_UNIFORM_COMPONENTS";
#endif
#ifdef GL_MAX_TESS_GEN_LEVEL
    static const char* s_MAX_TESS_GEN_LEVEL = "MAX_TESS_GEN_LEVEL";
#endif
#ifdef GL_MAX_TESS_PATCH_COMPONENTS
    static const char* s_MAX_TESS_PATCH_COMPONENTS =
      "MAX_TESS_PATCH_COMPONENTS";
#endif
#ifdef GL_MAX_TEXTURE_BUFFER_SIZE
    static const char* s_MAX_TEXTURE_BUFFER_SIZE = "MAX_TEXTURE_BUFFER_SIZE";
#endif
#ifdef GL_MAX_TEXTURE_IMAGE_UNITS
    static const char* s_MAX_TEXTURE_IMAGE_UNITS = "MAX_TEXTURE_IMAGE_UNITS";
#endif
#ifdef GL_MAX_TEXTURE_LOD_BIAS
    static const char* s_MAX_TEXTURE_LOD_BIAS = "MAX_TEXTURE_LOD_BIAS";
#endif
#ifdef GL_MAX_TEXTURE_SIZE
    static const char* s_MAX_TEXTURE_SIZE = "MAX_TEXTURE_SIZE";
#endif
#ifdef GL_MAX_TRANSFORM_FEEDBACK_BUFFERS
    static const char* s_MAX_TRANSFORM_FEEDBACK_BUFFERS =
      "MAX_TRANSFORM_FEEDBACK_BUFFERS";
#endif
#ifdef GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS
    static const char* s_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS =
      "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS";
#endif
#ifdef GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS
    static const char* s_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS =
      "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS";
#endif
#ifdef GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
    static const char* s_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS =
      "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS";
#endif
#ifdef GL_MAX_UNIFORM_BLOCK_SIZE
    static const char* s_MAX_UNIFORM_BLOCK_SIZE = "MAX_UNIFORM_BLOCK_SIZE";
#endif
#ifdef GL_MAX_UNIFORM_BUFFER_BINDINGS
    static const char* s_MAX_UNIFORM_BUFFER_BINDINGS =
      "MAX_UNIFORM_BUFFER_BINDINGS";
#endif
#ifdef GL_MAX_VARYING_COMPONENTS
    static const char* s_MAX_VARYING_COMPONENTS = "MAX_VARYING_COMPONENTS";
#endif
#ifdef GL_MAX_VARYING_VECTORS
    static const char* s_MAX_VARYING_VECTORS = "MAX_VARYING_VECTORS";
#endif
#ifdef GL_MAX_VERTEX_ATOMIC_COUNTERS
    static const char* s_MAX_VERTEX_ATOMIC_COUNTERS =
      "MAX_VERTEX_ATOMIC_COUNTERS";
#endif
#ifdef GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS
    static const char* s_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS =
      "MAX_VERTEX_ATOMIC_COUNTER_BUFFERS";
#endif
#ifdef GL_MAX_VERTEX_ATTRIBS
    static const char* s_MAX_VERTEX_ATTRIBS = "MAX_VERTEX_ATTRIBS";
#endif
#ifdef GL_MAX_VERTEX_IMAGE_UNIFORMS
    static const char* s_MAX_VERTEX_IMAGE_UNIFORMS =
      "MAX_VERTEX_IMAGE_UNIFORMS";
#endif
#ifdef GL_MAX_VERTEX_OUTPUT_COMPONENTS
    static const char* s_MAX_VERTEX_OUTPUT_COMPONENTS =
      "MAX_VERTEX_OUTPUT_COMPONENTS";
#endif
#ifdef GL_MAX_VERTEX_STREAMS
    static const char* s_MAX_VERTEX_STREAMS = "MAX_VERTEX_STREAMS";
#endif
#ifdef GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
    static const char* s_MAX_VERTEX_TEXTURE_IMAGE_UNITS =
      "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
#endif
#ifdef GL_MAX_VERTEX_UNIFORM_BLOCKS
    static const char* s_MAX_VERTEX_UNIFORM_BLOCKS =
      "MAX_VERTEX_UNIFORM_BLOCKS";
#endif
#ifdef GL_MAX_VERTEX_UNIFORM_COMPONENTS
    static const char* s_MAX_VERTEX_UNIFORM_COMPONENTS =
      "MAX_VERTEX_UNIFORM_COMPONENTS";
#endif
#ifdef GL_MAX_VERTEX_UNIFORM_VECTORS
    static const char* s_MAX_VERTEX_UNIFORM_VECTORS =
      "MAX_VERTEX_UNIFORM_VECTORS";
#endif
#ifdef GL_MAX_VIEWPORTS
    static const char* s_MAX_VIEWPORTS = "MAX_VIEWPORTS";
#endif
#ifdef GL_MAX_VIEWPORT_DIMS
    static const char* s_MAX_VIEWPORT_DIMS = "MAX_VIEWPORT_DIMS";
#endif
#ifdef GL_MAX_WIDTH
    static const char* s_MAX_WIDTH = "MAX_WIDTH";
#endif
#ifdef GL_MEDIUM_FLOAT
    static const char* s_MEDIUM_FLOAT = "MEDIUM_FLOAT";
#endif
#ifdef GL_MEDIUM_INT
    static const char* s_MEDIUM_INT = "MEDIUM_INT";
#endif
#ifdef GL_MIN
    static const char* s_MIN = "MIN";
#endif
#ifdef GL_MIN_FRAGMENT_INTERPOLATION_OFFSET
    static const char* s_MIN_FRAGMENT_INTERPOLATION_OFFSET =
      "MIN_FRAGMENT_INTERPOLATION_OFFSET";
#endif
#ifdef GL_MIN_MAP_BUFFER_ALIGNMENT
    static const char* s_MIN_MAP_BUFFER_ALIGNMENT = "MIN_MAP_BUFFER_ALIGNMENT";
#endif
#ifdef GL_MIN_PROGRAM_TEXEL_OFFSET
    static const char* s_MIN_PROGRAM_TEXEL_OFFSET = "MIN_PROGRAM_TEXEL_OFFSET";
#endif
#ifdef GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET
    static const char* s_MIN_PROGRAM_TEXTURE_GATHER_OFFSET =
      "MIN_PROGRAM_TEXTURE_GATHER_OFFSET";
#endif
#ifdef GL_MIPMAP
    static const char* s_MIPMAP = "MIPMAP";
#endif
#ifdef GL_MIRRORED_REPEAT
    static const char* s_MIRRORED_REPEAT = "MIRRORED_REPEAT";
#endif
#ifdef GL_MIRROR_CLAMP_TO_EDGE
    static const char* s_MIRROR_CLAMP_TO_EDGE = "MIRROR_CLAMP_TO_EDGE";
#endif
#ifdef GL_MITER_REVERT_NV
    static const char* s_MITER_REVERT_NV = "MITER_REVERT_NV";
#endif
#ifdef GL_MITER_TRUNCATE_NV
    static const char* s_MITER_TRUNCATE_NV = "MITER_TRUNCATE_NV";
#endif
#ifdef GL_MODELVIEW
    static const char* s_MODELVIEW = "MODELVIEW";
#endif
#ifdef GL_MOVE_TO_CONTINUES_NV
    static const char* s_MOVE_TO_CONTINUES_NV = "MOVE_TO_CONTINUES_NV";
#endif
#ifdef GL_MOVE_TO_NV
    static const char* s_MOVE_TO_NV = "MOVE_TO_NV";
#endif
#ifdef GL_MOVE_TO_RESET_NV
    static const char* s_MOVE_TO_RESET_NV = "MOVE_TO_RESET_NV";
#endif
#ifdef GL_MULTIPLY_KHR
    static const char* s_MULTIPLY_KHR = "MULTIPLY_KHR";
#endif
#ifdef GL_MULTISAMPLE
    static const char* s_MULTISAMPLE = "MULTISAMPLE";
#endif
#ifdef GL_NAMED_STRING_LENGTH_ARB
    static const char* s_NAMED_STRING_LENGTH_ARB = "NAMED_STRING_LENGTH_ARB";
#endif
#ifdef GL_NAMED_STRING_TYPE_ARB
    static const char* s_NAMED_STRING_TYPE_ARB = "NAMED_STRING_TYPE_ARB";
#endif
#ifdef GL_NAND
    static const char* s_NAND = "NAND";
#endif
#ifdef GL_NEAREST
    static const char* s_NEAREST = "NEAREST";
#endif
#ifdef GL_NEAREST_MIPMAP_LINEAR
    static const char* s_NEAREST_MIPMAP_LINEAR = "NEAREST_MIPMAP_LINEAR";
#endif
#ifdef GL_NEAREST_MIPMAP_NEAREST
    static const char* s_NEAREST_MIPMAP_NEAREST = "NEAREST_MIPMAP_NEAREST";
#endif
#ifdef GL_NEGATIVE_ONE_TO_ONE
    static const char* s_NEGATIVE_ONE_TO_ONE = "NEGATIVE_ONE_TO_ONE";
#endif
#ifdef GL_NEVER
    static const char* s_NEVER = "NEVER";
#endif
#ifdef GL_NICEST
    static const char* s_NICEST = "NICEST";
#endif
#ifdef GL_NONE
    static const char* s_NONE = "NONE";
#endif
#ifdef GL_NOOP
    static const char* s_NOOP = "NOOP";
#endif
#ifdef GL_NOP_COMMAND_NV
    static const char* s_NOP_COMMAND_NV = "NOP_COMMAND_NV";
#endif
#ifdef GL_NOR
    static const char* s_NOR = "NOR";
#endif
#ifdef GL_NORMAL_ARRAY
    static const char* s_NORMAL_ARRAY = "NORMAL_ARRAY";
#endif
#ifdef GL_NORMAL_ARRAY_ADDRESS_NV
    static const char* s_NORMAL_ARRAY_ADDRESS_NV = "NORMAL_ARRAY_ADDRESS_NV";
#endif
#ifdef GL_NOTEQUAL
    static const char* s_NOTEQUAL = "NOTEQUAL";
#endif
#ifdef GL_NO_ERROR
    static const char* s_NO_ERROR = "NO_ERROR";
#endif
#ifdef GL_NO_RESET_NOTIFICATION
    static const char* s_NO_RESET_NOTIFICATION = "NO_RESET_NOTIFICATION";
#endif
#ifdef GL_NUM_ACTIVE_VARIABLES
    static const char* s_NUM_ACTIVE_VARIABLES = "NUM_ACTIVE_VARIABLES";
#endif
#ifdef GL_NUM_COMPATIBLE_SUBROUTINES
    static const char* s_NUM_COMPATIBLE_SUBROUTINES =
      "NUM_COMPATIBLE_SUBROUTINES";
#endif
#ifdef GL_NUM_COMPRESSED_TEXTURE_FORMATS
    static const char* s_NUM_COMPRESSED_TEXTURE_FORMATS =
      "NUM_COMPRESSED_TEXTURE_FORMATS";
#endif
#ifdef GL_NUM_EXTENSIONS
    static const char* s_NUM_EXTENSIONS = "NUM_EXTENSIONS";
#endif
#ifdef GL_NUM_PROGRAM_BINARY_FORMATS
    static const char* s_NUM_PROGRAM_BINARY_FORMATS =
      "NUM_PROGRAM_BINARY_FORMATS";
#endif
#ifdef GL_NUM_SAMPLE_COUNTS
    static const char* s_NUM_SAMPLE_COUNTS = "NUM_SAMPLE_COUNTS";
#endif
#ifdef GL_NUM_SHADER_BINARY_FORMATS
    static const char* s_NUM_SHADER_BINARY_FORMATS =
      "NUM_SHADER_BINARY_FORMATS";
#endif
#ifdef GL_OBJECT_LINEAR
    static const char* s_OBJECT_LINEAR = "OBJECT_LINEAR";
#endif
#ifdef GL_OBJECT_TYPE
    static const char* s_OBJECT_TYPE = "OBJECT_TYPE";
#endif
#ifdef GL_OFFSET
    static const char* s_OFFSET = "OFFSET";
#endif
#ifdef GL_ONE
    static const char* s_ONE = "ONE";
#endif
#ifdef GL_ONE_MINUS_CONSTANT_ALPHA
    static const char* s_ONE_MINUS_CONSTANT_ALPHA = "ONE_MINUS_CONSTANT_ALPHA";
#endif
#ifdef GL_ONE_MINUS_CONSTANT_COLOR
    static const char* s_ONE_MINUS_CONSTANT_COLOR = "ONE_MINUS_CONSTANT_COLOR";
#endif
#ifdef GL_ONE_MINUS_DST_ALPHA
    static const char* s_ONE_MINUS_DST_ALPHA = "ONE_MINUS_DST_ALPHA";
#endif
#ifdef GL_ONE_MINUS_DST_COLOR
    static const char* s_ONE_MINUS_DST_COLOR = "ONE_MINUS_DST_COLOR";
#endif
#ifdef GL_ONE_MINUS_SRC1_ALPHA
    static const char* s_ONE_MINUS_SRC1_ALPHA = "ONE_MINUS_SRC1_ALPHA";
#endif
#ifdef GL_ONE_MINUS_SRC1_COLOR
    static const char* s_ONE_MINUS_SRC1_COLOR = "ONE_MINUS_SRC1_COLOR";
#endif
#ifdef GL_ONE_MINUS_SRC_ALPHA
    static const char* s_ONE_MINUS_SRC_ALPHA = "ONE_MINUS_SRC_ALPHA";
#endif
#ifdef GL_ONE_MINUS_SRC_COLOR
    static const char* s_ONE_MINUS_SRC_COLOR = "ONE_MINUS_SRC_COLOR";
#endif
#ifdef GL_OR
    static const char* s_OR = "OR";
#endif
#ifdef GL_OR_INVERTED
    static const char* s_OR_INVERTED = "OR_INVERTED";
#endif
#ifdef GL_OR_REVERSE
    static const char* s_OR_REVERSE = "OR_REVERSE";
#endif
#ifdef GL_OUT_OF_MEMORY
    static const char* s_OUT_OF_MEMORY = "OUT_OF_MEMORY";
#endif
#ifdef GL_OVERLAY_KHR
    static const char* s_OVERLAY_KHR = "OVERLAY_KHR";
#endif
#ifdef GL_PACK_ALIGNMENT
    static const char* s_PACK_ALIGNMENT = "PACK_ALIGNMENT";
#endif
#ifdef GL_PACK_COMPRESSED_BLOCK_DEPTH
    static const char* s_PACK_COMPRESSED_BLOCK_DEPTH =
      "PACK_COMPRESSED_BLOCK_DEPTH";
#endif
#ifdef GL_PACK_COMPRESSED_BLOCK_HEIGHT
    static const char* s_PACK_COMPRESSED_BLOCK_HEIGHT =
      "PACK_COMPRESSED_BLOCK_HEIGHT";
#endif
#ifdef GL_PACK_COMPRESSED_BLOCK_SIZE
    static const char* s_PACK_COMPRESSED_BLOCK_SIZE =
      "PACK_COMPRESSED_BLOCK_SIZE";
#endif
#ifdef GL_PACK_COMPRESSED_BLOCK_WIDTH
    static const char* s_PACK_COMPRESSED_BLOCK_WIDTH =
      "PACK_COMPRESSED_BLOCK_WIDTH";
#endif
#ifdef GL_PACK_IMAGE_HEIGHT
    static const char* s_PACK_IMAGE_HEIGHT = "PACK_IMAGE_HEIGHT";
#endif
#ifdef GL_PACK_LSB_FIRST
    static const char* s_PACK_LSB_FIRST = "PACK_LSB_FIRST";
#endif
#ifdef GL_PACK_ROW_LENGTH
    static const char* s_PACK_ROW_LENGTH = "PACK_ROW_LENGTH";
#endif
#ifdef GL_PACK_SKIP_IMAGES
    static const char* s_PACK_SKIP_IMAGES = "PACK_SKIP_IMAGES";
#endif
#ifdef GL_PACK_SKIP_PIXELS
    static const char* s_PACK_SKIP_PIXELS = "PACK_SKIP_PIXELS";
#endif
#ifdef GL_PACK_SKIP_ROWS
    static const char* s_PACK_SKIP_ROWS = "PACK_SKIP_ROWS";
#endif
#ifdef GL_PACK_SWAP_BYTES
    static const char* s_PACK_SWAP_BYTES = "PACK_SWAP_BYTES";
#endif
#ifdef GL_PARAMETER_BUFFER_ARB
    static const char* s_PARAMETER_BUFFER_ARB = "PARAMETER_BUFFER_ARB";
#endif
#ifdef GL_PARAMETER_BUFFER_BINDING_ARB
    static const char* s_PARAMETER_BUFFER_BINDING_ARB =
      "PARAMETER_BUFFER_BINDING_ARB";
#endif
#ifdef GL_PATCHES
    static const char* s_PATCHES = "PATCHES";
#endif
#ifdef GL_PATCH_DEFAULT_INNER_LEVEL
    static const char* s_PATCH_DEFAULT_INNER_LEVEL =
      "PATCH_DEFAULT_INNER_LEVEL";
#endif
#ifdef GL_PATCH_DEFAULT_OUTER_LEVEL
    static const char* s_PATCH_DEFAULT_OUTER_LEVEL =
      "PATCH_DEFAULT_OUTER_LEVEL";
#endif
#ifdef GL_PATCH_VERTICES
    static const char* s_PATCH_VERTICES = "PATCH_VERTICES";
#endif
#ifdef GL_PATH_CLIENT_LENGTH_NV
    static const char* s_PATH_CLIENT_LENGTH_NV = "PATH_CLIENT_LENGTH_NV";
#endif
#ifdef GL_PATH_COMMAND_COUNT_NV
    static const char* s_PATH_COMMAND_COUNT_NV = "PATH_COMMAND_COUNT_NV";
#endif
#ifdef GL_PATH_COMPUTED_LENGTH_NV
    static const char* s_PATH_COMPUTED_LENGTH_NV = "PATH_COMPUTED_LENGTH_NV";
#endif
#ifdef GL_PATH_COORD_COUNT_NV
    static const char* s_PATH_COORD_COUNT_NV = "PATH_COORD_COUNT_NV";
#endif
#ifdef GL_PATH_DASH_ARRAY_COUNT_NV
    static const char* s_PATH_DASH_ARRAY_COUNT_NV = "PATH_DASH_ARRAY_COUNT_NV";
#endif
#ifdef GL_PATH_DASH_OFFSET_NV
    static const char* s_PATH_DASH_OFFSET_NV = "PATH_DASH_OFFSET_NV";
#endif
#ifdef GL_PATH_DASH_OFFSET_RESET_NV
    static const char* s_PATH_DASH_OFFSET_RESET_NV =
      "PATH_DASH_OFFSET_RESET_NV";
#endif
#ifdef GL_PATH_FILL_BOUNDING_BOX_NV
    static const char* s_PATH_FILL_BOUNDING_BOX_NV =
      "PATH_FILL_BOUNDING_BOX_NV";
#endif
#ifdef GL_PATH_FILL_COVER_MODE_NV
    static const char* s_PATH_FILL_COVER_MODE_NV = "PATH_FILL_COVER_MODE_NV";
#endif
#ifdef GL_PATH_FILL_MASK_NV
    static const char* s_PATH_FILL_MASK_NV = "PATH_FILL_MASK_NV";
#endif
#ifdef GL_PATH_FILL_MODE_NV
    static const char* s_PATH_FILL_MODE_NV = "PATH_FILL_MODE_NV";
#endif
#ifdef GL_PATH_FORMAT_PS_NV
    static const char* s_PATH_FORMAT_PS_NV = "PATH_FORMAT_PS_NV";
#endif
#ifdef GL_PATH_FORMAT_SVG_NV
    static const char* s_PATH_FORMAT_SVG_NV = "PATH_FORMAT_SVG_NV";
#endif
#ifdef GL_PATH_INITIAL_DASH_CAP_NV
    static const char* s_PATH_INITIAL_DASH_CAP_NV = "PATH_INITIAL_DASH_CAP_NV";
#endif
#ifdef GL_PATH_INITIAL_END_CAP_NV
    static const char* s_PATH_INITIAL_END_CAP_NV = "PATH_INITIAL_END_CAP_NV";
#endif
#ifdef GL_PATH_JOIN_STYLE_NV
    static const char* s_PATH_JOIN_STYLE_NV = "PATH_JOIN_STYLE_NV";
#endif
#ifdef GL_PATH_MITER_LIMIT_NV
    static const char* s_PATH_MITER_LIMIT_NV = "PATH_MITER_LIMIT_NV";
#endif
#ifdef GL_PATH_OBJECT_BOUNDING_BOX_NV
    static const char* s_PATH_OBJECT_BOUNDING_BOX_NV =
      "PATH_OBJECT_BOUNDING_BOX_NV";
#endif
#ifdef GL_PATH_STROKE_BOUNDING_BOX_NV
    static const char* s_PATH_STROKE_BOUNDING_BOX_NV =
      "PATH_STROKE_BOUNDING_BOX_NV";
#endif
#ifdef GL_PATH_STROKE_BOUND_NV
    static const char* s_PATH_STROKE_BOUND_NV = "PATH_STROKE_BOUND_NV";
#endif
#ifdef GL_PATH_STROKE_COVER_MODE_NV
    static const char* s_PATH_STROKE_COVER_MODE_NV =
      "PATH_STROKE_COVER_MODE_NV";
#endif
#ifdef GL_PATH_STROKE_MASK_NV
    static const char* s_PATH_STROKE_MASK_NV = "PATH_STROKE_MASK_NV";
#endif
#ifdef GL_PATH_STROKE_WIDTH_NV
    static const char* s_PATH_STROKE_WIDTH_NV = "PATH_STROKE_WIDTH_NV";
#endif
#ifdef GL_PATH_TERMINAL_DASH_CAP_NV
    static const char* s_PATH_TERMINAL_DASH_CAP_NV =
      "PATH_TERMINAL_DASH_CAP_NV";
#endif
#ifdef GL_PATH_TERMINAL_END_CAP_NV
    static const char* s_PATH_TERMINAL_END_CAP_NV = "PATH_TERMINAL_END_CAP_NV";
#endif
#ifdef GL_PIXEL_BUFFER_BARRIER_BIT
    static const char* s_PIXEL_BUFFER_BARRIER_BIT = "PIXEL_BUFFER_BARRIER_BIT";
#endif
#ifdef GL_PIXEL_PACK_BUFFER
    static const char* s_PIXEL_PACK_BUFFER = "PIXEL_PACK_BUFFER";
#endif
#ifdef GL_PIXEL_PACK_BUFFER_BINDING
    static const char* s_PIXEL_PACK_BUFFER_BINDING =
      "PIXEL_PACK_BUFFER_BINDING";
#endif
#ifdef GL_PIXEL_UNPACK_BUFFER
    static const char* s_PIXEL_UNPACK_BUFFER = "PIXEL_UNPACK_BUFFER";
#endif
#ifdef GL_PIXEL_UNPACK_BUFFER_BINDING
    static const char* s_PIXEL_UNPACK_BUFFER_BINDING =
      "PIXEL_UNPACK_BUFFER_BINDING";
#endif
#ifdef GL_POINT
    static const char* s_POINT = "POINT";
#endif
#ifdef GL_POINTS
    static const char* s_POINTS = "POINTS";
#endif
#ifdef GL_POINT_FADE_THRESHOLD_SIZE
    static const char* s_POINT_FADE_THRESHOLD_SIZE =
      "POINT_FADE_THRESHOLD_SIZE";
#endif
#ifdef GL_POINT_SIZE
    static const char* s_POINT_SIZE = "POINT_SIZE";
#endif
#ifdef GL_POINT_SIZE_GRANULARITY
    static const char* s_POINT_SIZE_GRANULARITY = "POINT_SIZE_GRANULARITY";
#endif
#ifdef GL_POINT_SIZE_MAX
    static const char* s_POINT_SIZE_MAX = "POINT_SIZE_MAX";
#endif
#ifdef GL_POINT_SIZE_MIN
    static const char* s_POINT_SIZE_MIN = "POINT_SIZE_MIN";
#endif
#ifdef GL_POINT_SIZE_RANGE
    static const char* s_POINT_SIZE_RANGE = "POINT_SIZE_RANGE";
#endif
#ifdef GL_POINT_SPRITE_COORD_ORIGIN
    static const char* s_POINT_SPRITE_COORD_ORIGIN =
      "POINT_SPRITE_COORD_ORIGIN";
#endif
#ifdef GL_POLYGON
    static const char* s_POLYGON = "POLYGON";
#endif
#ifdef GL_POLYGON_OFFSET_COMMAND_NV
    static const char* s_POLYGON_OFFSET_COMMAND_NV =
      "POLYGON_OFFSET_COMMAND_NV";
#endif
#ifdef GL_POLYGON_OFFSET_FACTOR
    static const char* s_POLYGON_OFFSET_FACTOR = "POLYGON_OFFSET_FACTOR";
#endif
#ifdef GL_POLYGON_OFFSET_FILL
    static const char* s_POLYGON_OFFSET_FILL = "POLYGON_OFFSET_FILL";
#endif
#ifdef GL_POLYGON_OFFSET_LINE
    static const char* s_POLYGON_OFFSET_LINE = "POLYGON_OFFSET_LINE";
#endif
#ifdef GL_POLYGON_OFFSET_POINT
    static const char* s_POLYGON_OFFSET_POINT = "POLYGON_OFFSET_POINT";
#endif
#ifdef GL_POLYGON_OFFSET_UNITS
    static const char* s_POLYGON_OFFSET_UNITS = "POLYGON_OFFSET_UNITS";
#endif
#ifdef GL_POLYGON_SMOOTH
    static const char* s_POLYGON_SMOOTH = "POLYGON_SMOOTH";
#endif
#ifdef GL_POLYGON_SMOOTH_HINT
    static const char* s_POLYGON_SMOOTH_HINT = "POLYGON_SMOOTH_HINT";
#endif
#ifdef GL_POST_COLOR_MATRIX_ALPHA_BIAS
    static const char* s_POST_COLOR_MATRIX_ALPHA_BIAS =
      "POST_COLOR_MATRIX_ALPHA_BIAS";
#endif
#ifdef GL_POST_COLOR_MATRIX_ALPHA_SCALE
    static const char* s_POST_COLOR_MATRIX_ALPHA_SCALE =
      "POST_COLOR_MATRIX_ALPHA_SCALE";
#endif
#ifdef GL_POST_COLOR_MATRIX_BLUE_BIAS
    static const char* s_POST_COLOR_MATRIX_BLUE_BIAS =
      "POST_COLOR_MATRIX_BLUE_BIAS";
#endif
#ifdef GL_POST_COLOR_MATRIX_BLUE_SCALE
    static const char* s_POST_COLOR_MATRIX_BLUE_SCALE =
      "POST_COLOR_MATRIX_BLUE_SCALE";
#endif
#ifdef GL_POST_COLOR_MATRIX_GREEN_BIAS
    static const char* s_POST_COLOR_MATRIX_GREEN_BIAS =
      "POST_COLOR_MATRIX_GREEN_BIAS";
#endif
#ifdef GL_POST_COLOR_MATRIX_GREEN_SCALE
    static const char* s_POST_COLOR_MATRIX_GREEN_SCALE =
      "POST_COLOR_MATRIX_GREEN_SCALE";
#endif
#ifdef GL_POST_COLOR_MATRIX_RED_BIAS
    static const char* s_POST_COLOR_MATRIX_RED_BIAS =
      "POST_COLOR_MATRIX_RED_BIAS";
#endif
#ifdef GL_POST_COLOR_MATRIX_RED_SCALE
    static const char* s_POST_COLOR_MATRIX_RED_SCALE =
      "POST_COLOR_MATRIX_RED_SCALE";
#endif
#ifdef GL_POST_CONVOLUTION_ALPHA_BIAS
    static const char* s_POST_CONVOLUTION_ALPHA_BIAS =
      "POST_CONVOLUTION_ALPHA_BIAS";
#endif
#ifdef GL_POST_CONVOLUTION_ALPHA_SCALE
    static const char* s_POST_CONVOLUTION_ALPHA_SCALE =
      "POST_CONVOLUTION_ALPHA_SCALE";
#endif
#ifdef GL_POST_CONVOLUTION_BLUE_BIAS
    static const char* s_POST_CONVOLUTION_BLUE_BIAS =
      "POST_CONVOLUTION_BLUE_BIAS";
#endif
#ifdef GL_POST_CONVOLUTION_BLUE_SCALE
    static const char* s_POST_CONVOLUTION_BLUE_SCALE =
      "POST_CONVOLUTION_BLUE_SCALE";
#endif
#ifdef GL_POST_CONVOLUTION_GREEN_BIAS
    static const char* s_POST_CONVOLUTION_GREEN_BIAS =
      "POST_CONVOLUTION_GREEN_BIAS";
#endif
#ifdef GL_POST_CONVOLUTION_GREEN_SCALE
    static const char* s_POST_CONVOLUTION_GREEN_SCALE =
      "POST_CONVOLUTION_GREEN_SCALE";
#endif
#ifdef GL_POST_CONVOLUTION_RED_BIAS
    static const char* s_POST_CONVOLUTION_RED_BIAS =
      "POST_CONVOLUTION_RED_BIAS";
#endif
#ifdef GL_POST_CONVOLUTION_RED_SCALE
    static const char* s_POST_CONVOLUTION_RED_SCALE =
      "POST_CONVOLUTION_RED_SCALE";
#endif
#ifdef GL_PRIMARY_COLOR_NV
    static const char* s_PRIMARY_COLOR_NV = "PRIMARY_COLOR_NV";
#endif
#ifdef GL_PRIMITIVES_GENERATED
    static const char* s_PRIMITIVES_GENERATED = "PRIMITIVES_GENERATED";
#endif
#ifdef GL_PRIMITIVES_SUBMITTED_ARB
    static const char* s_PRIMITIVES_SUBMITTED_ARB = "PRIMITIVES_SUBMITTED_ARB";
#endif
#ifdef GL_PRIMITIVE_RESTART
    static const char* s_PRIMITIVE_RESTART = "PRIMITIVE_RESTART";
#endif
#ifdef GL_PRIMITIVE_RESTART_INDEX
    static const char* s_PRIMITIVE_RESTART_INDEX = "PRIMITIVE_RESTART_INDEX";
#endif
#ifdef GL_PROGRAM
    static const char* s_PROGRAM = "PROGRAM";
#endif
#ifdef GL_PROGRAM_BINARY_FORMATS
    static const char* s_PROGRAM_BINARY_FORMATS = "PROGRAM_BINARY_FORMATS";
#endif
#ifdef GL_PROGRAM_BINARY_LENGTH
    static const char* s_PROGRAM_BINARY_LENGTH = "PROGRAM_BINARY_LENGTH";
#endif
#ifdef GL_PROGRAM_INPUT
    static const char* s_PROGRAM_INPUT = "PROGRAM_INPUT";
#endif
#ifdef GL_PROGRAM_OUTPUT
    static const char* s_PROGRAM_OUTPUT = "PROGRAM_OUTPUT";
#endif
#ifdef GL_PROGRAM_PIPELINE
    static const char* s_PROGRAM_PIPELINE = "PROGRAM_PIPELINE";
#endif
#ifdef GL_PROGRAM_POINT_SIZE
    static const char* s_PROGRAM_POINT_SIZE = "PROGRAM_POINT_SIZE";
#endif
#ifdef GL_PROJECTION
    static const char* s_PROJECTION = "PROJECTION";
#endif
#ifdef GL_PROVOKING_VERTEX
    static const char* s_PROVOKING_VERTEX = "PROVOKING_VERTEX";
#endif
#ifdef GL_QUADRATIC_CURVE_TO_NV
    static const char* s_QUADRATIC_CURVE_TO_NV = "QUADRATIC_CURVE_TO_NV";
#endif
#ifdef GL_QUADS
    static const char* s_QUADS = "QUADS";
#endif
#ifdef GL_QUAD_STRIP
    static const char* s_QUAD_STRIP = "QUAD_STRIP";
#endif
#ifdef GL_QUERY
    static const char* s_QUERY = "QUERY";
#endif
#ifdef GL_QUERY_BUFFER
    static const char* s_QUERY_BUFFER = "QUERY_BUFFER";
#endif
#ifdef GL_QUERY_BUFFER_BINDING
    static const char* s_QUERY_BUFFER_BINDING = "QUERY_BUFFER_BINDING";
#endif
#ifdef GL_QUERY_BY_REGION_NO_WAIT
    static const char* s_QUERY_BY_REGION_NO_WAIT = "QUERY_BY_REGION_NO_WAIT";
#endif
#ifdef GL_QUERY_BY_REGION_NO_WAIT_INVERTED
    static const char* s_QUERY_BY_REGION_NO_WAIT_INVERTED =
      "QUERY_BY_REGION_NO_WAIT_INVERTED";
#endif
#ifdef GL_QUERY_BY_REGION_WAIT
    static const char* s_QUERY_BY_REGION_WAIT = "QUERY_BY_REGION_WAIT";
#endif
#ifdef GL_QUERY_BY_REGION_WAIT_INVERTED
    static const char* s_QUERY_BY_REGION_WAIT_INVERTED =
      "QUERY_BY_REGION_WAIT_INVERTED";
#endif
#ifdef GL_QUERY_NO_WAIT
    static const char* s_QUERY_NO_WAIT = "QUERY_NO_WAIT";
#endif
#ifdef GL_QUERY_NO_WAIT_INVERTED
    static const char* s_QUERY_NO_WAIT_INVERTED = "QUERY_NO_WAIT_INVERTED";
#endif
#ifdef GL_QUERY_RESULT
    static const char* s_QUERY_RESULT = "QUERY_RESULT";
#endif
#ifdef GL_QUERY_RESULT_AVAILABLE
    static const char* s_QUERY_RESULT_AVAILABLE = "QUERY_RESULT_AVAILABLE";
#endif
#ifdef GL_QUERY_WAIT
    static const char* s_QUERY_WAIT = "QUERY_WAIT";
#endif
#ifdef GL_QUERY_WAIT_INVERTED
    static const char* s_QUERY_WAIT_INVERTED = "QUERY_WAIT_INVERTED";
#endif
#ifdef GL_R11F_G11F_B10F
    static const char* s_R11F_G11F_B10F = "R11F_G11F_B10F";
#endif
#ifdef GL_R16
    static const char* s_R16 = "R16";
#endif
#ifdef GL_R16F
    static const char* s_R16F = "R16F";
#endif
#ifdef GL_R16I
    static const char* s_R16I = "R16I";
#endif
#ifdef GL_R16UI
    static const char* s_R16UI = "R16UI";
#endif
#ifdef GL_R16_SNORM
    static const char* s_R16_SNORM = "R16_SNORM";
#endif
#ifdef GL_R32F
    static const char* s_R32F = "R32F";
#endif
#ifdef GL_R32I
    static const char* s_R32I = "R32I";
#endif
#ifdef GL_R32UI
    static const char* s_R32UI = "R32UI";
#endif
#ifdef GL_R3_G3_B2
    static const char* s_R3_G3_B2 = "R3_G3_B2";
#endif
#ifdef GL_R8
    static const char* s_R8 = "R8";
#endif
#ifdef GL_R8I
    static const char* s_R8I = "R8I";
#endif
#ifdef GL_R8UI
    static const char* s_R8UI = "R8UI";
#endif
#ifdef GL_R8_SNORM
    static const char* s_R8_SNORM = "R8_SNORM";
#endif
#ifdef GL_RASTERIZER_DISCARD
    static const char* s_RASTERIZER_DISCARD = "RASTERIZER_DISCARD";
#endif
#ifdef GL_READ_BUFFER
    static const char* s_READ_BUFFER = "READ_BUFFER";
#endif
#ifdef GL_READ_FRAMEBUFFER
    static const char* s_READ_FRAMEBUFFER = "READ_FRAMEBUFFER";
#endif
#ifdef GL_READ_ONLY
    static const char* s_READ_ONLY = "READ_ONLY";
#endif
#ifdef GL_READ_PIXELS
    static const char* s_READ_PIXELS = "READ_PIXELS";
#endif
#ifdef GL_READ_PIXELS_FORMAT
    static const char* s_READ_PIXELS_FORMAT = "READ_PIXELS_FORMAT";
#endif
#ifdef GL_READ_PIXELS_TYPE
    static const char* s_READ_PIXELS_TYPE = "READ_PIXELS_TYPE";
#endif
#ifdef GL_READ_WRITE
    static const char* s_READ_WRITE = "READ_WRITE";
#endif
#ifdef GL_RECT_NV
    static const char* s_RECT_NV = "RECT_NV";
#endif
#ifdef GL_RED
    static const char* s_RED = "RED";
#endif
#ifdef GL_RED_BIAS
    static const char* s_RED_BIAS = "RED_BIAS";
#endif
#ifdef GL_RED_INTEGER
    static const char* s_RED_INTEGER = "RED_INTEGER";
#endif
#ifdef GL_RED_SCALE
    static const char* s_RED_SCALE = "RED_SCALE";
#endif
#ifdef GL_REFERENCED_BY_COMPUTE_SHADER
    static const char* s_REFERENCED_BY_COMPUTE_SHADER =
      "REFERENCED_BY_COMPUTE_SHADER";
#endif
#ifdef GL_REFERENCED_BY_FRAGMENT_SHADER
    static const char* s_REFERENCED_BY_FRAGMENT_SHADER =
      "REFERENCED_BY_FRAGMENT_SHADER";
#endif
#ifdef GL_REFERENCED_BY_GEOMETRY_SHADER
    static const char* s_REFERENCED_BY_GEOMETRY_SHADER =
      "REFERENCED_BY_GEOMETRY_SHADER";
#endif
#ifdef GL_REFERENCED_BY_TESS_CONTROL_SHADER
    static const char* s_REFERENCED_BY_TESS_CONTROL_SHADER =
      "REFERENCED_BY_TESS_CONTROL_SHADER";
#endif
#ifdef GL_REFERENCED_BY_TESS_EVALUATION_SHADER
    static const char* s_REFERENCED_BY_TESS_EVALUATION_SHADER =
      "REFERENCED_BY_TESS_EVALUATION_SHADER";
#endif
#ifdef GL_REFERENCED_BY_VERTEX_SHADER
    static const char* s_REFERENCED_BY_VERTEX_SHADER =
      "REFERENCED_BY_VERTEX_SHADER";
#endif
#ifdef GL_RELATIVE_ARC_TO_NV
    static const char* s_RELATIVE_ARC_TO_NV = "RELATIVE_ARC_TO_NV";
#endif
#ifdef GL_RELATIVE_CUBIC_CURVE_TO_NV
    static const char* s_RELATIVE_CUBIC_CURVE_TO_NV =
      "RELATIVE_CUBIC_CURVE_TO_NV";
#endif
#ifdef GL_RELATIVE_HORIZONTAL_LINE_TO_NV
    static const char* s_RELATIVE_HORIZONTAL_LINE_TO_NV =
      "RELATIVE_HORIZONTAL_LINE_TO_NV";
#endif
#ifdef GL_RELATIVE_LARGE_CCW_ARC_TO_NV
    static const char* s_RELATIVE_LARGE_CCW_ARC_TO_NV =
      "RELATIVE_LARGE_CCW_ARC_TO_NV";
#endif
#ifdef GL_RELATIVE_LARGE_CW_ARC_TO_NV
    static const char* s_RELATIVE_LARGE_CW_ARC_TO_NV =
      "RELATIVE_LARGE_CW_ARC_TO_NV";
#endif
#ifdef GL_RELATIVE_LINE_TO_NV
    static const char* s_RELATIVE_LINE_TO_NV = "RELATIVE_LINE_TO_NV";
#endif
#ifdef GL_RELATIVE_MOVE_TO_NV
    static const char* s_RELATIVE_MOVE_TO_NV = "RELATIVE_MOVE_TO_NV";
#endif
#ifdef GL_RELATIVE_QUADRATIC_CURVE_TO_NV
    static const char* s_RELATIVE_QUADRATIC_CURVE_TO_NV =
      "RELATIVE_QUADRATIC_CURVE_TO_NV";
#endif
#ifdef GL_RELATIVE_SMALL_CCW_ARC_TO_NV
    static const char* s_RELATIVE_SMALL_CCW_ARC_TO_NV =
      "RELATIVE_SMALL_CCW_ARC_TO_NV";
#endif
#ifdef GL_RELATIVE_SMALL_CW_ARC_TO_NV
    static const char* s_RELATIVE_SMALL_CW_ARC_TO_NV =
      "RELATIVE_SMALL_CW_ARC_TO_NV";
#endif
#ifdef GL_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV
    static const char* s_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV =
      "RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV";
#endif
#ifdef GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV
    static const char* s_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV =
      "RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV";
#endif
#ifdef GL_RELATIVE_VERTICAL_LINE_TO_NV
    static const char* s_RELATIVE_VERTICAL_LINE_TO_NV =
      "RELATIVE_VERTICAL_LINE_TO_NV";
#endif
#ifdef GL_RENDERBUFFER
    static const char* s_RENDERBUFFER = "RENDERBUFFER";
#endif
#ifdef GL_RENDERBUFFER_ALPHA_SIZE
    static const char* s_RENDERBUFFER_ALPHA_SIZE = "RENDERBUFFER_ALPHA_SIZE";
#endif
#ifdef GL_RENDERBUFFER_BINDING
    static const char* s_RENDERBUFFER_BINDING = "RENDERBUFFER_BINDING";
#endif
#ifdef GL_RENDERBUFFER_BLUE_SIZE
    static const char* s_RENDERBUFFER_BLUE_SIZE = "RENDERBUFFER_BLUE_SIZE";
#endif
#ifdef GL_RENDERBUFFER_DEPTH_SIZE
    static const char* s_RENDERBUFFER_DEPTH_SIZE = "RENDERBUFFER_DEPTH_SIZE";
#endif
#ifdef GL_RENDERBUFFER_GREEN_SIZE
    static const char* s_RENDERBUFFER_GREEN_SIZE = "RENDERBUFFER_GREEN_SIZE";
#endif
#ifdef GL_RENDERBUFFER_HEIGHT
    static const char* s_RENDERBUFFER_HEIGHT = "RENDERBUFFER_HEIGHT";
#endif
#ifdef GL_RENDERBUFFER_INTERNAL_FORMAT
    static const char* s_RENDERBUFFER_INTERNAL_FORMAT =
      "RENDERBUFFER_INTERNAL_FORMAT";
#endif
#ifdef GL_RENDERBUFFER_RED_SIZE
    static const char* s_RENDERBUFFER_RED_SIZE = "RENDERBUFFER_RED_SIZE";
#endif
#ifdef GL_RENDERBUFFER_SAMPLES
    static const char* s_RENDERBUFFER_SAMPLES = "RENDERBUFFER_SAMPLES";
#endif
#ifdef GL_RENDERBUFFER_STENCIL_SIZE
    static const char* s_RENDERBUFFER_STENCIL_SIZE =
      "RENDERBUFFER_STENCIL_SIZE";
#endif
#ifdef GL_RENDERBUFFER_WIDTH
    static const char* s_RENDERBUFFER_WIDTH = "RENDERBUFFER_WIDTH";
#endif
#ifdef GL_RENDERER
    static const char* s_RENDERER = "RENDERER";
#endif
#ifdef GL_REPEAT
    static const char* s_REPEAT = "REPEAT";
#endif
#ifdef GL_REPLACE
    static const char* s_REPLACE = "REPLACE";
#endif
#ifdef GL_RESTART_PATH_NV
    static const char* s_RESTART_PATH_NV = "RESTART_PATH_NV";
#endif
#ifdef GL_RG
    static const char* s_RG = "RG";
#endif
#ifdef GL_RG16
    static const char* s_RG16 = "RG16";
#endif
#ifdef GL_RG16F
    static const char* s_RG16F = "RG16F";
#endif
#ifdef GL_RG16I
    static const char* s_RG16I = "RG16I";
#endif
#ifdef GL_RG16UI
    static const char* s_RG16UI = "RG16UI";
#endif
#ifdef GL_RG16_SNORM
    static const char* s_RG16_SNORM = "RG16_SNORM";
#endif
#ifdef GL_RG32F
    static const char* s_RG32F = "RG32F";
#endif
#ifdef GL_RG32I
    static const char* s_RG32I = "RG32I";
#endif
#ifdef GL_RG32UI
    static const char* s_RG32UI = "RG32UI";
#endif
#ifdef GL_RG8
    static const char* s_RG8 = "RG8";
#endif
#ifdef GL_RG8I
    static const char* s_RG8I = "RG8I";
#endif
#ifdef GL_RG8UI
    static const char* s_RG8UI = "RG8UI";
#endif
#ifdef GL_RG8_SNORM
    static const char* s_RG8_SNORM = "RG8_SNORM";
#endif
#ifdef GL_RGB
    static const char* s_RGB = "RGB";
#endif
#ifdef GL_RGB10
    static const char* s_RGB10 = "RGB10";
#endif
#ifdef GL_RGB10_A2
    static const char* s_RGB10_A2 = "RGB10_A2";
#endif
#ifdef GL_RGB10_A2UI
    static const char* s_RGB10_A2UI = "RGB10_A2UI";
#endif
#ifdef GL_RGB12
    static const char* s_RGB12 = "RGB12";
#endif
#ifdef GL_RGB16
    static const char* s_RGB16 = "RGB16";
#endif
#ifdef GL_RGB16F
    static const char* s_RGB16F = "RGB16F";
#endif
#ifdef GL_RGB16I
    static const char* s_RGB16I = "RGB16I";
#endif
#ifdef GL_RGB16UI
    static const char* s_RGB16UI = "RGB16UI";
#endif
#ifdef GL_RGB16_SNORM
    static const char* s_RGB16_SNORM = "RGB16_SNORM";
#endif
#ifdef GL_RGB32F
    static const char* s_RGB32F = "RGB32F";
#endif
#ifdef GL_RGB32I
    static const char* s_RGB32I = "RGB32I";
#endif
#ifdef GL_RGB32UI
    static const char* s_RGB32UI = "RGB32UI";
#endif
#ifdef GL_RGB4
    static const char* s_RGB4 = "RGB4";
#endif
#ifdef GL_RGB5
    static const char* s_RGB5 = "RGB5";
#endif
#ifdef GL_RGB5_A1
    static const char* s_RGB5_A1 = "RGB5_A1";
#endif
#ifdef GL_RGB8
    static const char* s_RGB8 = "RGB8";
#endif
#ifdef GL_RGB8I
    static const char* s_RGB8I = "RGB8I";
#endif
#ifdef GL_RGB8UI
    static const char* s_RGB8UI = "RGB8UI";
#endif
#ifdef GL_RGB8_SNORM
    static const char* s_RGB8_SNORM = "RGB8_SNORM";
#endif
#ifdef GL_RGB9_E5
    static const char* s_RGB9_E5 = "RGB9_E5";
#endif
#ifdef GL_RGBA
    static const char* s_RGBA = "RGBA";
#endif
#ifdef GL_RGBA12
    static const char* s_RGBA12 = "RGBA12";
#endif
#ifdef GL_RGBA16
    static const char* s_RGBA16 = "RGBA16";
#endif
#ifdef GL_RGBA16F
    static const char* s_RGBA16F = "RGBA16F";
#endif
#ifdef GL_RGBA16I
    static const char* s_RGBA16I = "RGBA16I";
#endif
#ifdef GL_RGBA16UI
    static const char* s_RGBA16UI = "RGBA16UI";
#endif
#ifdef GL_RGBA16_SNORM
    static const char* s_RGBA16_SNORM = "RGBA16_SNORM";
#endif
#ifdef GL_RGBA2
    static const char* s_RGBA2 = "RGBA2";
#endif
#ifdef GL_RGBA32F
    static const char* s_RGBA32F = "RGBA32F";
#endif
#ifdef GL_RGBA32I
    static const char* s_RGBA32I = "RGBA32I";
#endif
#ifdef GL_RGBA32UI
    static const char* s_RGBA32UI = "RGBA32UI";
#endif
#ifdef GL_RGBA4
    static const char* s_RGBA4 = "RGBA4";
#endif
#ifdef GL_RGBA8
    static const char* s_RGBA8 = "RGBA8";
#endif
#ifdef GL_RGBA8I
    static const char* s_RGBA8I = "RGBA8I";
#endif
#ifdef GL_RGBA8UI
    static const char* s_RGBA8UI = "RGBA8UI";
#endif
#ifdef GL_RGBA8_SNORM
    static const char* s_RGBA8_SNORM = "RGBA8_SNORM";
#endif
#ifdef GL_RGBA_INTEGER
    static const char* s_RGBA_INTEGER = "RGBA_INTEGER";
#endif
#ifdef GL_RGB_INTEGER
    static const char* s_RGB_INTEGER = "RGB_INTEGER";
#endif
#ifdef GL_RG_INTEGER
    static const char* s_RG_INTEGER = "RG_INTEGER";
#endif
#ifdef GL_RIGHT
    static const char* s_RIGHT = "RIGHT";
#endif
#ifdef GL_ROUND_NV
    static const char* s_ROUND_NV = "ROUND_NV";
#endif
#ifdef GL_SAMPLER
    static const char* s_SAMPLER = "SAMPLER";
#endif
#ifdef GL_SAMPLER_1D
    static const char* s_SAMPLER_1D = "SAMPLER_1D";
#endif
#ifdef GL_SAMPLER_1D_ARRAY
    static const char* s_SAMPLER_1D_ARRAY = "SAMPLER_1D_ARRAY";
#endif
#ifdef GL_SAMPLER_1D_ARRAY_SHADOW
    static const char* s_SAMPLER_1D_ARRAY_SHADOW = "SAMPLER_1D_ARRAY_SHADOW";
#endif
#ifdef GL_SAMPLER_1D_SHADOW
    static const char* s_SAMPLER_1D_SHADOW = "SAMPLER_1D_SHADOW";
#endif
#ifdef GL_SAMPLER_2D
    static const char* s_SAMPLER_2D = "SAMPLER_2D";
#endif
#ifdef GL_SAMPLER_2D_ARRAY
    static const char* s_SAMPLER_2D_ARRAY = "SAMPLER_2D_ARRAY";
#endif
#ifdef GL_SAMPLER_2D_ARRAY_SHADOW
    static const char* s_SAMPLER_2D_ARRAY_SHADOW = "SAMPLER_2D_ARRAY_SHADOW";
#endif
#ifdef GL_SAMPLER_2D_MULTISAMPLE
    static const char* s_SAMPLER_2D_MULTISAMPLE = "SAMPLER_2D_MULTISAMPLE";
#endif
#ifdef GL_SAMPLER_2D_MULTISAMPLE_ARRAY
    static const char* s_SAMPLER_2D_MULTISAMPLE_ARRAY =
      "SAMPLER_2D_MULTISAMPLE_ARRAY";
#endif
#ifdef GL_SAMPLER_2D_RECT
    static const char* s_SAMPLER_2D_RECT = "SAMPLER_2D_RECT";
#endif
#ifdef GL_SAMPLER_2D_RECT_SHADOW
    static const char* s_SAMPLER_2D_RECT_SHADOW = "SAMPLER_2D_RECT_SHADOW";
#endif
#ifdef GL_SAMPLER_2D_SHADOW
    static const char* s_SAMPLER_2D_SHADOW = "SAMPLER_2D_SHADOW";
#endif
#ifdef GL_SAMPLER_3D
    static const char* s_SAMPLER_3D = "SAMPLER_3D";
#endif
#ifdef GL_SAMPLER_BINDING
    static const char* s_SAMPLER_BINDING = "SAMPLER_BINDING";
#endif
#ifdef GL_SAMPLER_BUFFER
    static const char* s_SAMPLER_BUFFER = "SAMPLER_BUFFER";
#endif
#ifdef GL_SAMPLER_CUBE
    static const char* s_SAMPLER_CUBE = "SAMPLER_CUBE";
#endif
#ifdef GL_SAMPLER_CUBE_MAP_ARRAY
    static const char* s_SAMPLER_CUBE_MAP_ARRAY = "SAMPLER_CUBE_MAP_ARRAY";
#endif
#ifdef GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW
    static const char* s_SAMPLER_CUBE_MAP_ARRAY_SHADOW =
      "SAMPLER_CUBE_MAP_ARRAY_SHADOW";
#endif
#ifdef GL_SAMPLER_CUBE_SHADOW
    static const char* s_SAMPLER_CUBE_SHADOW = "SAMPLER_CUBE_SHADOW";
#endif
#ifdef GL_SAMPLES
    static const char* s_SAMPLES = "SAMPLES";
#endif
#ifdef GL_SAMPLES_PASSED
    static const char* s_SAMPLES_PASSED = "SAMPLES_PASSED";
#endif
#ifdef GL_SAMPLE_ALPHA_TO_COVERAGE
    static const char* s_SAMPLE_ALPHA_TO_COVERAGE = "SAMPLE_ALPHA_TO_COVERAGE";
#endif
#ifdef GL_SAMPLE_ALPHA_TO_ONE
    static const char* s_SAMPLE_ALPHA_TO_ONE = "SAMPLE_ALPHA_TO_ONE";
#endif
#ifdef GL_SAMPLE_BUFFERS
    static const char* s_SAMPLE_BUFFERS = "SAMPLE_BUFFERS";
#endif
#ifdef GL_SAMPLE_COVERAGE
    static const char* s_SAMPLE_COVERAGE = "SAMPLE_COVERAGE";
#endif
#ifdef GL_SAMPLE_COVERAGE_INVERT
    static const char* s_SAMPLE_COVERAGE_INVERT = "SAMPLE_COVERAGE_INVERT";
#endif
#ifdef GL_SAMPLE_COVERAGE_VALUE
    static const char* s_SAMPLE_COVERAGE_VALUE = "SAMPLE_COVERAGE_VALUE";
#endif
#ifdef GL_SAMPLE_MASK
    static const char* s_SAMPLE_MASK = "SAMPLE_MASK";
#endif
#ifdef GL_SAMPLE_SHADING
    static const char* s_SAMPLE_SHADING = "SAMPLE_SHADING";
#endif
#ifdef GL_SCISSOR_BOX
    static const char* s_SCISSOR_BOX = "SCISSOR_BOX";
#endif
#ifdef GL_SCISSOR_COMMAND_NV
    static const char* s_SCISSOR_COMMAND_NV = "SCISSOR_COMMAND_NV";
#endif
#ifdef GL_SCISSOR_TEST
    static const char* s_SCISSOR_TEST = "SCISSOR_TEST";
#endif
#ifdef GL_SCREEN_KHR
    static const char* s_SCREEN_KHR = "SCREEN_KHR";
#endif
#ifdef GL_SECONDARY_COLOR_ARRAY
    static const char* s_SECONDARY_COLOR_ARRAY = "SECONDARY_COLOR_ARRAY";
#endif
#ifdef GL_SECONDARY_COLOR_ARRAY_ADDRESS_NV
    static const char* s_SECONDARY_COLOR_ARRAY_ADDRESS_NV =
      "SECONDARY_COLOR_ARRAY_ADDRESS_NV";
#endif
#ifdef GL_SECONDARY_COLOR_NV
    static const char* s_SECONDARY_COLOR_NV = "SECONDARY_COLOR_NV";
#endif
#ifdef GL_SEPARATE_ATTRIBS
    static const char* s_SEPARATE_ATTRIBS = "SEPARATE_ATTRIBS";
#endif
#ifdef GL_SET
    static const char* s_SET = "SET";
#endif
#ifdef GL_SHADER
    static const char* s_SHADER = "SHADER";
#endif
#ifdef GL_SHADER_COMPILER
    static const char* s_SHADER_COMPILER = "SHADER_COMPILER";
#endif
#ifdef GL_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV
    static const char* s_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV =
      "SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV";
#endif
#ifdef GL_SHADER_IMAGE_ACCESS_BARRIER_BIT
    static const char* s_SHADER_IMAGE_ACCESS_BARRIER_BIT =
      "SHADER_IMAGE_ACCESS_BARRIER_BIT";
#endif
#ifdef GL_SHADER_IMAGE_ATOMIC
    static const char* s_SHADER_IMAGE_ATOMIC = "SHADER_IMAGE_ATOMIC";
#endif
#ifdef GL_SHADER_IMAGE_LOAD
    static const char* s_SHADER_IMAGE_LOAD = "SHADER_IMAGE_LOAD";
#endif
#ifdef GL_SHADER_IMAGE_STORE
    static const char* s_SHADER_IMAGE_STORE = "SHADER_IMAGE_STORE";
#endif
#ifdef GL_SHADER_INCLUDE_ARB
    static const char* s_SHADER_INCLUDE_ARB = "SHADER_INCLUDE_ARB";
#endif
#ifdef GL_SHADER_SOURCE_LENGTH
    static const char* s_SHADER_SOURCE_LENGTH = "SHADER_SOURCE_LENGTH";
#endif
#ifdef GL_SHADER_STORAGE_BARRIER_BIT
    static const char* s_SHADER_STORAGE_BARRIER_BIT =
      "SHADER_STORAGE_BARRIER_BIT";
#endif
#ifdef GL_SHADER_STORAGE_BLOCK
    static const char* s_SHADER_STORAGE_BLOCK = "SHADER_STORAGE_BLOCK";
#endif
#ifdef GL_SHADER_STORAGE_BUFFER
    static const char* s_SHADER_STORAGE_BUFFER = "SHADER_STORAGE_BUFFER";
#endif
#ifdef GL_SHADER_STORAGE_BUFFER_BINDING
    static const char* s_SHADER_STORAGE_BUFFER_BINDING =
      "SHADER_STORAGE_BUFFER_BINDING";
#endif
#ifdef GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT
    static const char* s_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT =
      "SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT";
#endif
#ifdef GL_SHADER_STORAGE_BUFFER_SIZE
    static const char* s_SHADER_STORAGE_BUFFER_SIZE =
      "SHADER_STORAGE_BUFFER_SIZE";
#endif
#ifdef GL_SHADER_STORAGE_BUFFER_START
    static const char* s_SHADER_STORAGE_BUFFER_START =
      "SHADER_STORAGE_BUFFER_START";
#endif
#ifdef GL_SHADER_TYPE
    static const char* s_SHADER_TYPE = "SHADER_TYPE";
#endif
#ifdef GL_SHADING_LANGUAGE_VERSION
    static const char* s_SHADING_LANGUAGE_VERSION = "SHADING_LANGUAGE_VERSION";
#endif
#ifdef GL_SHORT
    static const char* s_SHORT = "SHORT";
#endif
#ifdef GL_SIGNALED
    static const char* s_SIGNALED = "SIGNALED";
#endif
#ifdef GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST
    static const char* s_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST =
      "SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST";
#endif
#ifdef GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE
    static const char* s_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE =
      "SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE";
#endif
#ifdef GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST
    static const char* s_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST =
      "SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST";
#endif
#ifdef GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE
    static const char* s_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE =
      "SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE";
#endif
#ifdef GL_SKIP_MISSING_GLYPH_NV
    static const char* s_SKIP_MISSING_GLYPH_NV = "SKIP_MISSING_GLYPH_NV";
#endif
#ifdef GL_SMALL_CCW_ARC_TO_NV
    static const char* s_SMALL_CCW_ARC_TO_NV = "SMALL_CCW_ARC_TO_NV";
#endif
#ifdef GL_SMALL_CW_ARC_TO_NV
    static const char* s_SMALL_CW_ARC_TO_NV = "SMALL_CW_ARC_TO_NV";
#endif
#ifdef GL_SMOOTH_CUBIC_CURVE_TO_NV
    static const char* s_SMOOTH_CUBIC_CURVE_TO_NV = "SMOOTH_CUBIC_CURVE_TO_NV";
#endif
#ifdef GL_SMOOTH_LINE_WIDTH_GRANULARITY
    static const char* s_SMOOTH_LINE_WIDTH_GRANULARITY =
      "SMOOTH_LINE_WIDTH_GRANULARITY";
#endif
#ifdef GL_SMOOTH_LINE_WIDTH_RANGE
    static const char* s_SMOOTH_LINE_WIDTH_RANGE = "SMOOTH_LINE_WIDTH_RANGE";
#endif
#ifdef GL_SMOOTH_QUADRATIC_CURVE_TO_NV
    static const char* s_SMOOTH_QUADRATIC_CURVE_TO_NV =
      "SMOOTH_QUADRATIC_CURVE_TO_NV";
#endif
#ifdef GL_SOFTLIGHT_KHR
    static const char* s_SOFTLIGHT_KHR = "SOFTLIGHT_KHR";
#endif
#ifdef GL_SPARSE_STORAGE_BIT_ARB
    static const char* s_SPARSE_STORAGE_BIT_ARB = "SPARSE_STORAGE_BIT_ARB";
#endif
#ifdef GL_SQUARE_NV
    static const char* s_SQUARE_NV = "SQUARE_NV";
#endif
#ifdef GL_SRC1_ALPHA
    static const char* s_SRC1_ALPHA = "SRC1_ALPHA";
#endif
#ifdef GL_SRC1_COLOR
    static const char* s_SRC1_COLOR = "SRC1_COLOR";
#endif
#ifdef GL_SRC_ALPHA
    static const char* s_SRC_ALPHA = "SRC_ALPHA";
#endif
#ifdef GL_SRC_ALPHA_SATURATE
    static const char* s_SRC_ALPHA_SATURATE = "SRC_ALPHA_SATURATE";
#endif
#ifdef GL_SRC_COLOR
    static const char* s_SRC_COLOR = "SRC_COLOR";
#endif
#ifdef GL_SRGB8
    static const char* s_SRGB8 = "SRGB8";
#endif
#ifdef GL_SRGB8_ALPHA8
    static const char* s_SRGB8_ALPHA8 = "SRGB8_ALPHA8";
#endif
#ifdef GL_SRGB_READ
    static const char* s_SRGB_READ = "SRGB_READ";
#endif
#ifdef GL_SRGB_WRITE
    static const char* s_SRGB_WRITE = "SRGB_WRITE";
#endif
#ifdef GL_STACK_OVERFLOW
    static const char* s_STACK_OVERFLOW = "STACK_OVERFLOW";
#endif
#ifdef GL_STACK_UNDERFLOW
    static const char* s_STACK_UNDERFLOW = "STACK_UNDERFLOW";
#endif
#ifdef GL_STANDARD_FONT_NAME_NV
    static const char* s_STANDARD_FONT_NAME_NV = "STANDARD_FONT_NAME_NV";
#endif
#ifdef GL_STATIC_COPY
    static const char* s_STATIC_COPY = "STATIC_COPY";
#endif
#ifdef GL_STATIC_DRAW
    static const char* s_STATIC_DRAW = "STATIC_DRAW";
#endif
#ifdef GL_STATIC_READ
    static const char* s_STATIC_READ = "STATIC_READ";
#endif
#ifdef GL_STENCIL
    static const char* s_STENCIL = "STENCIL";
#endif
#ifdef GL_STENCIL_ATTACHMENT
    static const char* s_STENCIL_ATTACHMENT = "STENCIL_ATTACHMENT";
#endif
#ifdef GL_STENCIL_BACK_FAIL
    static const char* s_STENCIL_BACK_FAIL = "STENCIL_BACK_FAIL";
#endif
#ifdef GL_STENCIL_BACK_FUNC
    static const char* s_STENCIL_BACK_FUNC = "STENCIL_BACK_FUNC";
#endif
#ifdef GL_STENCIL_BACK_PASS_DEPTH_FAIL
    static const char* s_STENCIL_BACK_PASS_DEPTH_FAIL =
      "STENCIL_BACK_PASS_DEPTH_FAIL";
#endif
#ifdef GL_STENCIL_BACK_PASS_DEPTH_PASS
    static const char* s_STENCIL_BACK_PASS_DEPTH_PASS =
      "STENCIL_BACK_PASS_DEPTH_PASS";
#endif
#ifdef GL_STENCIL_BACK_REF
    static const char* s_STENCIL_BACK_REF = "STENCIL_BACK_REF";
#endif
#ifdef GL_STENCIL_BACK_VALUE_MASK
    static const char* s_STENCIL_BACK_VALUE_MASK = "STENCIL_BACK_VALUE_MASK";
#endif
#ifdef GL_STENCIL_BACK_WRITEMASK
    static const char* s_STENCIL_BACK_WRITEMASK = "STENCIL_BACK_WRITEMASK";
#endif
#ifdef GL_STENCIL_BUFFER_BIT
    static const char* s_STENCIL_BUFFER_BIT = "STENCIL_BUFFER_BIT";
#endif
#ifdef GL_STENCIL_CLEAR_VALUE
    static const char* s_STENCIL_CLEAR_VALUE = "STENCIL_CLEAR_VALUE";
#endif
#ifdef GL_STENCIL_COMPONENTS
    static const char* s_STENCIL_COMPONENTS = "STENCIL_COMPONENTS";
#endif
#ifdef GL_STENCIL_FAIL
    static const char* s_STENCIL_FAIL = "STENCIL_FAIL";
#endif
#ifdef GL_STENCIL_FUNC
    static const char* s_STENCIL_FUNC = "STENCIL_FUNC";
#endif
#ifdef GL_STENCIL_INDEX
    static const char* s_STENCIL_INDEX = "STENCIL_INDEX";
#endif
#ifdef GL_STENCIL_INDEX8
    static const char* s_STENCIL_INDEX8 = "STENCIL_INDEX8";
#endif
#ifdef GL_STENCIL_PASS_DEPTH_FAIL
    static const char* s_STENCIL_PASS_DEPTH_FAIL = "STENCIL_PASS_DEPTH_FAIL";
#endif
#ifdef GL_STENCIL_PASS_DEPTH_PASS
    static const char* s_STENCIL_PASS_DEPTH_PASS = "STENCIL_PASS_DEPTH_PASS";
#endif
#ifdef GL_STENCIL_REF
    static const char* s_STENCIL_REF = "STENCIL_REF";
#endif
#ifdef GL_STENCIL_REF_COMMAND_NV
    static const char* s_STENCIL_REF_COMMAND_NV = "STENCIL_REF_COMMAND_NV";
#endif
#ifdef GL_STENCIL_RENDERABLE
    static const char* s_STENCIL_RENDERABLE = "STENCIL_RENDERABLE";
#endif
#ifdef GL_STENCIL_TEST
    static const char* s_STENCIL_TEST = "STENCIL_TEST";
#endif
#ifdef GL_STENCIL_VALUE_MASK
    static const char* s_STENCIL_VALUE_MASK = "STENCIL_VALUE_MASK";
#endif
#ifdef GL_STENCIL_WRITEMASK
    static const char* s_STENCIL_WRITEMASK = "STENCIL_WRITEMASK";
#endif
#ifdef GL_STEREO
    static const char* s_STEREO = "STEREO";
#endif
#ifdef GL_STREAM_COPY
    static const char* s_STREAM_COPY = "STREAM_COPY";
#endif
#ifdef GL_STREAM_DRAW
    static const char* s_STREAM_DRAW = "STREAM_DRAW";
#endif
#ifdef GL_STREAM_RASTERIZATION_AMD
    static const char* s_STREAM_RASTERIZATION_AMD = "STREAM_RASTERIZATION_AMD";
#endif
#ifdef GL_STREAM_READ
    static const char* s_STREAM_READ = "STREAM_READ";
#endif
#ifdef GL_SUBPIXEL_BITS
    static const char* s_SUBPIXEL_BITS = "SUBPIXEL_BITS";
#endif
#ifdef GL_SYNC_CONDITION
    static const char* s_SYNC_CONDITION = "SYNC_CONDITION";
#endif
#ifdef GL_SYNC_FENCE
    static const char* s_SYNC_FENCE = "SYNC_FENCE";
#endif
#ifdef GL_SYNC_GPU_COMMANDS_COMPLETE
    static const char* s_SYNC_GPU_COMMANDS_COMPLETE =
      "SYNC_GPU_COMMANDS_COMPLETE";
#endif
#ifdef GL_SYNC_STATUS
    static const char* s_SYNC_STATUS = "SYNC_STATUS";
#endif
#ifdef GL_SYSTEM_FONT_NAME_NV
    static const char* s_SYSTEM_FONT_NAME_NV = "SYSTEM_FONT_NAME_NV";
#endif
#ifdef GL_TABLE_TOO_LARGE
    static const char* s_TABLE_TOO_LARGE = "TABLE_TOO_LARGE";
#endif
#ifdef GL_TERMINATE_SEQUENCE_COMMAND_NV
    static const char* s_TERMINATE_SEQUENCE_COMMAND_NV =
      "TERMINATE_SEQUENCE_COMMAND_NV";
#endif
#ifdef GL_TESS_CONTROL_SHADER
    static const char* s_TESS_CONTROL_SHADER = "TESS_CONTROL_SHADER";
#endif
#ifdef GL_TESS_CONTROL_SHADER_BIT
    static const char* s_TESS_CONTROL_SHADER_BIT = "TESS_CONTROL_SHADER_BIT";
#endif
#ifdef GL_TESS_CONTROL_SHADER_PATCHES_ARB
    static const char* s_TESS_CONTROL_SHADER_PATCHES_ARB =
      "TESS_CONTROL_SHADER_PATCHES_ARB";
#endif
#ifdef GL_TESS_CONTROL_SUBROUTINE
    static const char* s_TESS_CONTROL_SUBROUTINE = "TESS_CONTROL_SUBROUTINE";
#endif
#ifdef GL_TESS_CONTROL_SUBROUTINE_UNIFORM
    static const char* s_TESS_CONTROL_SUBROUTINE_UNIFORM =
      "TESS_CONTROL_SUBROUTINE_UNIFORM";
#endif
#ifdef GL_TESS_CONTROL_TEXTURE
    static const char* s_TESS_CONTROL_TEXTURE = "TESS_CONTROL_TEXTURE";
#endif
#ifdef GL_TESS_EVALUATION_SHADER
    static const char* s_TESS_EVALUATION_SHADER = "TESS_EVALUATION_SHADER";
#endif
#ifdef GL_TESS_EVALUATION_SHADER_BIT
    static const char* s_TESS_EVALUATION_SHADER_BIT =
      "TESS_EVALUATION_SHADER_BIT";
#endif
#ifdef GL_TESS_EVALUATION_SHADER_INVOCATIONS_ARB
    static const char* s_TESS_EVALUATION_SHADER_INVOCATIONS_ARB =
      "TESS_EVALUATION_SHADER_INVOCATIONS_ARB";
#endif
#ifdef GL_TESS_EVALUATION_SUBROUTINE
    static const char* s_TESS_EVALUATION_SUBROUTINE =
      "TESS_EVALUATION_SUBROUTINE";
#endif
#ifdef GL_TESS_EVALUATION_SUBROUTINE_UNIFORM
    static const char* s_TESS_EVALUATION_SUBROUTINE_UNIFORM =
      "TESS_EVALUATION_SUBROUTINE_UNIFORM";
#endif
#ifdef GL_TESS_EVALUATION_TEXTURE
    static const char* s_TESS_EVALUATION_TEXTURE = "TESS_EVALUATION_TEXTURE";
#endif
#ifdef GL_TEXTURE
    static const char* s_TEXTURE = "TEXTURE";
#endif
#ifdef GL_TEXTURE0
    static const char* s_TEXTURE0 = "TEXTURE0";
#endif
#ifdef GL_TEXTURE_1D
    static const char* s_TEXTURE_1D = "TEXTURE_1D";
#endif
#ifdef GL_TEXTURE_1D_ARRAY
    static const char* s_TEXTURE_1D_ARRAY = "TEXTURE_1D_ARRAY";
#endif
#ifdef GL_TEXTURE_2D
    static const char* s_TEXTURE_2D = "TEXTURE_2D";
#endif
#ifdef GL_TEXTURE_2D_ARRAY
    static const char* s_TEXTURE_2D_ARRAY = "TEXTURE_2D_ARRAY";
#endif
#ifdef GL_TEXTURE_2D_MULTISAMPLE
    static const char* s_TEXTURE_2D_MULTISAMPLE = "TEXTURE_2D_MULTISAMPLE";
#endif
#ifdef GL_TEXTURE_2D_MULTISAMPLE_ARRAY
    static const char* s_TEXTURE_2D_MULTISAMPLE_ARRAY =
      "TEXTURE_2D_MULTISAMPLE_ARRAY";
#endif
#ifdef GL_TEXTURE_3D
    static const char* s_TEXTURE_3D = "TEXTURE_3D";
#endif
#ifdef GL_TEXTURE_BASE_LEVEL
    static const char* s_TEXTURE_BASE_LEVEL = "TEXTURE_BASE_LEVEL";
#endif
#ifdef GL_TEXTURE_BINDING_1D
    static const char* s_TEXTURE_BINDING_1D = "TEXTURE_BINDING_1D";
#endif
#ifdef GL_TEXTURE_BINDING_1D_ARRAY
    static const char* s_TEXTURE_BINDING_1D_ARRAY = "TEXTURE_BINDING_1D_ARRAY";
#endif
#ifdef GL_TEXTURE_BINDING_2D
    static const char* s_TEXTURE_BINDING_2D = "TEXTURE_BINDING_2D";
#endif
#ifdef GL_TEXTURE_BINDING_2D_ARRAY
    static const char* s_TEXTURE_BINDING_2D_ARRAY = "TEXTURE_BINDING_2D_ARRAY";
#endif
#ifdef GL_TEXTURE_BINDING_2D_MULTISAMPLE
    static const char* s_TEXTURE_BINDING_2D_MULTISAMPLE =
      "TEXTURE_BINDING_2D_MULTISAMPLE";
#endif
#ifdef GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY
    static const char* s_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY =
      "TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY";
#endif
#ifdef GL_TEXTURE_BINDING_3D
    static const char* s_TEXTURE_BINDING_3D = "TEXTURE_BINDING_3D";
#endif
#ifdef GL_TEXTURE_BINDING_BUFFER
    static const char* s_TEXTURE_BINDING_BUFFER = "TEXTURE_BINDING_BUFFER";
#endif
#ifdef GL_TEXTURE_BINDING_CUBE_MAP
    static const char* s_TEXTURE_BINDING_CUBE_MAP = "TEXTURE_BINDING_CUBE_MAP";
#endif
#ifdef GL_TEXTURE_BINDING_CUBE_MAP_ARRAY
    static const char* s_TEXTURE_BINDING_CUBE_MAP_ARRAY =
      "TEXTURE_BINDING_CUBE_MAP_ARRAY";
#endif
#ifdef GL_TEXTURE_BINDING_RECTANGLE
    static const char* s_TEXTURE_BINDING_RECTANGLE =
      "TEXTURE_BINDING_RECTANGLE";
#endif
#ifdef GL_TEXTURE_BORDER_COLOR
    static const char* s_TEXTURE_BORDER_COLOR = "TEXTURE_BORDER_COLOR";
#endif
#ifdef GL_TEXTURE_BUFFER
    static const char* s_TEXTURE_BUFFER = "TEXTURE_BUFFER";
#endif
#ifdef GL_TEXTURE_BUFFER_BINDING
    static const char* s_TEXTURE_BUFFER_BINDING = "TEXTURE_BUFFER_BINDING";
#endif
#ifdef GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT
    static const char* s_TEXTURE_BUFFER_OFFSET_ALIGNMENT =
      "TEXTURE_BUFFER_OFFSET_ALIGNMENT";
#endif
#ifdef GL_TEXTURE_COMPARE_FUNC
    static const char* s_TEXTURE_COMPARE_FUNC = "TEXTURE_COMPARE_FUNC";
#endif
#ifdef GL_TEXTURE_COMPARE_MODE
    static const char* s_TEXTURE_COMPARE_MODE = "TEXTURE_COMPARE_MODE";
#endif
#ifdef GL_TEXTURE_COMPRESSED
    static const char* s_TEXTURE_COMPRESSED = "TEXTURE_COMPRESSED";
#endif
#ifdef GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT
    static const char* s_TEXTURE_COMPRESSED_BLOCK_HEIGHT =
      "TEXTURE_COMPRESSED_BLOCK_HEIGHT";
#endif
#ifdef GL_TEXTURE_COMPRESSED_BLOCK_SIZE
    static const char* s_TEXTURE_COMPRESSED_BLOCK_SIZE =
      "TEXTURE_COMPRESSED_BLOCK_SIZE";
#endif
#ifdef GL_TEXTURE_COMPRESSED_BLOCK_WIDTH
    static const char* s_TEXTURE_COMPRESSED_BLOCK_WIDTH =
      "TEXTURE_COMPRESSED_BLOCK_WIDTH";
#endif
#ifdef GL_TEXTURE_COMPRESSION_HINT
    static const char* s_TEXTURE_COMPRESSION_HINT = "TEXTURE_COMPRESSION_HINT";
#endif
#ifdef GL_TEXTURE_COORD_ARRAY
    static const char* s_TEXTURE_COORD_ARRAY = "TEXTURE_COORD_ARRAY";
#endif
#ifdef GL_TEXTURE_COORD_ARRAY_ADDRESS_NV
    static const char* s_TEXTURE_COORD_ARRAY_ADDRESS_NV =
      "TEXTURE_COORD_ARRAY_ADDRESS_NV";
#endif
#ifdef GL_TEXTURE_CUBE_MAP
    static const char* s_TEXTURE_CUBE_MAP = "TEXTURE_CUBE_MAP";
#endif
#ifdef GL_TEXTURE_CUBE_MAP_ARRAY
    static const char* s_TEXTURE_CUBE_MAP_ARRAY = "TEXTURE_CUBE_MAP_ARRAY";
#endif
#ifdef GL_TEXTURE_CUBE_MAP_NEGATIVE_X
    static const char* s_TEXTURE_CUBE_MAP_NEGATIVE_X =
      "TEXTURE_CUBE_MAP_NEGATIVE_X";
#endif
#ifdef GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
    static const char* s_TEXTURE_CUBE_MAP_NEGATIVE_Y =
      "TEXTURE_CUBE_MAP_NEGATIVE_Y";
#endif
#ifdef GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
    static const char* s_TEXTURE_CUBE_MAP_NEGATIVE_Z =
      "TEXTURE_CUBE_MAP_NEGATIVE_Z";
#endif
#ifdef GL_TEXTURE_CUBE_MAP_POSITIVE_X
    static const char* s_TEXTURE_CUBE_MAP_POSITIVE_X =
      "TEXTURE_CUBE_MAP_POSITIVE_X";
#endif
#ifdef GL_TEXTURE_CUBE_MAP_POSITIVE_Y
    static const char* s_TEXTURE_CUBE_MAP_POSITIVE_Y =
      "TEXTURE_CUBE_MAP_POSITIVE_Y";
#endif
#ifdef GL_TEXTURE_CUBE_MAP_POSITIVE_Z
    static const char* s_TEXTURE_CUBE_MAP_POSITIVE_Z =
      "TEXTURE_CUBE_MAP_POSITIVE_Z";
#endif
#ifdef GL_TEXTURE_CUBE_MAP_SEAMLESS
    static const char* s_TEXTURE_CUBE_MAP_SEAMLESS =
      "TEXTURE_CUBE_MAP_SEAMLESS";
#endif
#ifdef GL_TEXTURE_FETCH_BARRIER_BIT
    static const char* s_TEXTURE_FETCH_BARRIER_BIT =
      "TEXTURE_FETCH_BARRIER_BIT";
#endif
#ifdef GL_TEXTURE_GATHER
    static const char* s_TEXTURE_GATHER = "TEXTURE_GATHER";
#endif
#ifdef GL_TEXTURE_GATHER_SHADOW
    static const char* s_TEXTURE_GATHER_SHADOW = "TEXTURE_GATHER_SHADOW";
#endif
#ifdef GL_TEXTURE_IMAGE_FORMAT
    static const char* s_TEXTURE_IMAGE_FORMAT = "TEXTURE_IMAGE_FORMAT";
#endif
#ifdef GL_TEXTURE_IMAGE_TYPE
    static const char* s_TEXTURE_IMAGE_TYPE = "TEXTURE_IMAGE_TYPE";
#endif
#ifdef GL_TEXTURE_IMMUTABLE_FORMAT
    static const char* s_TEXTURE_IMMUTABLE_FORMAT = "TEXTURE_IMMUTABLE_FORMAT";
#endif
#ifdef GL_TEXTURE_IMMUTABLE_LEVELS
    static const char* s_TEXTURE_IMMUTABLE_LEVELS = "TEXTURE_IMMUTABLE_LEVELS";
#endif
#ifdef GL_TEXTURE_LOD_BIAS
    static const char* s_TEXTURE_LOD_BIAS = "TEXTURE_LOD_BIAS";
#endif
#ifdef GL_TEXTURE_MAG_FILTER
    static const char* s_TEXTURE_MAG_FILTER = "TEXTURE_MAG_FILTER";
#endif
#ifdef GL_TEXTURE_MAX_LEVEL
    static const char* s_TEXTURE_MAX_LEVEL = "TEXTURE_MAX_LEVEL";
#endif
#ifdef GL_TEXTURE_MAX_LOD
    static const char* s_TEXTURE_MAX_LOD = "TEXTURE_MAX_LOD";
#endif
#ifdef GL_TEXTURE_MIN_FILTER
    static const char* s_TEXTURE_MIN_FILTER = "TEXTURE_MIN_FILTER";
#endif
#ifdef GL_TEXTURE_MIN_LOD
    static const char* s_TEXTURE_MIN_LOD = "TEXTURE_MIN_LOD";
#endif
#ifdef GL_TEXTURE_RECTANGLE
    static const char* s_TEXTURE_RECTANGLE = "TEXTURE_RECTANGLE";
#endif
#ifdef GL_TEXTURE_SHADOW
    static const char* s_TEXTURE_SHADOW = "TEXTURE_SHADOW";
#endif
#ifdef GL_TEXTURE_SWIZZLE_A
    static const char* s_TEXTURE_SWIZZLE_A = "TEXTURE_SWIZZLE_A";
#endif
#ifdef GL_TEXTURE_SWIZZLE_B
    static const char* s_TEXTURE_SWIZZLE_B = "TEXTURE_SWIZZLE_B";
#endif
#ifdef GL_TEXTURE_SWIZZLE_G
    static const char* s_TEXTURE_SWIZZLE_G = "TEXTURE_SWIZZLE_G";
#endif
#ifdef GL_TEXTURE_SWIZZLE_R
    static const char* s_TEXTURE_SWIZZLE_R = "TEXTURE_SWIZZLE_R";
#endif
#ifdef GL_TEXTURE_SWIZZLE_RGBA
    static const char* s_TEXTURE_SWIZZLE_RGBA = "TEXTURE_SWIZZLE_RGBA";
#endif
#ifdef GL_TEXTURE_TARGET
    static const char* s_TEXTURE_TARGET = "TEXTURE_TARGET";
#endif
#ifdef GL_TEXTURE_UPDATE_BARRIER_BIT
    static const char* s_TEXTURE_UPDATE_BARRIER_BIT =
      "TEXTURE_UPDATE_BARRIER_BIT";
#endif
#ifdef GL_TEXTURE_VIEW
    static const char* s_TEXTURE_VIEW = "TEXTURE_VIEW";
#endif
#ifdef GL_TEXTURE_VIEW_MIN_LAYER
    static const char* s_TEXTURE_VIEW_MIN_LAYER = "TEXTURE_VIEW_MIN_LAYER";
#endif
#ifdef GL_TEXTURE_VIEW_MIN_LEVEL
    static const char* s_TEXTURE_VIEW_MIN_LEVEL = "TEXTURE_VIEW_MIN_LEVEL";
#endif
#ifdef GL_TEXTURE_VIEW_NUM_LAYERS
    static const char* s_TEXTURE_VIEW_NUM_LAYERS = "TEXTURE_VIEW_NUM_LAYERS";
#endif
#ifdef GL_TEXTURE_VIEW_NUM_LEVELS
    static const char* s_TEXTURE_VIEW_NUM_LEVELS = "TEXTURE_VIEW_NUM_LEVELS";
#endif
#ifdef GL_TEXTURE_WRAP_R
    static const char* s_TEXTURE_WRAP_R = "TEXTURE_WRAP_R";
#endif
#ifdef GL_TEXTURE_WRAP_S
    static const char* s_TEXTURE_WRAP_S = "TEXTURE_WRAP_S";
#endif
#ifdef GL_TEXTURE_WRAP_T
    static const char* s_TEXTURE_WRAP_T = "TEXTURE_WRAP_T";
#endif
#ifdef GL_TIMEOUT_EXPIRED
    static const char* s_TIMEOUT_EXPIRED = "TIMEOUT_EXPIRED";
#endif
#ifdef GL_TIMESTAMP
    static const char* s_TIMESTAMP = "TIMESTAMP";
#endif
#ifdef GL_TIME_ELAPSED
    static const char* s_TIME_ELAPSED = "TIME_ELAPSED";
#endif
#ifdef GL_TOP_LEVEL_ARRAY_SIZE
    static const char* s_TOP_LEVEL_ARRAY_SIZE = "TOP_LEVEL_ARRAY_SIZE";
#endif
#ifdef GL_TOP_LEVEL_ARRAY_STRIDE
    static const char* s_TOP_LEVEL_ARRAY_STRIDE = "TOP_LEVEL_ARRAY_STRIDE";
#endif
#ifdef GL_TRANSFORM_FEEDBACK
    static const char* s_TRANSFORM_FEEDBACK = "TRANSFORM_FEEDBACK";
#endif
#ifdef GL_TRANSFORM_FEEDBACK_ACTIVE
    static const char* s_TRANSFORM_FEEDBACK_ACTIVE =
      "TRANSFORM_FEEDBACK_ACTIVE";
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BARRIER_BIT
    static const char* s_TRANSFORM_FEEDBACK_BARRIER_BIT =
      "TRANSFORM_FEEDBACK_BARRIER_BIT";
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BINDING
    static const char* s_TRANSFORM_FEEDBACK_BINDING =
      "TRANSFORM_FEEDBACK_BINDING";
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BUFFER
    static const char* s_TRANSFORM_FEEDBACK_BUFFER =
      "TRANSFORM_FEEDBACK_BUFFER";
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_BINDING
    static const char* s_TRANSFORM_FEEDBACK_BUFFER_BINDING =
      "TRANSFORM_FEEDBACK_BUFFER_BINDING";
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_INDEX
    static const char* s_TRANSFORM_FEEDBACK_BUFFER_INDEX =
      "TRANSFORM_FEEDBACK_BUFFER_INDEX";
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_MODE
    static const char* s_TRANSFORM_FEEDBACK_BUFFER_MODE =
      "TRANSFORM_FEEDBACK_BUFFER_MODE";
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_SIZE
    static const char* s_TRANSFORM_FEEDBACK_BUFFER_SIZE =
      "TRANSFORM_FEEDBACK_BUFFER_SIZE";
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_START
    static const char* s_TRANSFORM_FEEDBACK_BUFFER_START =
      "TRANSFORM_FEEDBACK_BUFFER_START";
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE
    static const char* s_TRANSFORM_FEEDBACK_BUFFER_STRIDE =
      "TRANSFORM_FEEDBACK_BUFFER_STRIDE";
#endif
#ifdef GL_TRANSFORM_FEEDBACK_OVERFLOW_ARB
    static const char* s_TRANSFORM_FEEDBACK_OVERFLOW_ARB =
      "TRANSFORM_FEEDBACK_OVERFLOW_ARB";
#endif
#ifdef GL_TRANSFORM_FEEDBACK_PAUSED
    static const char* s_TRANSFORM_FEEDBACK_PAUSED =
      "TRANSFORM_FEEDBACK_PAUSED";
#endif
#ifdef GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
    static const char* s_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN =
      "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN";
#endif
#ifdef GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW_ARB
    static const char* s_TRANSFORM_FEEDBACK_STREAM_OVERFLOW_ARB =
      "TRANSFORM_FEEDBACK_STREAM_OVERFLOW_ARB";
#endif
#ifdef GL_TRANSFORM_FEEDBACK_VARYINGS
    static const char* s_TRANSFORM_FEEDBACK_VARYINGS =
      "TRANSFORM_FEEDBACK_VARYINGS";
#endif
#ifdef GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH
    static const char* s_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH =
      "TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH";
#endif
#ifdef GL_TRANSFORM_FEEDEBACK_VARYING
    static const char* s_TRANSFORM_FEEDEBACK_VARYING =
      "TRANSFORM_FEEDEBACK_VARYING";
#endif
#ifdef GL_TRANSLATE_2D_NV
    static const char* s_TRANSLATE_2D_NV = "TRANSLATE_2D_NV";
#endif
#ifdef GL_TRANSLATE_3D_NV
    static const char* s_TRANSLATE_3D_NV = "TRANSLATE_3D_NV";
#endif
#ifdef GL_TRANSLATE_X_NV
    static const char* s_TRANSLATE_X_NV = "TRANSLATE_X_NV";
#endif
#ifdef GL_TRANSLATE_Y_NV
    static const char* s_TRANSLATE_Y_NV = "TRANSLATE_Y_NV";
#endif
#ifdef GL_TRANSPOSE_AFFINE_2D_NV
    static const char* s_TRANSPOSE_AFFINE_2D_NV = "TRANSPOSE_AFFINE_2D_NV";
#endif
#ifdef GL_TRANSPOSE_AFFINE_3D_NV
    static const char* s_TRANSPOSE_AFFINE_3D_NV = "TRANSPOSE_AFFINE_3D_NV";
#endif
#ifdef GL_TRIANGLES
    static const char* s_TRIANGLES = "TRIANGLES";
#endif
#ifdef GL_TRIANGLES_ADJACENCY
    static const char* s_TRIANGLES_ADJACENCY = "TRIANGLES_ADJACENCY";
#endif
#ifdef GL_TRIANGLE_FAN
    static const char* s_TRIANGLE_FAN = "TRIANGLE_FAN";
#endif
#ifdef GL_TRIANGLE_STRIP
    static const char* s_TRIANGLE_STRIP = "TRIANGLE_STRIP";
#endif
#ifdef GL_TRIANGLE_STRIP_ADJACENCY
    static const char* s_TRIANGLE_STRIP_ADJACENCY = "TRIANGLE_STRIP_ADJACENCY";
#endif
#ifdef GL_TRIANGULAR_NV
    static const char* s_TRIANGULAR_NV = "TRIANGULAR_NV";
#endif
#ifdef GL_TRUE
    static const char* s_TRUE = "TRUE";
#endif
#ifdef GL_UNIFORM
    static const char* s_UNIFORM = "UNIFORM";
#endif
#ifdef GL_UNIFORM_ADDRESS_COMMAND_NV
    static const char* s_UNIFORM_ADDRESS_COMMAND_NV =
      "UNIFORM_ADDRESS_COMMAND_NV";
#endif
#ifdef GL_UNIFORM_BARRIER_BIT
    static const char* s_UNIFORM_BARRIER_BIT = "UNIFORM_BARRIER_BIT";
#endif
#ifdef GL_UNIFORM_BLOCK
    static const char* s_UNIFORM_BLOCK = "UNIFORM_BLOCK";
#endif
#ifdef GL_UNIFORM_BUFFER
    static const char* s_UNIFORM_BUFFER = "UNIFORM_BUFFER";
#endif
#ifdef GL_UNIFORM_BUFFER_ADDRESS_NV
    static const char* s_UNIFORM_BUFFER_ADDRESS_NV =
      "UNIFORM_BUFFER_ADDRESS_NV";
#endif
#ifdef GL_UNIFORM_BUFFER_BINDING
    static const char* s_UNIFORM_BUFFER_BINDING = "UNIFORM_BUFFER_BINDING";
#endif
#ifdef GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT
    static const char* s_UNIFORM_BUFFER_OFFSET_ALIGNMENT =
      "UNIFORM_BUFFER_OFFSET_ALIGNMENT";
#endif
#ifdef GL_UNIFORM_BUFFER_SIZE
    static const char* s_UNIFORM_BUFFER_SIZE = "UNIFORM_BUFFER_SIZE";
#endif
#ifdef GL_UNIFORM_BUFFER_START
    static const char* s_UNIFORM_BUFFER_START = "UNIFORM_BUFFER_START";
#endif
#ifdef GL_UNIFORM_BUFFER_UNIFIED_NV
    static const char* s_UNIFORM_BUFFER_UNIFIED_NV =
      "UNIFORM_BUFFER_UNIFIED_NV";
#endif
#ifdef GL_UNKNOWN_CONTEXT_RESET
    static const char* s_UNKNOWN_CONTEXT_RESET = "UNKNOWN_CONTEXT_RESET";
#endif
#ifdef GL_UNPACK_ALIGNMENT
    static const char* s_UNPACK_ALIGNMENT = "UNPACK_ALIGNMENT";
#endif
#ifdef GL_UNPACK_COMPRESSED_BLOCK_DEPTH
    static const char* s_UNPACK_COMPRESSED_BLOCK_DEPTH =
      "UNPACK_COMPRESSED_BLOCK_DEPTH";
#endif
#ifdef GL_UNPACK_COMPRESSED_BLOCK_HEIGHT
    static const char* s_UNPACK_COMPRESSED_BLOCK_HEIGHT =
      "UNPACK_COMPRESSED_BLOCK_HEIGHT";
#endif
#ifdef GL_UNPACK_COMPRESSED_BLOCK_SIZE
    static const char* s_UNPACK_COMPRESSED_BLOCK_SIZE =
      "UNPACK_COMPRESSED_BLOCK_SIZE";
#endif
#ifdef GL_UNPACK_COMPRESSED_BLOCK_WIDTH
    static const char* s_UNPACK_COMPRESSED_BLOCK_WIDTH =
      "UNPACK_COMPRESSED_BLOCK_WIDTH";
#endif
#ifdef GL_UNPACK_IMAGE_HEIGHT
    static const char* s_UNPACK_IMAGE_HEIGHT = "UNPACK_IMAGE_HEIGHT";
#endif
#ifdef GL_UNPACK_LSB_FIRST
    static const char* s_UNPACK_LSB_FIRST = "UNPACK_LSB_FIRST";
#endif
#ifdef GL_UNPACK_ROW_LENGTH
    static const char* s_UNPACK_ROW_LENGTH = "UNPACK_ROW_LENGTH";
#endif
#ifdef GL_UNPACK_SKIP_IMAGES
    static const char* s_UNPACK_SKIP_IMAGES = "UNPACK_SKIP_IMAGES";
#endif
#ifdef GL_UNPACK_SKIP_PIXELS
    static const char* s_UNPACK_SKIP_PIXELS = "UNPACK_SKIP_PIXELS";
#endif
#ifdef GL_UNPACK_SKIP_ROWS
    static const char* s_UNPACK_SKIP_ROWS = "UNPACK_SKIP_ROWS";
#endif
#ifdef GL_UNPACK_SWAP_BYTES
    static const char* s_UNPACK_SWAP_BYTES = "UNPACK_SWAP_BYTES";
#endif
#ifdef GL_UNSIGNALED
    static const char* s_UNSIGNALED = "UNSIGNALED";
#endif
#ifdef GL_UNSIGNED_BYTE
    static const char* s_UNSIGNED_BYTE = "UNSIGNED_BYTE";
#endif
#ifdef GL_UNSIGNED_BYTE_2_3_3_REV
    static const char* s_UNSIGNED_BYTE_2_3_3_REV = "UNSIGNED_BYTE_2_3_3_REV";
#endif
#ifdef GL_UNSIGNED_BYTE_3_3_2
    static const char* s_UNSIGNED_BYTE_3_3_2 = "UNSIGNED_BYTE_3_3_2";
#endif
#ifdef GL_UNSIGNED_INT
    static const char* s_UNSIGNED_INT = "UNSIGNED_INT";
#endif
#ifdef GL_UNSIGNED_INT_10F_11F_11F_REV
    static const char* s_UNSIGNED_INT_10F_11F_11F_REV =
      "UNSIGNED_INT_10F_11F_11F_REV";
#endif
#ifdef GL_UNSIGNED_INT_10_10_10_2
    static const char* s_UNSIGNED_INT_10_10_10_2 = "UNSIGNED_INT_10_10_10_2";
#endif
#ifdef GL_UNSIGNED_INT_24_8
    static const char* s_UNSIGNED_INT_24_8 = "UNSIGNED_INT_24_8";
#endif
#ifdef GL_UNSIGNED_INT_2_10_10_10_REV
    static const char* s_UNSIGNED_INT_2_10_10_10_REV =
      "UNSIGNED_INT_2_10_10_10_REV";
#endif
#ifdef GL_UNSIGNED_INT_5_9_9_9_REV
    static const char* s_UNSIGNED_INT_5_9_9_9_REV = "UNSIGNED_INT_5_9_9_9_REV";
#endif
#ifdef GL_UNSIGNED_INT_8_8_8_8
    static const char* s_UNSIGNED_INT_8_8_8_8 = "UNSIGNED_INT_8_8_8_8";
#endif
#ifdef GL_UNSIGNED_INT_8_8_8_8_REV
    static const char* s_UNSIGNED_INT_8_8_8_8_REV = "UNSIGNED_INT_8_8_8_8_REV";
#endif
#ifdef GL_UNSIGNED_INT_ATOMIC_COUNTER
    static const char* s_UNSIGNED_INT_ATOMIC_COUNTER =
      "UNSIGNED_INT_ATOMIC_COUNTER";
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_1D
    static const char* s_UNSIGNED_INT_IMAGE_1D = "UNSIGNED_INT_IMAGE_1D";
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_1D_ARRAY
    static const char* s_UNSIGNED_INT_IMAGE_1D_ARRAY =
      "UNSIGNED_INT_IMAGE_1D_ARRAY";
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_2D
    static const char* s_UNSIGNED_INT_IMAGE_2D = "UNSIGNED_INT_IMAGE_2D";
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_2D_ARRAY
    static const char* s_UNSIGNED_INT_IMAGE_2D_ARRAY =
      "UNSIGNED_INT_IMAGE_2D_ARRAY";
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE
    static const char* s_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE =
      "UNSIGNED_INT_IMAGE_2D_MULTISAMPLE";
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY
    static const char* s_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY =
      "UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY";
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_2D_RECT
    static const char* s_UNSIGNED_INT_IMAGE_2D_RECT =
      "UNSIGNED_INT_IMAGE_2D_RECT";
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_3D
    static const char* s_UNSIGNED_INT_IMAGE_3D = "UNSIGNED_INT_IMAGE_3D";
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_BUFFER
    static const char* s_UNSIGNED_INT_IMAGE_BUFFER =
      "UNSIGNED_INT_IMAGE_BUFFER";
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_CUBE
    static const char* s_UNSIGNED_INT_IMAGE_CUBE = "UNSIGNED_INT_IMAGE_CUBE";
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_1D
    static const char* s_UNSIGNED_INT_SAMPLER_1D = "UNSIGNED_INT_SAMPLER_1D";
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_1D_ARRAY
    static const char* s_UNSIGNED_INT_SAMPLER_1D_ARRAY =
      "UNSIGNED_INT_SAMPLER_1D_ARRAY";
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_2D
    static const char* s_UNSIGNED_INT_SAMPLER_2D = "UNSIGNED_INT_SAMPLER_2D";
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_2D_ARRAY
    static const char* s_UNSIGNED_INT_SAMPLER_2D_ARRAY =
      "UNSIGNED_INT_SAMPLER_2D_ARRAY";
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE
    static const char* s_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE =
      "UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE";
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY
    static const char* s_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY =
      "UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY";
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_2D_RECT
    static const char* s_UNSIGNED_INT_SAMPLER_2D_RECT =
      "UNSIGNED_INT_SAMPLER_2D_RECT";
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_3D
    static const char* s_UNSIGNED_INT_SAMPLER_3D = "UNSIGNED_INT_SAMPLER_3D";
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_BUFFER
    static const char* s_UNSIGNED_INT_SAMPLER_BUFFER =
      "UNSIGNED_INT_SAMPLER_BUFFER";
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_CUBE
    static const char* s_UNSIGNED_INT_SAMPLER_CUBE =
      "UNSIGNED_INT_SAMPLER_CUBE";
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY
    static const char* s_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY =
      "UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY";
#endif
#ifdef GL_UNSIGNED_INT_VEC2
    static const char* s_UNSIGNED_INT_VEC2 = "UNSIGNED_INT_VEC2";
#endif
#ifdef GL_UNSIGNED_INT_VEC3
    static const char* s_UNSIGNED_INT_VEC3 = "UNSIGNED_INT_VEC3";
#endif
#ifdef GL_UNSIGNED_INT_VEC4
    static const char* s_UNSIGNED_INT_VEC4 = "UNSIGNED_INT_VEC4";
#endif
#ifdef GL_UNSIGNED_SHORT
    static const char* s_UNSIGNED_SHORT = "UNSIGNED_SHORT";
#endif
#ifdef GL_UNSIGNED_SHORT_1_5_5_5_REV
    static const char* s_UNSIGNED_SHORT_1_5_5_5_REV =
      "UNSIGNED_SHORT_1_5_5_5_REV";
#endif
#ifdef GL_UNSIGNED_SHORT_4_4_4_4
    static const char* s_UNSIGNED_SHORT_4_4_4_4 = "UNSIGNED_SHORT_4_4_4_4";
#endif
#ifdef GL_UNSIGNED_SHORT_4_4_4_4_REV
    static const char* s_UNSIGNED_SHORT_4_4_4_4_REV =
      "UNSIGNED_SHORT_4_4_4_4_REV";
#endif
#ifdef GL_UNSIGNED_SHORT_5_5_5_1
    static const char* s_UNSIGNED_SHORT_5_5_5_1 = "UNSIGNED_SHORT_5_5_5_1";
#endif
#ifdef GL_UNSIGNED_SHORT_5_6_5
    static const char* s_UNSIGNED_SHORT_5_6_5 = "UNSIGNED_SHORT_5_6_5";
#endif
#ifdef GL_UNSIGNED_SHORT_5_6_5_REV
    static const char* s_UNSIGNED_SHORT_5_6_5_REV = "UNSIGNED_SHORT_5_6_5_REV";
#endif
#ifdef GL_UPPER_LEFT
    static const char* s_UPPER_LEFT = "UPPER_LEFT";
#endif
#ifdef GL_USE_MISSING_GLYPH_NV
    static const char* s_USE_MISSING_GLYPH_NV = "USE_MISSING_GLYPH_NV";
#endif
#ifdef GL_UTF16_NV
    static const char* s_UTF16_NV = "UTF16_NV";
#endif
#ifdef GL_UTF8_NV
    static const char* s_UTF8_NV = "UTF8_NV";
#endif
#ifdef GL_VALIDATE_STATUS
    static const char* s_VALIDATE_STATUS = "VALIDATE_STATUS";
#endif
#ifdef GL_VENDOR
    static const char* s_VENDOR = "VENDOR";
#endif
#ifdef GL_VERSION
    static const char* s_VERSION = "VERSION";
#endif
#ifdef GL_VERTEX_ARRAY
    static const char* s_VERTEX_ARRAY = "VERTEX_ARRAY";
#endif
#ifdef GL_VERTEX_ARRAY_ADDRESS_NV
    static const char* s_VERTEX_ARRAY_ADDRESS_NV = "VERTEX_ARRAY_ADDRESS_NV";
#endif
#ifdef GL_VERTEX_ARRAY_BINDING
    static const char* s_VERTEX_ARRAY_BINDING = "VERTEX_ARRAY_BINDING";
#endif
#ifdef GL_VERTEX_ATTRIB_ARRAY_ADDRESS_NV
    static const char* s_VERTEX_ATTRIB_ARRAY_ADDRESS_NV =
      "VERTEX_ATTRIB_ARRAY_ADDRESS_NV";
#endif
#ifdef GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT
    static const char* s_VERTEX_ATTRIB_ARRAY_BARRIER_BIT =
      "VERTEX_ATTRIB_ARRAY_BARRIER_BIT";
#endif
#ifdef GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV
    static const char* s_VERTEX_ATTRIB_ARRAY_UNIFIED_NV =
      "VERTEX_ATTRIB_ARRAY_UNIFIED_NV";
#endif
#ifdef GL_VERTEX_SHADER
    static const char* s_VERTEX_SHADER = "VERTEX_SHADER";
#endif
#ifdef GL_VERTEX_SHADER_BIT
    static const char* s_VERTEX_SHADER_BIT = "VERTEX_SHADER_BIT";
#endif
#ifdef GL_VERTEX_SHADER_INVOCATIONS_ARB
    static const char* s_VERTEX_SHADER_INVOCATIONS_ARB =
      "VERTEX_SHADER_INVOCATIONS_ARB";
#endif
#ifdef GL_VERTEX_SUBROUTINE
    static const char* s_VERTEX_SUBROUTINE = "VERTEX_SUBROUTINE";
#endif
#ifdef GL_VERTEX_SUBROUTINE_UNIFORM
    static const char* s_VERTEX_SUBROUTINE_UNIFORM =
      "VERTEX_SUBROUTINE_UNIFORM";
#endif
#ifdef GL_VERTEX_TEXTURE
    static const char* s_VERTEX_TEXTURE = "VERTEX_TEXTURE";
#endif
#ifdef GL_VERTICAL_LINE_TO_NV
    static const char* s_VERTICAL_LINE_TO_NV = "VERTICAL_LINE_TO_NV";
#endif
#ifdef GL_VERTICES_SUBMITTED_ARB
    static const char* s_VERTICES_SUBMITTED_ARB = "VERTICES_SUBMITTED_ARB";
#endif
#ifdef GL_VIEWPORT
    static const char* s_VIEWPORT = "VIEWPORT";
#endif
#ifdef GL_VIEWPORT_BOUNDS_RANGE
    static const char* s_VIEWPORT_BOUNDS_RANGE = "VIEWPORT_BOUNDS_RANGE";
#endif
#ifdef GL_VIEWPORT_COMMAND_NV
    static const char* s_VIEWPORT_COMMAND_NV = "VIEWPORT_COMMAND_NV";
#endif
#ifdef GL_VIEWPORT_INDEX_PROVOKING_VERTEX
    static const char* s_VIEWPORT_INDEX_PROVOKING_VERTEX =
      "VIEWPORT_INDEX_PROVOKING_VERTEX";
#endif
#ifdef GL_VIEWPORT_SUBPIXEL_BITS
    static const char* s_VIEWPORT_SUBPIXEL_BITS = "VIEWPORT_SUBPIXEL_BITS";
#endif
#ifdef GL_VIEW_CLASS_128_BITS
    static const char* s_VIEW_CLASS_128_BITS = "VIEW_CLASS_128_BITS";
#endif
#ifdef GL_VIEW_CLASS_16_BITS
    static const char* s_VIEW_CLASS_16_BITS = "VIEW_CLASS_16_BITS";
#endif
#ifdef GL_VIEW_CLASS_24_BITS
    static const char* s_VIEW_CLASS_24_BITS = "VIEW_CLASS_24_BITS";
#endif
#ifdef GL_VIEW_CLASS_32_BITS
    static const char* s_VIEW_CLASS_32_BITS = "VIEW_CLASS_32_BITS";
#endif
#ifdef GL_VIEW_CLASS_48_BITS
    static const char* s_VIEW_CLASS_48_BITS = "VIEW_CLASS_48_BITS";
#endif
#ifdef GL_VIEW_CLASS_64_BITS
    static const char* s_VIEW_CLASS_64_BITS = "VIEW_CLASS_64_BITS";
#endif
#ifdef GL_VIEW_CLASS_8_BITS
    static const char* s_VIEW_CLASS_8_BITS = "VIEW_CLASS_8_BITS";
#endif
#ifdef GL_VIEW_CLASS_96_BITS
    static const char* s_VIEW_CLASS_96_BITS = "VIEW_CLASS_96_BITS";
#endif
#ifdef GL_VIEW_CLASS_BPTC_FLOAT
    static const char* s_VIEW_CLASS_BPTC_FLOAT = "VIEW_CLASS_BPTC_FLOAT";
#endif
#ifdef GL_VIEW_CLASS_BPTC_UNORM
    static const char* s_VIEW_CLASS_BPTC_UNORM = "VIEW_CLASS_BPTC_UNORM";
#endif
#ifdef GL_VIEW_CLASS_RGTC1_RED
    static const char* s_VIEW_CLASS_RGTC1_RED = "VIEW_CLASS_RGTC1_RED";
#endif
#ifdef GL_VIEW_CLASS_RGTC2_RG
    static const char* s_VIEW_CLASS_RGTC2_RG = "VIEW_CLASS_RGTC2_RG";
#endif
#ifdef GL_VIEW_CLASS_S3TC_DXT1_RGB
    static const char* s_VIEW_CLASS_S3TC_DXT1_RGB = "VIEW_CLASS_S3TC_DXT1_RGB";
#endif
#ifdef GL_VIEW_CLASS_S3TC_DXT1_RGBA
    static const char* s_VIEW_CLASS_S3TC_DXT1_RGBA =
      "VIEW_CLASS_S3TC_DXT1_RGBA";
#endif
#ifdef GL_VIEW_CLASS_S3TC_DXT3_RGBA
    static const char* s_VIEW_CLASS_S3TC_DXT3_RGBA =
      "VIEW_CLASS_S3TC_DXT3_RGBA";
#endif
#ifdef GL_VIEW_CLASS_S3TC_DXT5_RGBA
    static const char* s_VIEW_CLASS_S3TC_DXT5_RGBA =
      "VIEW_CLASS_S3TC_DXT5_RGBA";
#endif
#ifdef GL_VIEW_COMPATIBILITY_CLASS
    static const char* s_VIEW_COMPATIBILITY_CLASS = "VIEW_COMPATIBILITY_CLASS";
#endif
#ifdef GL_WAIT_FAILED
    static const char* s_WAIT_FAILED = "WAIT_FAILED";
#endif
#ifdef GL_WRITE_ONLY
    static const char* s_WRITE_ONLY = "WRITE_ONLY";
#endif
#ifdef GL_XOR
    static const char* s_XOR = "XOR";
#endif
#ifdef GL_ZERO
    static const char* s_ZERO = "ZERO";
#endif
#ifdef GL_ZERO_TO_ONE
    static const char* s_ZERO_TO_ONE = "ZERO_TO_ONE";
#endif

    switch(aev._type_id) {
        case 0: /* access_specifier */
            switch(GLenum(aev._value)) {
#ifdef GL_READ_ONLY
                case GL_READ_ONLY:
                    return {s_READ_ONLY, 9};
#endif
#ifdef GL_READ_WRITE
                case GL_READ_WRITE:
                    return {s_READ_WRITE, 10};
#endif
#ifdef GL_WRITE_ONLY
                case GL_WRITE_ONLY:
                    return {s_WRITE_ONLY, 10};
#endif
                default:;
            }
            break;
        case 1: /* binding_query */
            switch(GLenum(aev._value)) {
#ifdef GL_ARRAY_BUFFER_BINDING
                case GL_ARRAY_BUFFER_BINDING:
                    return {s_ARRAY_BUFFER_BINDING, 20};
#endif
#ifdef GL_ATOMIC_COUNTER_BUFFER_BINDING
                case GL_ATOMIC_COUNTER_BUFFER_BINDING:
                    return {s_ATOMIC_COUNTER_BUFFER_BINDING, 29};
#endif
#ifdef GL_BUFFER_BINDING
                case GL_BUFFER_BINDING:
                    return {s_BUFFER_BINDING, 14};
#endif
#ifdef GL_COPY_READ_BUFFER_BINDING
                case GL_COPY_READ_BUFFER_BINDING:
                    return {s_COPY_READ_BUFFER_BINDING, 24};
#endif
#ifdef GL_COPY_WRITE_BUFFER_BINDING
                case GL_COPY_WRITE_BUFFER_BINDING:
                    return {s_COPY_WRITE_BUFFER_BINDING, 25};
#endif
#ifdef GL_CURRENT_PROGRAM
                case GL_CURRENT_PROGRAM:
                    return {s_CURRENT_PROGRAM, 15};
#endif
#ifdef GL_DISPATCH_INDIRECT_BUFFER_BINDING
                case GL_DISPATCH_INDIRECT_BUFFER_BINDING:
                    return {s_DISPATCH_INDIRECT_BUFFER_BINDING, 32};
#endif
#ifdef GL_DRAW_FRAMEBUFFER_BINDING
                case GL_DRAW_FRAMEBUFFER_BINDING:
                    return {s_DRAW_FRAMEBUFFER_BINDING, 24};
#endif
#ifdef GL_DRAW_INDIRECT_BUFFER_BINDING
                case GL_DRAW_INDIRECT_BUFFER_BINDING:
                    return {s_DRAW_INDIRECT_BUFFER_BINDING, 28};
#endif
#ifdef GL_ELEMENT_ARRAY_BUFFER_BINDING
                case GL_ELEMENT_ARRAY_BUFFER_BINDING:
                    return {s_ELEMENT_ARRAY_BUFFER_BINDING, 28};
#endif
#ifdef GL_PARAMETER_BUFFER_BINDING_ARB
                case GL_PARAMETER_BUFFER_BINDING_ARB:
                    return {s_PARAMETER_BUFFER_BINDING_ARB, 28};
#endif
#ifdef GL_PIXEL_PACK_BUFFER_BINDING
                case GL_PIXEL_PACK_BUFFER_BINDING:
                    return {s_PIXEL_PACK_BUFFER_BINDING, 25};
#endif
#ifdef GL_PIXEL_UNPACK_BUFFER_BINDING
                case GL_PIXEL_UNPACK_BUFFER_BINDING:
                    return {s_PIXEL_UNPACK_BUFFER_BINDING, 27};
#endif
#ifdef GL_QUERY_BUFFER_BINDING
                case GL_QUERY_BUFFER_BINDING:
                    return {s_QUERY_BUFFER_BINDING, 20};
#endif
#ifdef GL_RENDERBUFFER_BINDING
                case GL_RENDERBUFFER_BINDING:
                    return {s_RENDERBUFFER_BINDING, 20};
#endif
#ifdef GL_SAMPLER_BINDING
                case GL_SAMPLER_BINDING:
                    return {s_SAMPLER_BINDING, 15};
#endif
#ifdef GL_SHADER_STORAGE_BUFFER_BINDING
                case GL_SHADER_STORAGE_BUFFER_BINDING:
                    return {s_SHADER_STORAGE_BUFFER_BINDING, 29};
#endif
#ifdef GL_TEXTURE_BINDING_1D
                case GL_TEXTURE_BINDING_1D:
                    return {s_TEXTURE_BINDING_1D, 18};
#endif
#ifdef GL_TEXTURE_BINDING_1D_ARRAY
                case GL_TEXTURE_BINDING_1D_ARRAY:
                    return {s_TEXTURE_BINDING_1D_ARRAY, 24};
#endif
#ifdef GL_TEXTURE_BINDING_2D
                case GL_TEXTURE_BINDING_2D:
                    return {s_TEXTURE_BINDING_2D, 18};
#endif
#ifdef GL_TEXTURE_BINDING_2D_ARRAY
                case GL_TEXTURE_BINDING_2D_ARRAY:
                    return {s_TEXTURE_BINDING_2D_ARRAY, 24};
#endif
#ifdef GL_TEXTURE_BINDING_2D_MULTISAMPLE
                case GL_TEXTURE_BINDING_2D_MULTISAMPLE:
                    return {s_TEXTURE_BINDING_2D_MULTISAMPLE, 30};
#endif
#ifdef GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY
                case GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY:
                    return {s_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY, 36};
#endif
#ifdef GL_TEXTURE_BINDING_3D
                case GL_TEXTURE_BINDING_3D:
                    return {s_TEXTURE_BINDING_3D, 18};
#endif
#ifdef GL_TEXTURE_BINDING_BUFFER
                case GL_TEXTURE_BINDING_BUFFER:
                    return {s_TEXTURE_BINDING_BUFFER, 22};
#endif
#ifdef GL_TEXTURE_BINDING_CUBE_MAP
                case GL_TEXTURE_BINDING_CUBE_MAP:
                    return {s_TEXTURE_BINDING_CUBE_MAP, 24};
#endif
#ifdef GL_TEXTURE_BINDING_CUBE_MAP_ARRAY
                case GL_TEXTURE_BINDING_CUBE_MAP_ARRAY:
                    return {s_TEXTURE_BINDING_CUBE_MAP_ARRAY, 30};
#endif
#ifdef GL_TEXTURE_BINDING_RECTANGLE
                case GL_TEXTURE_BINDING_RECTANGLE:
                    return {s_TEXTURE_BINDING_RECTANGLE, 25};
#endif
#ifdef GL_TEXTURE_BUFFER_BINDING
                case GL_TEXTURE_BUFFER_BINDING:
                    return {s_TEXTURE_BUFFER_BINDING, 22};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BINDING
                case GL_TRANSFORM_FEEDBACK_BINDING:
                    return {s_TRANSFORM_FEEDBACK_BINDING, 26};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_BINDING
                case GL_TRANSFORM_FEEDBACK_BUFFER_BINDING:
                    return {s_TRANSFORM_FEEDBACK_BUFFER_BINDING, 33};
#endif
#ifdef GL_UNIFORM_BUFFER_BINDING
                case GL_UNIFORM_BUFFER_BINDING:
                    return {s_UNIFORM_BUFFER_BINDING, 22};
#endif
#ifdef GL_VERTEX_ARRAY_BINDING
                case GL_VERTEX_ARRAY_BINDING:
                    return {s_VERTEX_ARRAY_BINDING, 20};
#endif
                default:;
            }
            break;
        case 2: /* blend_equation */
            switch(GLenum(aev._value)) {
#ifdef GL_FUNC_ADD
                case GL_FUNC_ADD:
                    return {s_FUNC_ADD, 8};
#endif
#ifdef GL_FUNC_REVERSE_SUBTRACT
                case GL_FUNC_REVERSE_SUBTRACT:
                    return {s_FUNC_REVERSE_SUBTRACT, 21};
#endif
#ifdef GL_FUNC_SUBTRACT
                case GL_FUNC_SUBTRACT:
                    return {s_FUNC_SUBTRACT, 13};
#endif
#ifdef GL_MAX
                case GL_MAX:
                    return {s_MAX, 3};
#endif
#ifdef GL_MIN
                case GL_MIN:
                    return {s_MIN, 3};
#endif
                default:;
            }
            break;
        case 3: /* blend_equation_advanced */
            switch(GLenum(aev._value)) {
#ifdef GL_COLORBURN_KHR
                case GL_COLORBURN_KHR:
                    return {s_COLORBURN_KHR, 13};
#endif
#ifdef GL_COLORDODGE_KHR
                case GL_COLORDODGE_KHR:
                    return {s_COLORDODGE_KHR, 14};
#endif
#ifdef GL_DARKEN_KHR
                case GL_DARKEN_KHR:
                    return {s_DARKEN_KHR, 10};
#endif
#ifdef GL_DIFFERENCE_KHR
                case GL_DIFFERENCE_KHR:
                    return {s_DIFFERENCE_KHR, 14};
#endif
#ifdef GL_EXCLUSION_KHR
                case GL_EXCLUSION_KHR:
                    return {s_EXCLUSION_KHR, 13};
#endif
#ifdef GL_HARDLIGHT_KHR
                case GL_HARDLIGHT_KHR:
                    return {s_HARDLIGHT_KHR, 13};
#endif
#ifdef GL_HSL_COLOR_KHR
                case GL_HSL_COLOR_KHR:
                    return {s_HSL_COLOR_KHR, 13};
#endif
#ifdef GL_HSL_HUE_KHR
                case GL_HSL_HUE_KHR:
                    return {s_HSL_HUE_KHR, 11};
#endif
#ifdef GL_HSL_LUMINOSITY_KHR
                case GL_HSL_LUMINOSITY_KHR:
                    return {s_HSL_LUMINOSITY_KHR, 18};
#endif
#ifdef GL_HSL_SATURATION_KHR
                case GL_HSL_SATURATION_KHR:
                    return {s_HSL_SATURATION_KHR, 18};
#endif
#ifdef GL_LIGHTEN_KHR
                case GL_LIGHTEN_KHR:
                    return {s_LIGHTEN_KHR, 11};
#endif
#ifdef GL_MULTIPLY_KHR
                case GL_MULTIPLY_KHR:
                    return {s_MULTIPLY_KHR, 12};
#endif
#ifdef GL_OVERLAY_KHR
                case GL_OVERLAY_KHR:
                    return {s_OVERLAY_KHR, 11};
#endif
#ifdef GL_SCREEN_KHR
                case GL_SCREEN_KHR:
                    return {s_SCREEN_KHR, 10};
#endif
#ifdef GL_SOFTLIGHT_KHR
                case GL_SOFTLIGHT_KHR:
                    return {s_SOFTLIGHT_KHR, 13};
#endif
                default:;
            }
            break;
        case 4: /* blend_function */
            switch(GLenum(aev._value)) {
#ifdef GL_CONSTANT_ALPHA
                case GL_CONSTANT_ALPHA:
                    return {s_CONSTANT_ALPHA, 14};
#endif
#ifdef GL_CONSTANT_COLOR
                case GL_CONSTANT_COLOR:
                    return {s_CONSTANT_COLOR, 14};
#endif
#ifdef GL_DST_ALPHA
                case GL_DST_ALPHA:
                    return {s_DST_ALPHA, 9};
#endif
#ifdef GL_DST_COLOR
                case GL_DST_COLOR:
                    return {s_DST_COLOR, 9};
#endif
#ifdef GL_ONE
                case GL_ONE:
                    return {s_ONE, 3};
#endif
#ifdef GL_ONE_MINUS_CONSTANT_ALPHA
                case GL_ONE_MINUS_CONSTANT_ALPHA:
                    return {s_ONE_MINUS_CONSTANT_ALPHA, 24};
#endif
#ifdef GL_ONE_MINUS_CONSTANT_COLOR
                case GL_ONE_MINUS_CONSTANT_COLOR:
                    return {s_ONE_MINUS_CONSTANT_COLOR, 24};
#endif
#ifdef GL_ONE_MINUS_DST_ALPHA
                case GL_ONE_MINUS_DST_ALPHA:
                    return {s_ONE_MINUS_DST_ALPHA, 19};
#endif
#ifdef GL_ONE_MINUS_DST_COLOR
                case GL_ONE_MINUS_DST_COLOR:
                    return {s_ONE_MINUS_DST_COLOR, 19};
#endif
#ifdef GL_ONE_MINUS_SRC1_ALPHA
                case GL_ONE_MINUS_SRC1_ALPHA:
                    return {s_ONE_MINUS_SRC1_ALPHA, 20};
#endif
#ifdef GL_ONE_MINUS_SRC1_COLOR
                case GL_ONE_MINUS_SRC1_COLOR:
                    return {s_ONE_MINUS_SRC1_COLOR, 20};
#endif
#ifdef GL_ONE_MINUS_SRC_ALPHA
                case GL_ONE_MINUS_SRC_ALPHA:
                    return {s_ONE_MINUS_SRC_ALPHA, 19};
#endif
#ifdef GL_ONE_MINUS_SRC_COLOR
                case GL_ONE_MINUS_SRC_COLOR:
                    return {s_ONE_MINUS_SRC_COLOR, 19};
#endif
#ifdef GL_SRC1_ALPHA
                case GL_SRC1_ALPHA:
                    return {s_SRC1_ALPHA, 10};
#endif
#ifdef GL_SRC1_COLOR
                case GL_SRC1_COLOR:
                    return {s_SRC1_COLOR, 10};
#endif
#ifdef GL_SRC_ALPHA
                case GL_SRC_ALPHA:
                    return {s_SRC_ALPHA, 9};
#endif
#ifdef GL_SRC_ALPHA_SATURATE
                case GL_SRC_ALPHA_SATURATE:
                    return {s_SRC_ALPHA_SATURATE, 18};
#endif
#ifdef GL_SRC_COLOR
                case GL_SRC_COLOR:
                    return {s_SRC_COLOR, 9};
#endif
#ifdef GL_ZERO
                case GL_ZERO:
                    return {s_ZERO, 4};
#endif
                default:;
            }
            break;
        case 5: /* blit_filter */
            switch(GLenum(aev._value)) {
#ifdef GL_LINEAR
                case GL_LINEAR:
                    return {s_LINEAR, 6};
#endif
#ifdef GL_NEAREST
                case GL_NEAREST:
                    return {s_NEAREST, 7};
#endif
                default:;
            }
            break;
        case 6: /* buffer_indexed_target */
            switch(GLenum(aev._value)) {
#ifdef GL_ATOMIC_COUNTER_BUFFER
                case GL_ATOMIC_COUNTER_BUFFER:
                    return {s_ATOMIC_COUNTER_BUFFER, 21};
#endif
#ifdef GL_SHADER_STORAGE_BUFFER
                case GL_SHADER_STORAGE_BUFFER:
                    return {s_SHADER_STORAGE_BUFFER, 21};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BUFFER
                case GL_TRANSFORM_FEEDBACK_BUFFER:
                    return {s_TRANSFORM_FEEDBACK_BUFFER, 25};
#endif
#ifdef GL_UNIFORM_BUFFER
                case GL_UNIFORM_BUFFER:
                    return {s_UNIFORM_BUFFER, 14};
#endif
                default:;
            }
            break;
        case 7: /* buffer_map_access */
            switch(GLbitfield(aev._value)) {
#ifdef GL_MAP_COHERENT_BIT
                case GL_MAP_COHERENT_BIT:
                    return {s_MAP_COHERENT_BIT, 16};
#endif
#ifdef GL_MAP_FLUSH_EXPLICIT_BIT
                case GL_MAP_FLUSH_EXPLICIT_BIT:
                    return {s_MAP_FLUSH_EXPLICIT_BIT, 22};
#endif
#ifdef GL_MAP_INVALIDATE_BUFFER_BIT
                case GL_MAP_INVALIDATE_BUFFER_BIT:
                    return {s_MAP_INVALIDATE_BUFFER_BIT, 25};
#endif
#ifdef GL_MAP_INVALIDATE_RANGE_BIT
                case GL_MAP_INVALIDATE_RANGE_BIT:
                    return {s_MAP_INVALIDATE_RANGE_BIT, 24};
#endif
#ifdef GL_MAP_PERSISTENT_BIT
                case GL_MAP_PERSISTENT_BIT:
                    return {s_MAP_PERSISTENT_BIT, 18};
#endif
#ifdef GL_MAP_READ_BIT
                case GL_MAP_READ_BIT:
                    return {s_MAP_READ_BIT, 12};
#endif
#ifdef GL_MAP_UNSYNCHRONIZED_BIT
                case GL_MAP_UNSYNCHRONIZED_BIT:
                    return {s_MAP_UNSYNCHRONIZED_BIT, 22};
#endif
#ifdef GL_MAP_WRITE_BIT
                case GL_MAP_WRITE_BIT:
                    return {s_MAP_WRITE_BIT, 13};
#endif
                default:;
            }
            break;
        case 8: /* buffer_parameter */
            switch(GLenum(aev._value)) {
#ifdef GL_BUFFER_ACCESS
                case GL_BUFFER_ACCESS:
                    return {s_BUFFER_ACCESS, 13};
#endif
#ifdef GL_BUFFER_ACCESS_FLAGS
                case GL_BUFFER_ACCESS_FLAGS:
                    return {s_BUFFER_ACCESS_FLAGS, 19};
#endif
#ifdef GL_BUFFER_IMMUTABLE_STORAGE
                case GL_BUFFER_IMMUTABLE_STORAGE:
                    return {s_BUFFER_IMMUTABLE_STORAGE, 24};
#endif
#ifdef GL_BUFFER_MAPPED
                case GL_BUFFER_MAPPED:
                    return {s_BUFFER_MAPPED, 13};
#endif
#ifdef GL_BUFFER_MAP_LENGTH
                case GL_BUFFER_MAP_LENGTH:
                    return {s_BUFFER_MAP_LENGTH, 17};
#endif
#ifdef GL_BUFFER_MAP_OFFSET
                case GL_BUFFER_MAP_OFFSET:
                    return {s_BUFFER_MAP_OFFSET, 17};
#endif
#ifdef GL_BUFFER_SIZE
                case GL_BUFFER_SIZE:
                    return {s_BUFFER_SIZE, 11};
#endif
#ifdef GL_BUFFER_STORAGE_FLAGS
                case GL_BUFFER_STORAGE_FLAGS:
                    return {s_BUFFER_STORAGE_FLAGS, 20};
#endif
#ifdef GL_BUFFER_USAGE
                case GL_BUFFER_USAGE:
                    return {s_BUFFER_USAGE, 12};
#endif
                default:;
            }
            break;
        case 9: /* buffer_select_bits */
            switch(GLbitfield(aev._value)) {
#ifdef GL_COLOR_BUFFER_BIT
                case GL_COLOR_BUFFER_BIT:
                    return {s_COLOR_BUFFER_BIT, 16};
#endif
#ifdef GL_DEPTH_BUFFER_BIT
                case GL_DEPTH_BUFFER_BIT:
                    return {s_DEPTH_BUFFER_BIT, 16};
#endif
#ifdef GL_STENCIL_BUFFER_BIT
                case GL_STENCIL_BUFFER_BIT:
                    return {s_STENCIL_BUFFER_BIT, 18};
#endif
                default:;
            }
            break;
        case 10: /* buffer_storage_bits */
            switch(GLbitfield(aev._value)) {
#ifdef GL_CLIENT_STORAGE_BIT
                case GL_CLIENT_STORAGE_BIT:
                    return {s_CLIENT_STORAGE_BIT, 18};
#endif
#ifdef GL_DYNAMIC_STORAGE_BIT
                case GL_DYNAMIC_STORAGE_BIT:
                    return {s_DYNAMIC_STORAGE_BIT, 19};
#endif
#ifdef GL_MAP_COHERENT_BIT
                case GL_MAP_COHERENT_BIT:
                    return {s_MAP_COHERENT_BIT, 16};
#endif
#ifdef GL_MAP_PERSISTENT_BIT
                case GL_MAP_PERSISTENT_BIT:
                    return {s_MAP_PERSISTENT_BIT, 18};
#endif
#ifdef GL_MAP_READ_BIT
                case GL_MAP_READ_BIT:
                    return {s_MAP_READ_BIT, 12};
#endif
#ifdef GL_MAP_WRITE_BIT
                case GL_MAP_WRITE_BIT:
                    return {s_MAP_WRITE_BIT, 13};
#endif
#ifdef GL_SPARSE_STORAGE_BIT_ARB
                case GL_SPARSE_STORAGE_BIT_ARB:
                    return {s_SPARSE_STORAGE_BIT_ARB, 22};
#endif
                default:;
            }
            break;
        case 11: /* buffer_target */
            switch(GLenum(aev._value)) {
#ifdef GL_ARRAY_BUFFER
                case GL_ARRAY_BUFFER:
                    return {s_ARRAY_BUFFER, 12};
#endif
#ifdef GL_ATOMIC_COUNTER_BUFFER
                case GL_ATOMIC_COUNTER_BUFFER:
                    return {s_ATOMIC_COUNTER_BUFFER, 21};
#endif
#ifdef GL_COPY_READ_BUFFER
                case GL_COPY_READ_BUFFER:
                    return {s_COPY_READ_BUFFER, 16};
#endif
#ifdef GL_COPY_WRITE_BUFFER
                case GL_COPY_WRITE_BUFFER:
                    return {s_COPY_WRITE_BUFFER, 17};
#endif
#ifdef GL_DISPATCH_INDIRECT_BUFFER
                case GL_DISPATCH_INDIRECT_BUFFER:
                    return {s_DISPATCH_INDIRECT_BUFFER, 24};
#endif
#ifdef GL_DRAW_INDIRECT_BUFFER
                case GL_DRAW_INDIRECT_BUFFER:
                    return {s_DRAW_INDIRECT_BUFFER, 20};
#endif
#ifdef GL_ELEMENT_ARRAY_BUFFER
                case GL_ELEMENT_ARRAY_BUFFER:
                    return {s_ELEMENT_ARRAY_BUFFER, 20};
#endif
#ifdef GL_EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD
                case GL_EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD:
                    return {s_EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD, 34};
#endif
#ifdef GL_PARAMETER_BUFFER_ARB
                case GL_PARAMETER_BUFFER_ARB:
                    return {s_PARAMETER_BUFFER_ARB, 20};
#endif
#ifdef GL_PIXEL_PACK_BUFFER
                case GL_PIXEL_PACK_BUFFER:
                    return {s_PIXEL_PACK_BUFFER, 17};
#endif
#ifdef GL_PIXEL_UNPACK_BUFFER
                case GL_PIXEL_UNPACK_BUFFER:
                    return {s_PIXEL_UNPACK_BUFFER, 19};
#endif
#ifdef GL_QUERY_BUFFER
                case GL_QUERY_BUFFER:
                    return {s_QUERY_BUFFER, 12};
#endif
#ifdef GL_SHADER_STORAGE_BUFFER
                case GL_SHADER_STORAGE_BUFFER:
                    return {s_SHADER_STORAGE_BUFFER, 21};
#endif
#ifdef GL_TEXTURE_BUFFER
                case GL_TEXTURE_BUFFER:
                    return {s_TEXTURE_BUFFER, 14};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BUFFER
                case GL_TRANSFORM_FEEDBACK_BUFFER:
                    return {s_TRANSFORM_FEEDBACK_BUFFER, 25};
#endif
#ifdef GL_UNIFORM_BUFFER
                case GL_UNIFORM_BUFFER:
                    return {s_UNIFORM_BUFFER, 14};
#endif
                default:;
            }
            break;
        case 12: /* buffer_usage */
            switch(GLenum(aev._value)) {
#ifdef GL_DYNAMIC_COPY
                case GL_DYNAMIC_COPY:
                    return {s_DYNAMIC_COPY, 12};
#endif
#ifdef GL_DYNAMIC_DRAW
                case GL_DYNAMIC_DRAW:
                    return {s_DYNAMIC_DRAW, 12};
#endif
#ifdef GL_DYNAMIC_READ
                case GL_DYNAMIC_READ:
                    return {s_DYNAMIC_READ, 12};
#endif
#ifdef GL_STATIC_COPY
                case GL_STATIC_COPY:
                    return {s_STATIC_COPY, 11};
#endif
#ifdef GL_STATIC_DRAW
                case GL_STATIC_DRAW:
                    return {s_STATIC_DRAW, 11};
#endif
#ifdef GL_STATIC_READ
                case GL_STATIC_READ:
                    return {s_STATIC_READ, 11};
#endif
#ifdef GL_STREAM_COPY
                case GL_STREAM_COPY:
                    return {s_STREAM_COPY, 11};
#endif
#ifdef GL_STREAM_DRAW
                case GL_STREAM_DRAW:
                    return {s_STREAM_DRAW, 11};
#endif
#ifdef GL_STREAM_READ
                case GL_STREAM_READ:
                    return {s_STREAM_READ, 11};
#endif
                default:;
            }
            break;
        case 13: /* capability */
            switch(GLenum(aev._value)) {
#ifdef GL_BLEND
                case GL_BLEND:
                    return {s_BLEND, 5};
#endif
#ifdef GL_BLEND_ADVANCED_COHERENT_KHR
                case GL_BLEND_ADVANCED_COHERENT_KHR:
                    return {s_BLEND_ADVANCED_COHERENT_KHR, 27};
#endif
#ifdef GL_COLOR_LOGIC_OP
                case GL_COLOR_LOGIC_OP:
                    return {s_COLOR_LOGIC_OP, 14};
#endif
#ifdef GL_CULL_FACE
                case GL_CULL_FACE:
                    return {s_CULL_FACE, 9};
#endif
#ifdef GL_DEBUG_OUTPUT
                case GL_DEBUG_OUTPUT:
                    return {s_DEBUG_OUTPUT, 12};
#endif
#ifdef GL_DEBUG_OUTPUT_SYNCHRONOUS
                case GL_DEBUG_OUTPUT_SYNCHRONOUS:
                    return {s_DEBUG_OUTPUT_SYNCHRONOUS, 24};
#endif
#ifdef GL_DEPTH_TEST
                case GL_DEPTH_TEST:
                    return {s_DEPTH_TEST, 10};
#endif
#ifdef GL_DITHER
                case GL_DITHER:
                    return {s_DITHER, 6};
#endif
#ifdef GL_FRAGMENT_COVERAGE_TO_COLOR_NV
                case GL_FRAGMENT_COVERAGE_TO_COLOR_NV:
                    return {s_FRAGMENT_COVERAGE_TO_COLOR_NV, 29};
#endif
#ifdef GL_FRAMEBUFFER_SRGB
                case GL_FRAMEBUFFER_SRGB:
                    return {s_FRAMEBUFFER_SRGB, 16};
#endif
#ifdef GL_LINE_SMOOTH
                case GL_LINE_SMOOTH:
                    return {s_LINE_SMOOTH, 11};
#endif
#ifdef GL_MULTISAMPLE
                case GL_MULTISAMPLE:
                    return {s_MULTISAMPLE, 11};
#endif
#ifdef GL_POLYGON_OFFSET_FILL
                case GL_POLYGON_OFFSET_FILL:
                    return {s_POLYGON_OFFSET_FILL, 19};
#endif
#ifdef GL_POLYGON_OFFSET_LINE
                case GL_POLYGON_OFFSET_LINE:
                    return {s_POLYGON_OFFSET_LINE, 19};
#endif
#ifdef GL_POLYGON_OFFSET_POINT
                case GL_POLYGON_OFFSET_POINT:
                    return {s_POLYGON_OFFSET_POINT, 20};
#endif
#ifdef GL_POLYGON_SMOOTH
                case GL_POLYGON_SMOOTH:
                    return {s_POLYGON_SMOOTH, 14};
#endif
#ifdef GL_PRIMITIVE_RESTART
                case GL_PRIMITIVE_RESTART:
                    return {s_PRIMITIVE_RESTART, 17};
#endif
#ifdef GL_PROGRAM_POINT_SIZE
                case GL_PROGRAM_POINT_SIZE:
                    return {s_PROGRAM_POINT_SIZE, 18};
#endif
#ifdef GL_RASTERIZER_DISCARD
                case GL_RASTERIZER_DISCARD:
                    return {s_RASTERIZER_DISCARD, 18};
#endif
#ifdef GL_SAMPLE_ALPHA_TO_COVERAGE
                case GL_SAMPLE_ALPHA_TO_COVERAGE:
                    return {s_SAMPLE_ALPHA_TO_COVERAGE, 24};
#endif
#ifdef GL_SAMPLE_ALPHA_TO_ONE
                case GL_SAMPLE_ALPHA_TO_ONE:
                    return {s_SAMPLE_ALPHA_TO_ONE, 19};
#endif
#ifdef GL_SAMPLE_COVERAGE
                case GL_SAMPLE_COVERAGE:
                    return {s_SAMPLE_COVERAGE, 15};
#endif
#ifdef GL_SAMPLE_MASK
                case GL_SAMPLE_MASK:
                    return {s_SAMPLE_MASK, 11};
#endif
#ifdef GL_SAMPLE_SHADING
                case GL_SAMPLE_SHADING:
                    return {s_SAMPLE_SHADING, 14};
#endif
#ifdef GL_SCISSOR_TEST
                case GL_SCISSOR_TEST:
                    return {s_SCISSOR_TEST, 12};
#endif
#ifdef GL_STENCIL_TEST
                case GL_STENCIL_TEST:
                    return {s_STENCIL_TEST, 12};
#endif
#ifdef GL_STREAM_RASTERIZATION_AMD
                case GL_STREAM_RASTERIZATION_AMD:
                    return {s_STREAM_RASTERIZATION_AMD, 24};
#endif
#ifdef GL_TEXTURE_CUBE_MAP_SEAMLESS
                case GL_TEXTURE_CUBE_MAP_SEAMLESS:
                    return {s_TEXTURE_CUBE_MAP_SEAMLESS, 25};
#endif
                default:;
            }
            break;
        case 14: /* clamp_color_target */
            switch(GLenum(aev._value)) {
#ifdef GL_CLAMP_READ_COLOR
                case GL_CLAMP_READ_COLOR:
                    return {s_CLAMP_READ_COLOR, 16};
#endif
                default:;
            }
            break;
        case 15: /* client_capability */
            switch(GLenum(aev._value)) {
#ifdef GL_COLOR_ARRAY
                case GL_COLOR_ARRAY:
                    return {s_COLOR_ARRAY, 11};
#endif
#ifdef GL_EDGE_FLAG_ARRAY
                case GL_EDGE_FLAG_ARRAY:
                    return {s_EDGE_FLAG_ARRAY, 15};
#endif
#ifdef GL_ELEMENT_ARRAY_UNIFIED_NV
                case GL_ELEMENT_ARRAY_UNIFIED_NV:
                    return {s_ELEMENT_ARRAY_UNIFIED_NV, 24};
#endif
#ifdef GL_FOG_COORD_ARRAY
                case GL_FOG_COORD_ARRAY:
                    return {s_FOG_COORD_ARRAY, 15};
#endif
#ifdef GL_INDEX_ARRAY
                case GL_INDEX_ARRAY:
                    return {s_INDEX_ARRAY, 11};
#endif
#ifdef GL_NORMAL_ARRAY
                case GL_NORMAL_ARRAY:
                    return {s_NORMAL_ARRAY, 12};
#endif
#ifdef GL_SECONDARY_COLOR_ARRAY
                case GL_SECONDARY_COLOR_ARRAY:
                    return {s_SECONDARY_COLOR_ARRAY, 21};
#endif
#ifdef GL_TEXTURE_COORD_ARRAY
                case GL_TEXTURE_COORD_ARRAY:
                    return {s_TEXTURE_COORD_ARRAY, 19};
#endif
#ifdef GL_UNIFORM_BUFFER_UNIFIED_NV
                case GL_UNIFORM_BUFFER_UNIFIED_NV:
                    return {s_UNIFORM_BUFFER_UNIFIED_NV, 25};
#endif
#ifdef GL_VERTEX_ARRAY
                case GL_VERTEX_ARRAY:
                    return {s_VERTEX_ARRAY, 12};
#endif
#ifdef GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV
                case GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV:
                    return {s_VERTEX_ATTRIB_ARRAY_UNIFIED_NV, 30};
#endif
                default:;
            }
            break;
        case 16: /* clip_depth_mode */
            switch(GLenum(aev._value)) {
#ifdef GL_NEGATIVE_ONE_TO_ONE
                case GL_NEGATIVE_ONE_TO_ONE:
                    return {s_NEGATIVE_ONE_TO_ONE, 19};
#endif
#ifdef GL_ZERO_TO_ONE
                case GL_ZERO_TO_ONE:
                    return {s_ZERO_TO_ONE, 11};
#endif
                default:;
            }
            break;
        case 17: /* clip_origin */
            switch(GLenum(aev._value)) {
#ifdef GL_LOWER_LEFT
                case GL_LOWER_LEFT:
                    return {s_LOWER_LEFT, 10};
#endif
#ifdef GL_UPPER_LEFT
                case GL_UPPER_LEFT:
                    return {s_UPPER_LEFT, 10};
#endif
                default:;
            }
            break;
        case 18: /* color_buffer */
            switch(GLenum(aev._value)) {
#ifdef GL_BACK
                case GL_BACK:
                    return {s_BACK, 4};
#endif
#ifdef GL_BACK_LEFT
                case GL_BACK_LEFT:
                    return {s_BACK_LEFT, 9};
#endif
#ifdef GL_BACK_RIGHT
                case GL_BACK_RIGHT:
                    return {s_BACK_RIGHT, 10};
#endif
#ifdef GL_FRONT
                case GL_FRONT:
                    return {s_FRONT, 5};
#endif
#ifdef GL_FRONT_AND_BACK
                case GL_FRONT_AND_BACK:
                    return {s_FRONT_AND_BACK, 14};
#endif
#ifdef GL_FRONT_LEFT
                case GL_FRONT_LEFT:
                    return {s_FRONT_LEFT, 10};
#endif
#ifdef GL_FRONT_RIGHT
                case GL_FRONT_RIGHT:
                    return {s_FRONT_RIGHT, 11};
#endif
#ifdef GL_LEFT
                case GL_LEFT:
                    return {s_LEFT, 4};
#endif
#ifdef GL_NONE
                case GL_NONE:
                    return {s_NONE, 4};
#endif
#ifdef GL_RIGHT
                case GL_RIGHT:
                    return {s_RIGHT, 5};
#endif
                default:;
            }
            break;
        case 19: /* color_logic_operation */
            switch(GLenum(aev._value)) {
#ifdef GL_AND
                case GL_AND:
                    return {s_AND, 3};
#endif
#ifdef GL_AND_INVERTED
                case GL_AND_INVERTED:
                    return {s_AND_INVERTED, 12};
#endif
#ifdef GL_AND_REVERSE
                case GL_AND_REVERSE:
                    return {s_AND_REVERSE, 11};
#endif
#ifdef GL_CLEAR
                case GL_CLEAR:
                    return {s_CLEAR, 5};
#endif
#ifdef GL_COPY
                case GL_COPY:
                    return {s_COPY, 4};
#endif
#ifdef GL_COPY_INVERTED
                case GL_COPY_INVERTED:
                    return {s_COPY_INVERTED, 13};
#endif
#ifdef GL_EQUIV
                case GL_EQUIV:
                    return {s_EQUIV, 5};
#endif
#ifdef GL_INVERT
                case GL_INVERT:
                    return {s_INVERT, 6};
#endif
#ifdef GL_NAND
                case GL_NAND:
                    return {s_NAND, 4};
#endif
#ifdef GL_NOOP
                case GL_NOOP:
                    return {s_NOOP, 4};
#endif
#ifdef GL_NOR
                case GL_NOR:
                    return {s_NOR, 3};
#endif
#ifdef GL_OR
                case GL_OR:
                    return {s_OR, 2};
#endif
#ifdef GL_OR_INVERTED
                case GL_OR_INVERTED:
                    return {s_OR_INVERTED, 11};
#endif
#ifdef GL_OR_REVERSE
                case GL_OR_REVERSE:
                    return {s_OR_REVERSE, 10};
#endif
#ifdef GL_SET
                case GL_SET:
                    return {s_SET, 3};
#endif
#ifdef GL_XOR
                case GL_XOR:
                    return {s_XOR, 3};
#endif
                default:;
            }
            break;
        case 20: /* command_token_nv */
            switch(GLenum(aev._value)) {
#ifdef GL_ALPHA_REF_COMMAND_NV
                case GL_ALPHA_REF_COMMAND_NV:
                    return {s_ALPHA_REF_COMMAND_NV, 20};
#endif
#ifdef GL_ATTRIBUTE_ADDRESS_COMMAND_NV
                case GL_ATTRIBUTE_ADDRESS_COMMAND_NV:
                    return {s_ATTRIBUTE_ADDRESS_COMMAND_NV, 28};
#endif
#ifdef GL_BLEND_COLOR_COMMAND_NV
                case GL_BLEND_COLOR_COMMAND_NV:
                    return {s_BLEND_COLOR_COMMAND_NV, 22};
#endif
#ifdef GL_DRAW_ARRAYS_COMMAND_NV
                case GL_DRAW_ARRAYS_COMMAND_NV:
                    return {s_DRAW_ARRAYS_COMMAND_NV, 22};
#endif
#ifdef GL_DRAW_ARRAYS_INSTANCED_COMMAND_NV
                case GL_DRAW_ARRAYS_INSTANCED_COMMAND_NV:
                    return {s_DRAW_ARRAYS_INSTANCED_COMMAND_NV, 32};
#endif
#ifdef GL_DRAW_ARRAYS_STRIP_COMMAND_NV
                case GL_DRAW_ARRAYS_STRIP_COMMAND_NV:
                    return {s_DRAW_ARRAYS_STRIP_COMMAND_NV, 28};
#endif
#ifdef GL_DRAW_ELEMENTS_COMMAND_NV
                case GL_DRAW_ELEMENTS_COMMAND_NV:
                    return {s_DRAW_ELEMENTS_COMMAND_NV, 24};
#endif
#ifdef GL_DRAW_ELEMENTS_INSTANCED_COMMAND_NV
                case GL_DRAW_ELEMENTS_INSTANCED_COMMAND_NV:
                    return {s_DRAW_ELEMENTS_INSTANCED_COMMAND_NV, 34};
#endif
#ifdef GL_DRAW_ELEMENTS_STRIP_COMMAND_NV
                case GL_DRAW_ELEMENTS_STRIP_COMMAND_NV:
                    return {s_DRAW_ELEMENTS_STRIP_COMMAND_NV, 30};
#endif
#ifdef GL_ELEMENT_ADDRESS_COMMAND_NV
                case GL_ELEMENT_ADDRESS_COMMAND_NV:
                    return {s_ELEMENT_ADDRESS_COMMAND_NV, 26};
#endif
#ifdef GL_FRONT_FACE_COMMAND_NV
                case GL_FRONT_FACE_COMMAND_NV:
                    return {s_FRONT_FACE_COMMAND_NV, 21};
#endif
#ifdef GL_LINE_WIDTH_COMMAND_NV
                case GL_LINE_WIDTH_COMMAND_NV:
                    return {s_LINE_WIDTH_COMMAND_NV, 21};
#endif
#ifdef GL_NOP_COMMAND_NV
                case GL_NOP_COMMAND_NV:
                    return {s_NOP_COMMAND_NV, 14};
#endif
#ifdef GL_POLYGON_OFFSET_COMMAND_NV
                case GL_POLYGON_OFFSET_COMMAND_NV:
                    return {s_POLYGON_OFFSET_COMMAND_NV, 25};
#endif
#ifdef GL_SCISSOR_COMMAND_NV
                case GL_SCISSOR_COMMAND_NV:
                    return {s_SCISSOR_COMMAND_NV, 18};
#endif
#ifdef GL_STENCIL_REF_COMMAND_NV
                case GL_STENCIL_REF_COMMAND_NV:
                    return {s_STENCIL_REF_COMMAND_NV, 22};
#endif
#ifdef GL_TERMINATE_SEQUENCE_COMMAND_NV
                case GL_TERMINATE_SEQUENCE_COMMAND_NV:
                    return {s_TERMINATE_SEQUENCE_COMMAND_NV, 29};
#endif
#ifdef GL_UNIFORM_ADDRESS_COMMAND_NV
                case GL_UNIFORM_ADDRESS_COMMAND_NV:
                    return {s_UNIFORM_ADDRESS_COMMAND_NV, 26};
#endif
#ifdef GL_VIEWPORT_COMMAND_NV
                case GL_VIEWPORT_COMMAND_NV:
                    return {s_VIEWPORT_COMMAND_NV, 19};
#endif
                default:;
            }
            break;
        case 21: /* compare_function */
            switch(GLenum(aev._value)) {
#ifdef GL_ALWAYS
                case GL_ALWAYS:
                    return {s_ALWAYS, 6};
#endif
#ifdef GL_EQUAL
                case GL_EQUAL:
                    return {s_EQUAL, 5};
#endif
#ifdef GL_GEQUAL
                case GL_GEQUAL:
                    return {s_GEQUAL, 6};
#endif
#ifdef GL_GREATER
                case GL_GREATER:
                    return {s_GREATER, 7};
#endif
#ifdef GL_LEQUAL
                case GL_LEQUAL:
                    return {s_LEQUAL, 6};
#endif
#ifdef GL_LESS
                case GL_LESS:
                    return {s_LESS, 4};
#endif
#ifdef GL_NEVER
                case GL_NEVER:
                    return {s_NEVER, 5};
#endif
#ifdef GL_NOTEQUAL
                case GL_NOTEQUAL:
                    return {s_NOTEQUAL, 8};
#endif
                default:;
            }
            break;
        case 22: /* conditional_render_mode */
            switch(GLenum(aev._value)) {
#ifdef GL_QUERY_BY_REGION_NO_WAIT
                case GL_QUERY_BY_REGION_NO_WAIT:
                    return {s_QUERY_BY_REGION_NO_WAIT, 23};
#endif
#ifdef GL_QUERY_BY_REGION_NO_WAIT_INVERTED
                case GL_QUERY_BY_REGION_NO_WAIT_INVERTED:
                    return {s_QUERY_BY_REGION_NO_WAIT_INVERTED, 32};
#endif
#ifdef GL_QUERY_BY_REGION_WAIT
                case GL_QUERY_BY_REGION_WAIT:
                    return {s_QUERY_BY_REGION_WAIT, 20};
#endif
#ifdef GL_QUERY_BY_REGION_WAIT_INVERTED
                case GL_QUERY_BY_REGION_WAIT_INVERTED:
                    return {s_QUERY_BY_REGION_WAIT_INVERTED, 29};
#endif
#ifdef GL_QUERY_NO_WAIT
                case GL_QUERY_NO_WAIT:
                    return {s_QUERY_NO_WAIT, 13};
#endif
#ifdef GL_QUERY_NO_WAIT_INVERTED
                case GL_QUERY_NO_WAIT_INVERTED:
                    return {s_QUERY_NO_WAIT_INVERTED, 22};
#endif
#ifdef GL_QUERY_WAIT
                case GL_QUERY_WAIT:
                    return {s_QUERY_WAIT, 10};
#endif
#ifdef GL_QUERY_WAIT_INVERTED
                case GL_QUERY_WAIT_INVERTED:
                    return {s_QUERY_WAIT_INVERTED, 19};
#endif
                default:;
            }
            break;
        case 23: /* context_flag_bits */
            switch(GLbitfield(aev._value)) {
#ifdef GL_CONTEXT_FLAG_DEBUG_BIT
                case GL_CONTEXT_FLAG_DEBUG_BIT:
                    return {s_CONTEXT_FLAG_DEBUG_BIT, 22};
#endif
#ifdef GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT
                case GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT:
                    return {s_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT, 35};
#endif
#ifdef GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB
                case GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB:
                    return {s_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB, 34};
#endif
                default:;
            }
            break;
        case 24: /* context_profile_bits */
            switch(GLbitfield(aev._value)) {
#ifdef GL_CONTEXT_COMPATIBILITY_PROFILE_BIT
                case GL_CONTEXT_COMPATIBILITY_PROFILE_BIT:
                    return {s_CONTEXT_COMPATIBILITY_PROFILE_BIT, 33};
#endif
#ifdef GL_CONTEXT_CORE_PROFILE_BIT
                case GL_CONTEXT_CORE_PROFILE_BIT:
                    return {s_CONTEXT_CORE_PROFILE_BIT, 24};
#endif
                default:;
            }
            break;
        case 25: /* context_release_behavior */
            switch(GLenum(aev._value)) {
#ifdef GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH
                case GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH:
                    return {s_CONTEXT_RELEASE_BEHAVIOR_FLUSH, 30};
#endif
#ifdef GL_NONE
                case GL_NONE:
                    return {s_NONE, 4};
#endif
                default:;
            }
            break;
        case 26: /* data_type */
            switch(GLenum(aev._value)) {
#ifdef GL_BYTE
                case GL_BYTE:
                    return {s_BYTE, 4};
#endif
#ifdef GL_DOUBLE
                case GL_DOUBLE:
                    return {s_DOUBLE, 6};
#endif
#ifdef GL_FIXED
                case GL_FIXED:
                    return {s_FIXED, 5};
#endif
#ifdef GL_FLOAT
                case GL_FLOAT:
                    return {s_FLOAT, 5};
#endif
#ifdef GL_HALF_FLOAT
                case GL_HALF_FLOAT:
                    return {s_HALF_FLOAT, 10};
#endif
#ifdef GL_INT
                case GL_INT:
                    return {s_INT, 3};
#endif
#ifdef GL_SHORT
                case GL_SHORT:
                    return {s_SHORT, 5};
#endif
#ifdef GL_UNSIGNED_BYTE
                case GL_UNSIGNED_BYTE:
                    return {s_UNSIGNED_BYTE, 13};
#endif
#ifdef GL_UNSIGNED_INT
                case GL_UNSIGNED_INT:
                    return {s_UNSIGNED_INT, 12};
#endif
#ifdef GL_UNSIGNED_SHORT
                case GL_UNSIGNED_SHORT:
                    return {s_UNSIGNED_SHORT, 14};
#endif
                default:;
            }
            break;
        case 27: /* debug_output_severity */
            switch(GLenum(aev._value)) {
#ifdef GL_DEBUG_SEVERITY_HIGH
                case GL_DEBUG_SEVERITY_HIGH:
                    return {s_DEBUG_SEVERITY_HIGH, 19};
#endif
#ifdef GL_DEBUG_SEVERITY_LOW
                case GL_DEBUG_SEVERITY_LOW:
                    return {s_DEBUG_SEVERITY_LOW, 18};
#endif
#ifdef GL_DEBUG_SEVERITY_MEDIUM
                case GL_DEBUG_SEVERITY_MEDIUM:
                    return {s_DEBUG_SEVERITY_MEDIUM, 21};
#endif
#ifdef GL_DEBUG_SEVERITY_NOTIFICATION
                case GL_DEBUG_SEVERITY_NOTIFICATION:
                    return {s_DEBUG_SEVERITY_NOTIFICATION, 27};
#endif
#ifdef GL_DONT_CARE
                case GL_DONT_CARE:
                    return {s_DONT_CARE, 9};
#endif
                default:;
            }
            break;
        case 28: /* debug_output_source */
            switch(GLenum(aev._value)) {
#ifdef GL_DEBUG_SOURCE_API
                case GL_DEBUG_SOURCE_API:
                    return {s_DEBUG_SOURCE_API, 16};
#endif
#ifdef GL_DEBUG_SOURCE_APPLICATION
                case GL_DEBUG_SOURCE_APPLICATION:
                    return {s_DEBUG_SOURCE_APPLICATION, 24};
#endif
#ifdef GL_DEBUG_SOURCE_OTHER
                case GL_DEBUG_SOURCE_OTHER:
                    return {s_DEBUG_SOURCE_OTHER, 18};
#endif
#ifdef GL_DEBUG_SOURCE_SHADER_COMPILER
                case GL_DEBUG_SOURCE_SHADER_COMPILER:
                    return {s_DEBUG_SOURCE_SHADER_COMPILER, 28};
#endif
#ifdef GL_DEBUG_SOURCE_THIRD_PARTY
                case GL_DEBUG_SOURCE_THIRD_PARTY:
                    return {s_DEBUG_SOURCE_THIRD_PARTY, 24};
#endif
#ifdef GL_DEBUG_SOURCE_WINDOW_SYSTEM
                case GL_DEBUG_SOURCE_WINDOW_SYSTEM:
                    return {s_DEBUG_SOURCE_WINDOW_SYSTEM, 26};
#endif
#ifdef GL_DONT_CARE
                case GL_DONT_CARE:
                    return {s_DONT_CARE, 9};
#endif
                default:;
            }
            break;
        case 29: /* debug_output_type */
            switch(GLenum(aev._value)) {
#ifdef GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR
                case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR:
                    return {s_DEBUG_TYPE_DEPRECATED_BEHAVIOR, 30};
#endif
#ifdef GL_DEBUG_TYPE_ERROR
                case GL_DEBUG_TYPE_ERROR:
                    return {s_DEBUG_TYPE_ERROR, 16};
#endif
#ifdef GL_DEBUG_TYPE_MARKER
                case GL_DEBUG_TYPE_MARKER:
                    return {s_DEBUG_TYPE_MARKER, 17};
#endif
#ifdef GL_DEBUG_TYPE_OTHER
                case GL_DEBUG_TYPE_OTHER:
                    return {s_DEBUG_TYPE_OTHER, 16};
#endif
#ifdef GL_DEBUG_TYPE_PERFORMANCE
                case GL_DEBUG_TYPE_PERFORMANCE:
                    return {s_DEBUG_TYPE_PERFORMANCE, 22};
#endif
#ifdef GL_DEBUG_TYPE_POP_GROUP
                case GL_DEBUG_TYPE_POP_GROUP:
                    return {s_DEBUG_TYPE_POP_GROUP, 20};
#endif
#ifdef GL_DEBUG_TYPE_PORTABILITY
                case GL_DEBUG_TYPE_PORTABILITY:
                    return {s_DEBUG_TYPE_PORTABILITY, 22};
#endif
#ifdef GL_DEBUG_TYPE_PUSH_GROUP
                case GL_DEBUG_TYPE_PUSH_GROUP:
                    return {s_DEBUG_TYPE_PUSH_GROUP, 21};
#endif
#ifdef GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR
                case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:
                    return {s_DEBUG_TYPE_UNDEFINED_BEHAVIOR, 29};
#endif
#ifdef GL_DONT_CARE
                case GL_DONT_CARE:
                    return {s_DONT_CARE, 9};
#endif
                default:;
            }
            break;
        case 30: /* error_code */
            switch(GLenum(aev._value)) {
#ifdef GL_CONTEXT_LOST
                case GL_CONTEXT_LOST:
                    return {s_CONTEXT_LOST, 12};
#endif
#ifdef GL_INVALID_ENUM
                case GL_INVALID_ENUM:
                    return {s_INVALID_ENUM, 12};
#endif
#ifdef GL_INVALID_FRAMEBUFFER_OPERATION
                case GL_INVALID_FRAMEBUFFER_OPERATION:
                    return {s_INVALID_FRAMEBUFFER_OPERATION, 29};
#endif
#ifdef GL_INVALID_OPERATION
                case GL_INVALID_OPERATION:
                    return {s_INVALID_OPERATION, 17};
#endif
#ifdef GL_INVALID_VALUE
                case GL_INVALID_VALUE:
                    return {s_INVALID_VALUE, 13};
#endif
#ifdef GL_NO_ERROR
                case GL_NO_ERROR:
                    return {s_NO_ERROR, 8};
#endif
#ifdef GL_OUT_OF_MEMORY
                case GL_OUT_OF_MEMORY:
                    return {s_OUT_OF_MEMORY, 13};
#endif
#ifdef GL_STACK_OVERFLOW
                case GL_STACK_OVERFLOW:
                    return {s_STACK_OVERFLOW, 14};
#endif
#ifdef GL_STACK_UNDERFLOW
                case GL_STACK_UNDERFLOW:
                    return {s_STACK_UNDERFLOW, 15};
#endif
#ifdef GL_TABLE_TOO_LARGE
                case GL_TABLE_TOO_LARGE:
                    return {s_TABLE_TOO_LARGE, 15};
#endif
                default:;
            }
            break;
        case 31: /* face */
            switch(GLenum(aev._value)) {
#ifdef GL_BACK
                case GL_BACK:
                    return {s_BACK, 4};
#endif
#ifdef GL_FRONT
                case GL_FRONT:
                    return {s_FRONT, 5};
#endif
#ifdef GL_FRONT_AND_BACK
                case GL_FRONT_AND_BACK:
                    return {s_FRONT_AND_BACK, 14};
#endif
                default:;
            }
            break;
        case 32: /* face_orientation */
            switch(GLenum(aev._value)) {
#ifdef GL_CCW
                case GL_CCW:
                    return {s_CCW, 3};
#endif
#ifdef GL_CW
                case GL_CW:
                    return {s_CW, 2};
#endif
                default:;
            }
            break;
        case 33: /* framebuffer_buffer */
            switch(GLenum(aev._value)) {
#ifdef GL_COLOR
                case GL_COLOR:
                    return {s_COLOR, 5};
#endif
#ifdef GL_DEPTH
                case GL_DEPTH:
                    return {s_DEPTH, 5};
#endif
#ifdef GL_DEPTH_STENCIL
                case GL_DEPTH_STENCIL:
                    return {s_DEPTH_STENCIL, 13};
#endif
#ifdef GL_STENCIL
                case GL_STENCIL:
                    return {s_STENCIL, 7};
#endif
                default:;
            }
            break;
        case 34: /* framebuffer_other_attachment */
            switch(GLenum(aev._value)) {
#ifdef GL_DEPTH_ATTACHMENT
                case GL_DEPTH_ATTACHMENT:
                    return {s_DEPTH_ATTACHMENT, 16};
#endif
#ifdef GL_DEPTH_STENCIL_ATTACHMENT
                case GL_DEPTH_STENCIL_ATTACHMENT:
                    return {s_DEPTH_STENCIL_ATTACHMENT, 24};
#endif
#ifdef GL_STENCIL_ATTACHMENT
                case GL_STENCIL_ATTACHMENT:
                    return {s_STENCIL_ATTACHMENT, 18};
#endif
                default:;
            }
            break;
        case 35: /* framebuffer_parameter */
            switch(GLenum(aev._value)) {
#ifdef GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS
                case GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS:
                    return {s_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS, 42};
#endif
#ifdef GL_FRAMEBUFFER_DEFAULT_HEIGHT
                case GL_FRAMEBUFFER_DEFAULT_HEIGHT:
                    return {s_FRAMEBUFFER_DEFAULT_HEIGHT, 26};
#endif
#ifdef GL_FRAMEBUFFER_DEFAULT_LAYERS
                case GL_FRAMEBUFFER_DEFAULT_LAYERS:
                    return {s_FRAMEBUFFER_DEFAULT_LAYERS, 26};
#endif
#ifdef GL_FRAMEBUFFER_DEFAULT_SAMPLES
                case GL_FRAMEBUFFER_DEFAULT_SAMPLES:
                    return {s_FRAMEBUFFER_DEFAULT_SAMPLES, 27};
#endif
#ifdef GL_FRAMEBUFFER_DEFAULT_WIDTH
                case GL_FRAMEBUFFER_DEFAULT_WIDTH:
                    return {s_FRAMEBUFFER_DEFAULT_WIDTH, 25};
#endif
                default:;
            }
            break;
        case 36: /* framebuffer_status */
            switch(GLenum(aev._value)) {
#ifdef GL_FRAMEBUFFER_COMPLETE
                case GL_FRAMEBUFFER_COMPLETE:
                    return {s_FRAMEBUFFER_COMPLETE, 20};
#endif
#ifdef GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
                case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    return {s_FRAMEBUFFER_INCOMPLETE_ATTACHMENT, 33};
#endif
#ifdef GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS
                case GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS:
                    return {s_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS, 36};
#endif
#ifdef GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT
                case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    return {s_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT, 41};
#endif
#ifdef GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE
                case GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:
                    return {s_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE, 34};
#endif
#ifdef GL_FRAMEBUFFER_UNDEFINED
                case GL_FRAMEBUFFER_UNDEFINED:
                    return {s_FRAMEBUFFER_UNDEFINED, 21};
#endif
#ifdef GL_FRAMEBUFFER_UNSUPPORTED
                case GL_FRAMEBUFFER_UNSUPPORTED:
                    return {s_FRAMEBUFFER_UNSUPPORTED, 23};
#endif
                default:;
            }
            break;
        case 37: /* framebuffer_target */
            switch(GLenum(aev._value)) {
#ifdef GL_DRAW_FRAMEBUFFER
                case GL_DRAW_FRAMEBUFFER:
                    return {s_DRAW_FRAMEBUFFER, 16};
#endif
#ifdef GL_READ_FRAMEBUFFER
                case GL_READ_FRAMEBUFFER:
                    return {s_READ_FRAMEBUFFER, 16};
#endif
                default:;
            }
            break;
        case 38: /* graphics_reset_status */
            switch(GLenum(aev._value)) {
#ifdef GL_GUILTY_CONTEXT_RESET
                case GL_GUILTY_CONTEXT_RESET:
                    return {s_GUILTY_CONTEXT_RESET, 20};
#endif
#ifdef GL_INNOCENT_CONTEXT_RESET
                case GL_INNOCENT_CONTEXT_RESET:
                    return {s_INNOCENT_CONTEXT_RESET, 22};
#endif
#ifdef GL_NO_ERROR
                case GL_NO_ERROR:
                    return {s_NO_ERROR, 8};
#endif
#ifdef GL_UNKNOWN_CONTEXT_RESET
                case GL_UNKNOWN_CONTEXT_RESET:
                    return {s_UNKNOWN_CONTEXT_RESET, 21};
#endif
                default:;
            }
            break;
        case 39: /* hint_option */
            switch(GLenum(aev._value)) {
#ifdef GL_DONT_CARE
                case GL_DONT_CARE:
                    return {s_DONT_CARE, 9};
#endif
#ifdef GL_FASTEST
                case GL_FASTEST:
                    return {s_FASTEST, 7};
#endif
#ifdef GL_NICEST
                case GL_NICEST:
                    return {s_NICEST, 6};
#endif
                default:;
            }
            break;
        case 40: /* hint_target */
            switch(GLenum(aev._value)) {
#ifdef GL_FRAGMENT_SHADER_DERIVATIVE_HINT
                case GL_FRAGMENT_SHADER_DERIVATIVE_HINT:
                    return {s_FRAGMENT_SHADER_DERIVATIVE_HINT, 31};
#endif
#ifdef GL_LINE_SMOOTH_HINT
                case GL_LINE_SMOOTH_HINT:
                    return {s_LINE_SMOOTH_HINT, 16};
#endif
#ifdef GL_POLYGON_SMOOTH_HINT
                case GL_POLYGON_SMOOTH_HINT:
                    return {s_POLYGON_SMOOTH_HINT, 19};
#endif
#ifdef GL_TEXTURE_COMPRESSION_HINT
                case GL_TEXTURE_COMPRESSION_HINT:
                    return {s_TEXTURE_COMPRESSION_HINT, 24};
#endif
                default:;
            }
            break;
        case 41: /* image_compatibility_class */
            switch(GLenum(aev._value)) {
#ifdef GL_IMAGE_CLASS_10_10_10_2
                case GL_IMAGE_CLASS_10_10_10_2:
                    return {s_IMAGE_CLASS_10_10_10_2, 22};
#endif
#ifdef GL_IMAGE_CLASS_11_11_10
                case GL_IMAGE_CLASS_11_11_10:
                    return {s_IMAGE_CLASS_11_11_10, 20};
#endif
#ifdef GL_IMAGE_CLASS_1_X_16
                case GL_IMAGE_CLASS_1_X_16:
                    return {s_IMAGE_CLASS_1_X_16, 18};
#endif
#ifdef GL_IMAGE_CLASS_1_X_32
                case GL_IMAGE_CLASS_1_X_32:
                    return {s_IMAGE_CLASS_1_X_32, 18};
#endif
#ifdef GL_IMAGE_CLASS_1_X_8
                case GL_IMAGE_CLASS_1_X_8:
                    return {s_IMAGE_CLASS_1_X_8, 17};
#endif
#ifdef GL_IMAGE_CLASS_2_X_16
                case GL_IMAGE_CLASS_2_X_16:
                    return {s_IMAGE_CLASS_2_X_16, 18};
#endif
#ifdef GL_IMAGE_CLASS_2_X_32
                case GL_IMAGE_CLASS_2_X_32:
                    return {s_IMAGE_CLASS_2_X_32, 18};
#endif
#ifdef GL_IMAGE_CLASS_2_X_8
                case GL_IMAGE_CLASS_2_X_8:
                    return {s_IMAGE_CLASS_2_X_8, 17};
#endif
#ifdef GL_IMAGE_CLASS_4_X_16
                case GL_IMAGE_CLASS_4_X_16:
                    return {s_IMAGE_CLASS_4_X_16, 18};
#endif
#ifdef GL_IMAGE_CLASS_4_X_32
                case GL_IMAGE_CLASS_4_X_32:
                    return {s_IMAGE_CLASS_4_X_32, 18};
#endif
#ifdef GL_IMAGE_CLASS_4_X_8
                case GL_IMAGE_CLASS_4_X_8:
                    return {s_IMAGE_CLASS_4_X_8, 17};
#endif
                default:;
            }
            break;
        case 42: /* image_unit_format */
            switch(GLenum(aev._value)) {
#ifdef GL_R11F_G11F_B10F
                case GL_R11F_G11F_B10F:
                    return {s_R11F_G11F_B10F, 14};
#endif
#ifdef GL_R16
                case GL_R16:
                    return {s_R16, 3};
#endif
#ifdef GL_R16F
                case GL_R16F:
                    return {s_R16F, 4};
#endif
#ifdef GL_R16I
                case GL_R16I:
                    return {s_R16I, 4};
#endif
#ifdef GL_R16UI
                case GL_R16UI:
                    return {s_R16UI, 5};
#endif
#ifdef GL_R16_SNORM
                case GL_R16_SNORM:
                    return {s_R16_SNORM, 9};
#endif
#ifdef GL_R32F
                case GL_R32F:
                    return {s_R32F, 4};
#endif
#ifdef GL_R32I
                case GL_R32I:
                    return {s_R32I, 4};
#endif
#ifdef GL_R32UI
                case GL_R32UI:
                    return {s_R32UI, 5};
#endif
#ifdef GL_R8
                case GL_R8:
                    return {s_R8, 2};
#endif
#ifdef GL_R8I
                case GL_R8I:
                    return {s_R8I, 3};
#endif
#ifdef GL_R8UI
                case GL_R8UI:
                    return {s_R8UI, 4};
#endif
#ifdef GL_R8_SNORM
                case GL_R8_SNORM:
                    return {s_R8_SNORM, 8};
#endif
#ifdef GL_RG16
                case GL_RG16:
                    return {s_RG16, 4};
#endif
#ifdef GL_RG16F
                case GL_RG16F:
                    return {s_RG16F, 5};
#endif
#ifdef GL_RG16I
                case GL_RG16I:
                    return {s_RG16I, 5};
#endif
#ifdef GL_RG16UI
                case GL_RG16UI:
                    return {s_RG16UI, 6};
#endif
#ifdef GL_RG16_SNORM
                case GL_RG16_SNORM:
                    return {s_RG16_SNORM, 10};
#endif
#ifdef GL_RG32F
                case GL_RG32F:
                    return {s_RG32F, 5};
#endif
#ifdef GL_RG32I
                case GL_RG32I:
                    return {s_RG32I, 5};
#endif
#ifdef GL_RG32UI
                case GL_RG32UI:
                    return {s_RG32UI, 6};
#endif
#ifdef GL_RG8
                case GL_RG8:
                    return {s_RG8, 3};
#endif
#ifdef GL_RG8I
                case GL_RG8I:
                    return {s_RG8I, 4};
#endif
#ifdef GL_RG8UI
                case GL_RG8UI:
                    return {s_RG8UI, 5};
#endif
#ifdef GL_RG8_SNORM
                case GL_RG8_SNORM:
                    return {s_RG8_SNORM, 9};
#endif
#ifdef GL_RGB10_A2
                case GL_RGB10_A2:
                    return {s_RGB10_A2, 8};
#endif
#ifdef GL_RGB10_A2UI
                case GL_RGB10_A2UI:
                    return {s_RGB10_A2UI, 10};
#endif
#ifdef GL_RGBA16
                case GL_RGBA16:
                    return {s_RGBA16, 6};
#endif
#ifdef GL_RGBA16F
                case GL_RGBA16F:
                    return {s_RGBA16F, 7};
#endif
#ifdef GL_RGBA16I
                case GL_RGBA16I:
                    return {s_RGBA16I, 7};
#endif
#ifdef GL_RGBA16UI
                case GL_RGBA16UI:
                    return {s_RGBA16UI, 8};
#endif
#ifdef GL_RGBA16_SNORM
                case GL_RGBA16_SNORM:
                    return {s_RGBA16_SNORM, 12};
#endif
#ifdef GL_RGBA32F
                case GL_RGBA32F:
                    return {s_RGBA32F, 7};
#endif
#ifdef GL_RGBA32I
                case GL_RGBA32I:
                    return {s_RGBA32I, 7};
#endif
#ifdef GL_RGBA32UI
                case GL_RGBA32UI:
                    return {s_RGBA32UI, 8};
#endif
#ifdef GL_RGBA8
                case GL_RGBA8:
                    return {s_RGBA8, 5};
#endif
#ifdef GL_RGBA8I
                case GL_RGBA8I:
                    return {s_RGBA8I, 6};
#endif
#ifdef GL_RGBA8UI
                case GL_RGBA8UI:
                    return {s_RGBA8UI, 7};
#endif
#ifdef GL_RGBA8_SNORM
                case GL_RGBA8_SNORM:
                    return {s_RGBA8_SNORM, 11};
#endif
                default:;
            }
            break;
        case 43: /* index_type */
            switch(GLenum(aev._value)) {
#ifdef GL_UNSIGNED_BYTE
                case GL_UNSIGNED_BYTE:
                    return {s_UNSIGNED_BYTE, 13};
#endif
#ifdef GL_UNSIGNED_INT
                case GL_UNSIGNED_INT:
                    return {s_UNSIGNED_INT, 12};
#endif
#ifdef GL_UNSIGNED_SHORT
                case GL_UNSIGNED_SHORT:
                    return {s_UNSIGNED_SHORT, 14};
#endif
                default:;
            }
            break;
        case 44: /* indexed_value_base */
            switch(GLenum(aev._value)) {
#ifdef GL_CLIP_DISTANCE0
                case GL_CLIP_DISTANCE0:
                    return {s_CLIP_DISTANCE0, 14};
#endif
#ifdef GL_COLOR_ATTACHMENT0
                case GL_COLOR_ATTACHMENT0:
                    return {s_COLOR_ATTACHMENT0, 17};
#endif
#ifdef GL_DRAW_BUFFER0
                case GL_DRAW_BUFFER0:
                    return {s_DRAW_BUFFER0, 12};
#endif
#ifdef GL_TEXTURE0
                case GL_TEXTURE0:
                    return {s_TEXTURE0, 8};
#endif
                default:;
            }
            break;
        case 45: /* internal_format_parameter */
            switch(GLenum(aev._value)) {
#ifdef GL_AUTO_GENERATE_MIPMAP
                case GL_AUTO_GENERATE_MIPMAP:
                    return {s_AUTO_GENERATE_MIPMAP, 20};
#endif
#ifdef GL_CLEAR_BUFFER
                case GL_CLEAR_BUFFER:
                    return {s_CLEAR_BUFFER, 12};
#endif
#ifdef GL_CLEAR_TEXTURE
                case GL_CLEAR_TEXTURE:
                    return {s_CLEAR_TEXTURE, 13};
#endif
#ifdef GL_COLOR_COMPONENTS
                case GL_COLOR_COMPONENTS:
                    return {s_COLOR_COMPONENTS, 16};
#endif
#ifdef GL_COLOR_ENCODING
                case GL_COLOR_ENCODING:
                    return {s_COLOR_ENCODING, 14};
#endif
#ifdef GL_COLOR_RENDERABLE
                case GL_COLOR_RENDERABLE:
                    return {s_COLOR_RENDERABLE, 16};
#endif
#ifdef GL_COMPUTE_TEXTURE
                case GL_COMPUTE_TEXTURE:
                    return {s_COMPUTE_TEXTURE, 15};
#endif
#ifdef GL_DEPTH_COMPONENTS
                case GL_DEPTH_COMPONENTS:
                    return {s_DEPTH_COMPONENTS, 16};
#endif
#ifdef GL_DEPTH_RENDERABLE
                case GL_DEPTH_RENDERABLE:
                    return {s_DEPTH_RENDERABLE, 16};
#endif
#ifdef GL_FILTER
                case GL_FILTER:
                    return {s_FILTER, 6};
#endif
#ifdef GL_FRAGMENT_TEXTURE
                case GL_FRAGMENT_TEXTURE:
                    return {s_FRAGMENT_TEXTURE, 16};
#endif
#ifdef GL_FRAMEBUFFER_BLEND
                case GL_FRAMEBUFFER_BLEND:
                    return {s_FRAMEBUFFER_BLEND, 17};
#endif
#ifdef GL_FRAMEBUFFER_RENDERABLE
                case GL_FRAMEBUFFER_RENDERABLE:
                    return {s_FRAMEBUFFER_RENDERABLE, 22};
#endif
#ifdef GL_FRAMEBUFFER_RENDERABLE_LAYERED
                case GL_FRAMEBUFFER_RENDERABLE_LAYERED:
                    return {s_FRAMEBUFFER_RENDERABLE_LAYERED, 30};
#endif
#ifdef GL_GENERATE_MIPMAP
                case GL_GENERATE_MIPMAP:
                    return {s_GENERATE_MIPMAP, 15};
#endif
#ifdef GL_GEOMETRY_TEXTURE
                case GL_GEOMETRY_TEXTURE:
                    return {s_GEOMETRY_TEXTURE, 16};
#endif
#ifdef GL_GET_TEXTURE_IMAGE_FORMAT
                case GL_GET_TEXTURE_IMAGE_FORMAT:
                    return {s_GET_TEXTURE_IMAGE_FORMAT, 24};
#endif
#ifdef GL_GET_TEXTURE_IMAGE_TYPE
                case GL_GET_TEXTURE_IMAGE_TYPE:
                    return {s_GET_TEXTURE_IMAGE_TYPE, 22};
#endif
#ifdef GL_IMAGE_COMPATIBILITY_CLASS
                case GL_IMAGE_COMPATIBILITY_CLASS:
                    return {s_IMAGE_COMPATIBILITY_CLASS, 25};
#endif
#ifdef GL_IMAGE_FORMAT_COMPATIBILITY_TYPE
                case GL_IMAGE_FORMAT_COMPATIBILITY_TYPE:
                    return {s_IMAGE_FORMAT_COMPATIBILITY_TYPE, 31};
#endif
#ifdef GL_IMAGE_PIXEL_FORMAT
                case GL_IMAGE_PIXEL_FORMAT:
                    return {s_IMAGE_PIXEL_FORMAT, 18};
#endif
#ifdef GL_IMAGE_PIXEL_TYPE
                case GL_IMAGE_PIXEL_TYPE:
                    return {s_IMAGE_PIXEL_TYPE, 16};
#endif
#ifdef GL_IMAGE_TEXEL_SIZE
                case GL_IMAGE_TEXEL_SIZE:
                    return {s_IMAGE_TEXEL_SIZE, 16};
#endif
#ifdef GL_INTERNALFORMAT_ALPHA_SIZE
                case GL_INTERNALFORMAT_ALPHA_SIZE:
                    return {s_INTERNALFORMAT_ALPHA_SIZE, 25};
#endif
#ifdef GL_INTERNALFORMAT_ALPHA_TYPE
                case GL_INTERNALFORMAT_ALPHA_TYPE:
                    return {s_INTERNALFORMAT_ALPHA_TYPE, 25};
#endif
#ifdef GL_INTERNALFORMAT_BLUE_SIZE
                case GL_INTERNALFORMAT_BLUE_SIZE:
                    return {s_INTERNALFORMAT_BLUE_SIZE, 24};
#endif
#ifdef GL_INTERNALFORMAT_BLUE_TYPE
                case GL_INTERNALFORMAT_BLUE_TYPE:
                    return {s_INTERNALFORMAT_BLUE_TYPE, 24};
#endif
#ifdef GL_INTERNALFORMAT_DEPTH_SIZE
                case GL_INTERNALFORMAT_DEPTH_SIZE:
                    return {s_INTERNALFORMAT_DEPTH_SIZE, 25};
#endif
#ifdef GL_INTERNALFORMAT_DEPTH_TYPE
                case GL_INTERNALFORMAT_DEPTH_TYPE:
                    return {s_INTERNALFORMAT_DEPTH_TYPE, 25};
#endif
#ifdef GL_INTERNALFORMAT_GREEN_SIZE
                case GL_INTERNALFORMAT_GREEN_SIZE:
                    return {s_INTERNALFORMAT_GREEN_SIZE, 25};
#endif
#ifdef GL_INTERNALFORMAT_GREEN_TYPE
                case GL_INTERNALFORMAT_GREEN_TYPE:
                    return {s_INTERNALFORMAT_GREEN_TYPE, 25};
#endif
#ifdef GL_INTERNALFORMAT_PREFERRED
                case GL_INTERNALFORMAT_PREFERRED:
                    return {s_INTERNALFORMAT_PREFERRED, 24};
#endif
#ifdef GL_INTERNALFORMAT_RED_SIZE
                case GL_INTERNALFORMAT_RED_SIZE:
                    return {s_INTERNALFORMAT_RED_SIZE, 23};
#endif
#ifdef GL_INTERNALFORMAT_RED_TYPE
                case GL_INTERNALFORMAT_RED_TYPE:
                    return {s_INTERNALFORMAT_RED_TYPE, 23};
#endif
#ifdef GL_INTERNALFORMAT_SHARED_SIZE
                case GL_INTERNALFORMAT_SHARED_SIZE:
                    return {s_INTERNALFORMAT_SHARED_SIZE, 26};
#endif
#ifdef GL_INTERNALFORMAT_STENCIL_SIZE
                case GL_INTERNALFORMAT_STENCIL_SIZE:
                    return {s_INTERNALFORMAT_STENCIL_SIZE, 27};
#endif
#ifdef GL_INTERNALFORMAT_STENCIL_TYPE
                case GL_INTERNALFORMAT_STENCIL_TYPE:
                    return {s_INTERNALFORMAT_STENCIL_TYPE, 27};
#endif
#ifdef GL_INTERNALFORMAT_SUPPORTED
                case GL_INTERNALFORMAT_SUPPORTED:
                    return {s_INTERNALFORMAT_SUPPORTED, 24};
#endif
#ifdef GL_MAX_COMBINED_DIMENSIONS
                case GL_MAX_COMBINED_DIMENSIONS:
                    return {s_MAX_COMBINED_DIMENSIONS, 23};
#endif
#ifdef GL_MAX_DEPTH
                case GL_MAX_DEPTH:
                    return {s_MAX_DEPTH, 9};
#endif
#ifdef GL_MAX_HEIGHT
                case GL_MAX_HEIGHT:
                    return {s_MAX_HEIGHT, 10};
#endif
#ifdef GL_MAX_LAYERS
                case GL_MAX_LAYERS:
                    return {s_MAX_LAYERS, 10};
#endif
#ifdef GL_MAX_WIDTH
                case GL_MAX_WIDTH:
                    return {s_MAX_WIDTH, 9};
#endif
#ifdef GL_MIPMAP
                case GL_MIPMAP:
                    return {s_MIPMAP, 6};
#endif
#ifdef GL_NUM_SAMPLE_COUNTS
                case GL_NUM_SAMPLE_COUNTS:
                    return {s_NUM_SAMPLE_COUNTS, 17};
#endif
#ifdef GL_READ_PIXELS
                case GL_READ_PIXELS:
                    return {s_READ_PIXELS, 11};
#endif
#ifdef GL_READ_PIXELS_FORMAT
                case GL_READ_PIXELS_FORMAT:
                    return {s_READ_PIXELS_FORMAT, 18};
#endif
#ifdef GL_READ_PIXELS_TYPE
                case GL_READ_PIXELS_TYPE:
                    return {s_READ_PIXELS_TYPE, 16};
#endif
#ifdef GL_SAMPLES
                case GL_SAMPLES:
                    return {s_SAMPLES, 7};
#endif
#ifdef GL_SHADER_IMAGE_ATOMIC
                case GL_SHADER_IMAGE_ATOMIC:
                    return {s_SHADER_IMAGE_ATOMIC, 19};
#endif
#ifdef GL_SHADER_IMAGE_LOAD
                case GL_SHADER_IMAGE_LOAD:
                    return {s_SHADER_IMAGE_LOAD, 17};
#endif
#ifdef GL_SHADER_IMAGE_STORE
                case GL_SHADER_IMAGE_STORE:
                    return {s_SHADER_IMAGE_STORE, 18};
#endif
#ifdef GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST
                case GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST:
                    return {s_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST, 35};
#endif
#ifdef GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE
                case GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE:
                    return {s_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE, 36};
#endif
#ifdef GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST
                case GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST:
                    return {s_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST, 37};
#endif
#ifdef GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE
                case GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE:
                    return {s_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE, 38};
#endif
#ifdef GL_SRGB_READ
                case GL_SRGB_READ:
                    return {s_SRGB_READ, 9};
#endif
#ifdef GL_SRGB_WRITE
                case GL_SRGB_WRITE:
                    return {s_SRGB_WRITE, 10};
#endif
#ifdef GL_STENCIL_COMPONENTS
                case GL_STENCIL_COMPONENTS:
                    return {s_STENCIL_COMPONENTS, 18};
#endif
#ifdef GL_STENCIL_RENDERABLE
                case GL_STENCIL_RENDERABLE:
                    return {s_STENCIL_RENDERABLE, 18};
#endif
#ifdef GL_TESS_CONTROL_TEXTURE
                case GL_TESS_CONTROL_TEXTURE:
                    return {s_TESS_CONTROL_TEXTURE, 20};
#endif
#ifdef GL_TESS_EVALUATION_TEXTURE
                case GL_TESS_EVALUATION_TEXTURE:
                    return {s_TESS_EVALUATION_TEXTURE, 23};
#endif
#ifdef GL_TEXTURE_COMPRESSED
                case GL_TEXTURE_COMPRESSED:
                    return {s_TEXTURE_COMPRESSED, 18};
#endif
#ifdef GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT
                case GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT:
                    return {s_TEXTURE_COMPRESSED_BLOCK_HEIGHT, 31};
#endif
#ifdef GL_TEXTURE_COMPRESSED_BLOCK_SIZE
                case GL_TEXTURE_COMPRESSED_BLOCK_SIZE:
                    return {s_TEXTURE_COMPRESSED_BLOCK_SIZE, 29};
#endif
#ifdef GL_TEXTURE_COMPRESSED_BLOCK_WIDTH
                case GL_TEXTURE_COMPRESSED_BLOCK_WIDTH:
                    return {s_TEXTURE_COMPRESSED_BLOCK_WIDTH, 30};
#endif
#ifdef GL_TEXTURE_GATHER
                case GL_TEXTURE_GATHER:
                    return {s_TEXTURE_GATHER, 14};
#endif
#ifdef GL_TEXTURE_GATHER_SHADOW
                case GL_TEXTURE_GATHER_SHADOW:
                    return {s_TEXTURE_GATHER_SHADOW, 21};
#endif
#ifdef GL_TEXTURE_IMAGE_FORMAT
                case GL_TEXTURE_IMAGE_FORMAT:
                    return {s_TEXTURE_IMAGE_FORMAT, 20};
#endif
#ifdef GL_TEXTURE_IMAGE_TYPE
                case GL_TEXTURE_IMAGE_TYPE:
                    return {s_TEXTURE_IMAGE_TYPE, 18};
#endif
#ifdef GL_TEXTURE_SHADOW
                case GL_TEXTURE_SHADOW:
                    return {s_TEXTURE_SHADOW, 14};
#endif
#ifdef GL_TEXTURE_VIEW
                case GL_TEXTURE_VIEW:
                    return {s_TEXTURE_VIEW, 12};
#endif
#ifdef GL_VERTEX_TEXTURE
                case GL_VERTEX_TEXTURE:
                    return {s_VERTEX_TEXTURE, 14};
#endif
#ifdef GL_VIEW_COMPATIBILITY_CLASS
                case GL_VIEW_COMPATIBILITY_CLASS:
                    return {s_VIEW_COMPATIBILITY_CLASS, 24};
#endif
                default:;
            }
            break;
        case 46: /* internal_format_target */
            switch(GLenum(aev._value)) {
#ifdef GL_RENDERBUFFER
                case GL_RENDERBUFFER:
                    return {s_RENDERBUFFER, 12};
#endif
#ifdef GL_TEXTURE_1D
                case GL_TEXTURE_1D:
                    return {s_TEXTURE_1D, 10};
#endif
#ifdef GL_TEXTURE_1D_ARRAY
                case GL_TEXTURE_1D_ARRAY:
                    return {s_TEXTURE_1D_ARRAY, 16};
#endif
#ifdef GL_TEXTURE_2D
                case GL_TEXTURE_2D:
                    return {s_TEXTURE_2D, 10};
#endif
#ifdef GL_TEXTURE_2D_ARRAY
                case GL_TEXTURE_2D_ARRAY:
                    return {s_TEXTURE_2D_ARRAY, 16};
#endif
#ifdef GL_TEXTURE_2D_MULTISAMPLE
                case GL_TEXTURE_2D_MULTISAMPLE:
                    return {s_TEXTURE_2D_MULTISAMPLE, 22};
#endif
#ifdef GL_TEXTURE_2D_MULTISAMPLE_ARRAY
                case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
                    return {s_TEXTURE_2D_MULTISAMPLE_ARRAY, 28};
#endif
#ifdef GL_TEXTURE_3D
                case GL_TEXTURE_3D:
                    return {s_TEXTURE_3D, 10};
#endif
#ifdef GL_TEXTURE_BUFFER
                case GL_TEXTURE_BUFFER:
                    return {s_TEXTURE_BUFFER, 14};
#endif
#ifdef GL_TEXTURE_CUBE_MAP
                case GL_TEXTURE_CUBE_MAP:
                    return {s_TEXTURE_CUBE_MAP, 16};
#endif
#ifdef GL_TEXTURE_CUBE_MAP_ARRAY
                case GL_TEXTURE_CUBE_MAP_ARRAY:
                    return {s_TEXTURE_CUBE_MAP_ARRAY, 22};
#endif
#ifdef GL_TEXTURE_RECTANGLE
                case GL_TEXTURE_RECTANGLE:
                    return {s_TEXTURE_RECTANGLE, 17};
#endif
                default:;
            }
            break;
        case 47: /* limit_query */
            switch(GLenum(aev._value)) {
#ifdef GL_MAX_3D_TEXTURE_SIZE
                case GL_MAX_3D_TEXTURE_SIZE:
                    return {s_MAX_3D_TEXTURE_SIZE, 19};
#endif
#ifdef GL_MAX_ARRAY_TEXTURE_LAYERS
                case GL_MAX_ARRAY_TEXTURE_LAYERS:
                    return {s_MAX_ARRAY_TEXTURE_LAYERS, 24};
#endif
#ifdef GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS
                case GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS:
                    return {s_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS, 34};
#endif
#ifdef GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE
                case GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE:
                    return {s_MAX_ATOMIC_COUNTER_BUFFER_SIZE, 30};
#endif
#ifdef GL_MAX_CLIP_DISTANCES
                case GL_MAX_CLIP_DISTANCES:
                    return {s_MAX_CLIP_DISTANCES, 18};
#endif
#ifdef GL_MAX_COLOR_ATTACHMENTS
                case GL_MAX_COLOR_ATTACHMENTS:
                    return {s_MAX_COLOR_ATTACHMENTS, 21};
#endif
#ifdef GL_MAX_COLOR_TEXTURE_SAMPLES
                case GL_MAX_COLOR_TEXTURE_SAMPLES:
                    return {s_MAX_COLOR_TEXTURE_SAMPLES, 25};
#endif
#ifdef GL_MAX_COMBINED_ATOMIC_COUNTERS
                case GL_MAX_COMBINED_ATOMIC_COUNTERS:
                    return {s_MAX_COMBINED_ATOMIC_COUNTERS, 28};
#endif
#ifdef GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS
                case GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS:
                    return {s_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS, 35};
#endif
#ifdef GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES
                case GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES:
                    return {s_MAX_COMBINED_CLIP_AND_CULL_DISTANCES, 36};
#endif
#ifdef GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS
                case GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:
                    return {s_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS, 40};
#endif
#ifdef GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS
                case GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS:
                    return {s_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS, 40};
#endif
#ifdef GL_MAX_COMBINED_IMAGE_UNIFORMS
                case GL_MAX_COMBINED_IMAGE_UNIFORMS:
                    return {s_MAX_COMBINED_IMAGE_UNIFORMS, 27};
#endif
#ifdef GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS
                case GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS:
                    return {
                      s_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS, 45};
#endif
#ifdef GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS
                case GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS:
                    return {s_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS, 44};
#endif
#ifdef GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS
                case GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS:
                    return {
                      s_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS, 47};
#endif
#ifdef GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
                case GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS:
                    return {s_MAX_COMBINED_TEXTURE_IMAGE_UNITS, 32};
#endif
#ifdef GL_MAX_COMBINED_UNIFORM_BLOCKS
                case GL_MAX_COMBINED_UNIFORM_BLOCKS:
                    return {s_MAX_COMBINED_UNIFORM_BLOCKS, 27};
#endif
#ifdef GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS
                case GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:
                    return {s_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS, 38};
#endif
#ifdef GL_MAX_COMPUTE_SHARED_MEMORY_SIZE
                case GL_MAX_COMPUTE_SHARED_MEMORY_SIZE:
                    return {s_MAX_COMPUTE_SHARED_MEMORY_SIZE, 30};
#endif
#ifdef GL_MAX_COMPUTE_WORK_GROUP_COUNT
                case GL_MAX_COMPUTE_WORK_GROUP_COUNT:
                    return {s_MAX_COMPUTE_WORK_GROUP_COUNT, 28};
#endif
#ifdef GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS
                case GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS:
                    return {s_MAX_COMPUTE_WORK_GROUP_INVOCATIONS, 34};
#endif
#ifdef GL_MAX_COMPUTE_WORK_GROUP_SIZE
                case GL_MAX_COMPUTE_WORK_GROUP_SIZE:
                    return {s_MAX_COMPUTE_WORK_GROUP_SIZE, 27};
#endif
#ifdef GL_MAX_CUBE_MAP_TEXTURE_SIZE
                case GL_MAX_CUBE_MAP_TEXTURE_SIZE:
                    return {s_MAX_CUBE_MAP_TEXTURE_SIZE, 25};
#endif
#ifdef GL_MAX_CULL_DISTANCES
                case GL_MAX_CULL_DISTANCES:
                    return {s_MAX_CULL_DISTANCES, 18};
#endif
#ifdef GL_MAX_DEPTH_TEXTURE_SAMPLES
                case GL_MAX_DEPTH_TEXTURE_SAMPLES:
                    return {s_MAX_DEPTH_TEXTURE_SAMPLES, 25};
#endif
#ifdef GL_MAX_DRAW_BUFFERS
                case GL_MAX_DRAW_BUFFERS:
                    return {s_MAX_DRAW_BUFFERS, 16};
#endif
#ifdef GL_MAX_DUAL_SOURCE_DRAW_BUFFERS
                case GL_MAX_DUAL_SOURCE_DRAW_BUFFERS:
                    return {s_MAX_DUAL_SOURCE_DRAW_BUFFERS, 28};
#endif
#ifdef GL_MAX_ELEMENTS_INDICES
                case GL_MAX_ELEMENTS_INDICES:
                    return {s_MAX_ELEMENTS_INDICES, 20};
#endif
#ifdef GL_MAX_ELEMENTS_VERTICES
                case GL_MAX_ELEMENTS_VERTICES:
                    return {s_MAX_ELEMENTS_VERTICES, 21};
#endif
#ifdef GL_MAX_FRAGMENT_ATOMIC_COUNTERS
                case GL_MAX_FRAGMENT_ATOMIC_COUNTERS:
                    return {s_MAX_FRAGMENT_ATOMIC_COUNTERS, 28};
#endif
#ifdef GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS
                case GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS:
                    return {s_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS, 35};
#endif
#ifdef GL_MAX_FRAGMENT_IMAGE_UNIFORMS
                case GL_MAX_FRAGMENT_IMAGE_UNIFORMS:
                    return {s_MAX_FRAGMENT_IMAGE_UNIFORMS, 27};
#endif
#ifdef GL_MAX_FRAGMENT_INPUT_COMPONENTS
                case GL_MAX_FRAGMENT_INPUT_COMPONENTS:
                    return {s_MAX_FRAGMENT_INPUT_COMPONENTS, 29};
#endif
#ifdef GL_MAX_FRAGMENT_INTERPOLATION_OFFSET
                case GL_MAX_FRAGMENT_INTERPOLATION_OFFSET:
                    return {s_MAX_FRAGMENT_INTERPOLATION_OFFSET, 33};
#endif
#ifdef GL_MAX_FRAGMENT_UNIFORM_BLOCKS
                case GL_MAX_FRAGMENT_UNIFORM_BLOCKS:
                    return {s_MAX_FRAGMENT_UNIFORM_BLOCKS, 27};
#endif
#ifdef GL_MAX_FRAGMENT_UNIFORM_COMPONENTS
                case GL_MAX_FRAGMENT_UNIFORM_COMPONENTS:
                    return {s_MAX_FRAGMENT_UNIFORM_COMPONENTS, 31};
#endif
#ifdef GL_MAX_FRAGMENT_UNIFORM_VECTORS
                case GL_MAX_FRAGMENT_UNIFORM_VECTORS:
                    return {s_MAX_FRAGMENT_UNIFORM_VECTORS, 28};
#endif
#ifdef GL_MAX_GEOMETRY_ATOMIC_COUNTERS
                case GL_MAX_GEOMETRY_ATOMIC_COUNTERS:
                    return {s_MAX_GEOMETRY_ATOMIC_COUNTERS, 28};
#endif
#ifdef GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS
                case GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS:
                    return {s_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS, 35};
#endif
#ifdef GL_MAX_GEOMETRY_IMAGE_UNIFORMS
                case GL_MAX_GEOMETRY_IMAGE_UNIFORMS:
                    return {s_MAX_GEOMETRY_IMAGE_UNIFORMS, 27};
#endif
#ifdef GL_MAX_GEOMETRY_INPUT_COMPONENTS
                case GL_MAX_GEOMETRY_INPUT_COMPONENTS:
                    return {s_MAX_GEOMETRY_INPUT_COMPONENTS, 29};
#endif
#ifdef GL_MAX_GEOMETRY_OUTPUT_COMPONENTS
                case GL_MAX_GEOMETRY_OUTPUT_COMPONENTS:
                    return {s_MAX_GEOMETRY_OUTPUT_COMPONENTS, 30};
#endif
#ifdef GL_MAX_GEOMETRY_OUTPUT_VERTICES
                case GL_MAX_GEOMETRY_OUTPUT_VERTICES:
                    return {s_MAX_GEOMETRY_OUTPUT_VERTICES, 28};
#endif
#ifdef GL_MAX_GEOMETRY_SHADER_INVOCATIONS
                case GL_MAX_GEOMETRY_SHADER_INVOCATIONS:
                    return {s_MAX_GEOMETRY_SHADER_INVOCATIONS, 31};
#endif
#ifdef GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS
                case GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS:
                    return {s_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS, 32};
#endif
#ifdef GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS
                case GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS:
                    return {s_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS, 36};
#endif
#ifdef GL_MAX_GEOMETRY_UNIFORM_BLOCKS
                case GL_MAX_GEOMETRY_UNIFORM_BLOCKS:
                    return {s_MAX_GEOMETRY_UNIFORM_BLOCKS, 27};
#endif
#ifdef GL_MAX_GEOMETRY_UNIFORM_COMPONENTS
                case GL_MAX_GEOMETRY_UNIFORM_COMPONENTS:
                    return {s_MAX_GEOMETRY_UNIFORM_COMPONENTS, 31};
#endif
#ifdef GL_MAX_IMAGE_SAMPLES
                case GL_MAX_IMAGE_SAMPLES:
                    return {s_MAX_IMAGE_SAMPLES, 17};
#endif
#ifdef GL_MAX_IMAGE_UNITS
                case GL_MAX_IMAGE_UNITS:
                    return {s_MAX_IMAGE_UNITS, 15};
#endif
#ifdef GL_MAX_INTEGER_SAMPLES
                case GL_MAX_INTEGER_SAMPLES:
                    return {s_MAX_INTEGER_SAMPLES, 19};
#endif
#ifdef GL_MAX_PATCH_VERTICES
                case GL_MAX_PATCH_VERTICES:
                    return {s_MAX_PATCH_VERTICES, 18};
#endif
#ifdef GL_MAX_PROGRAM_TEXEL_OFFSET
                case GL_MAX_PROGRAM_TEXEL_OFFSET:
                    return {s_MAX_PROGRAM_TEXEL_OFFSET, 24};
#endif
#ifdef GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET
                case GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET:
                    return {s_MAX_PROGRAM_TEXTURE_GATHER_OFFSET, 33};
#endif
#ifdef GL_MAX_RECTANGLE_TEXTURE_SIZE
                case GL_MAX_RECTANGLE_TEXTURE_SIZE:
                    return {s_MAX_RECTANGLE_TEXTURE_SIZE, 26};
#endif
#ifdef GL_MAX_RENDERBUFFER_SIZE
                case GL_MAX_RENDERBUFFER_SIZE:
                    return {s_MAX_RENDERBUFFER_SIZE, 21};
#endif
#ifdef GL_MAX_SAMPLES
                case GL_MAX_SAMPLES:
                    return {s_MAX_SAMPLES, 11};
#endif
#ifdef GL_MAX_SAMPLE_MASK_WORDS
                case GL_MAX_SAMPLE_MASK_WORDS:
                    return {s_MAX_SAMPLE_MASK_WORDS, 21};
#endif
#ifdef GL_MAX_SERVER_WAIT_TIMEOUT
                case GL_MAX_SERVER_WAIT_TIMEOUT:
                    return {s_MAX_SERVER_WAIT_TIMEOUT, 23};
#endif
#ifdef GL_MAX_SUBROUTINES
                case GL_MAX_SUBROUTINES:
                    return {s_MAX_SUBROUTINES, 15};
#endif
#ifdef GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS
                case GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS:
                    return {s_MAX_SUBROUTINE_UNIFORM_LOCATIONS, 32};
#endif
#ifdef GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS
                case GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS:
                    return {s_MAX_TESS_CONTROL_ATOMIC_COUNTERS, 32};
#endif
#ifdef GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS
                case GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS:
                    return {s_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS, 39};
#endif
#ifdef GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS
                case GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS:
                    return {s_MAX_TESS_CONTROL_IMAGE_UNIFORMS, 31};
#endif
#ifdef GL_MAX_TESS_CONTROL_INPUT_COMPONENTS
                case GL_MAX_TESS_CONTROL_INPUT_COMPONENTS:
                    return {s_MAX_TESS_CONTROL_INPUT_COMPONENTS, 33};
#endif
#ifdef GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS
                case GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS:
                    return {s_MAX_TESS_CONTROL_OUTPUT_COMPONENTS, 34};
#endif
#ifdef GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS
                case GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS:
                    return {s_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS, 36};
#endif
#ifdef GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS
                case GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS:
                    return {s_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS, 40};
#endif
#ifdef GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS
                case GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS:
                    return {s_MAX_TESS_CONTROL_UNIFORM_BLOCKS, 31};
#endif
#ifdef GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS
                case GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS:
                    return {s_MAX_TESS_CONTROL_UNIFORM_COMPONENTS, 35};
#endif
#ifdef GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS
                case GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS:
                    return {s_MAX_TESS_EVALUATION_ATOMIC_COUNTERS, 35};
#endif
#ifdef GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS
                case GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS:
                    return {s_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS, 42};
#endif
#ifdef GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS
                case GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS:
                    return {s_MAX_TESS_EVALUATION_IMAGE_UNIFORMS, 34};
#endif
#ifdef GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS
                case GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS:
                    return {s_MAX_TESS_EVALUATION_INPUT_COMPONENTS, 36};
#endif
#ifdef GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS
                case GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS:
                    return {s_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS, 37};
#endif
#ifdef GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS
                case GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS:
                    return {s_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS, 39};
#endif
#ifdef GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS
                case GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS:
                    return {s_MAX_TESS_EVALUATION_UNIFORM_BLOCKS, 34};
#endif
#ifdef GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS
                case GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS:
                    return {s_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS, 38};
#endif
#ifdef GL_MAX_TESS_GEN_LEVEL
                case GL_MAX_TESS_GEN_LEVEL:
                    return {s_MAX_TESS_GEN_LEVEL, 18};
#endif
#ifdef GL_MAX_TESS_PATCH_COMPONENTS
                case GL_MAX_TESS_PATCH_COMPONENTS:
                    return {s_MAX_TESS_PATCH_COMPONENTS, 25};
#endif
#ifdef GL_MAX_TEXTURE_BUFFER_SIZE
                case GL_MAX_TEXTURE_BUFFER_SIZE:
                    return {s_MAX_TEXTURE_BUFFER_SIZE, 23};
#endif
#ifdef GL_MAX_TEXTURE_IMAGE_UNITS
                case GL_MAX_TEXTURE_IMAGE_UNITS:
                    return {s_MAX_TEXTURE_IMAGE_UNITS, 23};
#endif
#ifdef GL_MAX_TEXTURE_LOD_BIAS
                case GL_MAX_TEXTURE_LOD_BIAS:
                    return {s_MAX_TEXTURE_LOD_BIAS, 20};
#endif
#ifdef GL_MAX_TEXTURE_SIZE
                case GL_MAX_TEXTURE_SIZE:
                    return {s_MAX_TEXTURE_SIZE, 16};
#endif
#ifdef GL_MAX_TRANSFORM_FEEDBACK_BUFFERS
                case GL_MAX_TRANSFORM_FEEDBACK_BUFFERS:
                    return {s_MAX_TRANSFORM_FEEDBACK_BUFFERS, 30};
#endif
#ifdef GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS
                case GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS:
                    return {
                      s_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS, 45};
#endif
#ifdef GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS
                case GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS:
                    return {s_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS, 39};
#endif
#ifdef GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
                case GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS:
                    return {s_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS, 42};
#endif
#ifdef GL_MAX_UNIFORM_BLOCK_SIZE
                case GL_MAX_UNIFORM_BLOCK_SIZE:
                    return {s_MAX_UNIFORM_BLOCK_SIZE, 22};
#endif
#ifdef GL_MAX_UNIFORM_BUFFER_BINDINGS
                case GL_MAX_UNIFORM_BUFFER_BINDINGS:
                    return {s_MAX_UNIFORM_BUFFER_BINDINGS, 27};
#endif
#ifdef GL_MAX_VARYING_COMPONENTS
                case GL_MAX_VARYING_COMPONENTS:
                    return {s_MAX_VARYING_COMPONENTS, 22};
#endif
#ifdef GL_MAX_VARYING_VECTORS
                case GL_MAX_VARYING_VECTORS:
                    return {s_MAX_VARYING_VECTORS, 19};
#endif
#ifdef GL_MAX_VERTEX_ATOMIC_COUNTERS
                case GL_MAX_VERTEX_ATOMIC_COUNTERS:
                    return {s_MAX_VERTEX_ATOMIC_COUNTERS, 26};
#endif
#ifdef GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS
                case GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS:
                    return {s_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS, 33};
#endif
#ifdef GL_MAX_VERTEX_ATTRIBS
                case GL_MAX_VERTEX_ATTRIBS:
                    return {s_MAX_VERTEX_ATTRIBS, 18};
#endif
#ifdef GL_MAX_VERTEX_IMAGE_UNIFORMS
                case GL_MAX_VERTEX_IMAGE_UNIFORMS:
                    return {s_MAX_VERTEX_IMAGE_UNIFORMS, 25};
#endif
#ifdef GL_MAX_VERTEX_OUTPUT_COMPONENTS
                case GL_MAX_VERTEX_OUTPUT_COMPONENTS:
                    return {s_MAX_VERTEX_OUTPUT_COMPONENTS, 28};
#endif
#ifdef GL_MAX_VERTEX_STREAMS
                case GL_MAX_VERTEX_STREAMS:
                    return {s_MAX_VERTEX_STREAMS, 18};
#endif
#ifdef GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
                case GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS:
                    return {s_MAX_VERTEX_TEXTURE_IMAGE_UNITS, 30};
#endif
#ifdef GL_MAX_VERTEX_UNIFORM_BLOCKS
                case GL_MAX_VERTEX_UNIFORM_BLOCKS:
                    return {s_MAX_VERTEX_UNIFORM_BLOCKS, 25};
#endif
#ifdef GL_MAX_VERTEX_UNIFORM_COMPONENTS
                case GL_MAX_VERTEX_UNIFORM_COMPONENTS:
                    return {s_MAX_VERTEX_UNIFORM_COMPONENTS, 29};
#endif
#ifdef GL_MAX_VERTEX_UNIFORM_VECTORS
                case GL_MAX_VERTEX_UNIFORM_VECTORS:
                    return {s_MAX_VERTEX_UNIFORM_VECTORS, 26};
#endif
#ifdef GL_MAX_VIEWPORTS
                case GL_MAX_VIEWPORTS:
                    return {s_MAX_VIEWPORTS, 13};
#endif
#ifdef GL_MAX_VIEWPORT_DIMS
                case GL_MAX_VIEWPORT_DIMS:
                    return {s_MAX_VIEWPORT_DIMS, 17};
#endif
#ifdef GL_MIN_FRAGMENT_INTERPOLATION_OFFSET
                case GL_MIN_FRAGMENT_INTERPOLATION_OFFSET:
                    return {s_MIN_FRAGMENT_INTERPOLATION_OFFSET, 33};
#endif
#ifdef GL_MIN_MAP_BUFFER_ALIGNMENT
                case GL_MIN_MAP_BUFFER_ALIGNMENT:
                    return {s_MIN_MAP_BUFFER_ALIGNMENT, 24};
#endif
#ifdef GL_MIN_PROGRAM_TEXEL_OFFSET
                case GL_MIN_PROGRAM_TEXEL_OFFSET:
                    return {s_MIN_PROGRAM_TEXEL_OFFSET, 24};
#endif
#ifdef GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET
                case GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET:
                    return {s_MIN_PROGRAM_TEXTURE_GATHER_OFFSET, 33};
#endif
                default:;
            }
            break;
        case 48: /* memory_barrier_bits */
            switch(GLbitfield(aev._value)) {
#ifdef GL_ALL_BARRIER_BITS
                case GL_ALL_BARRIER_BITS:
                    return {s_ALL_BARRIER_BITS, 16};
#endif
#ifdef GL_ATOMIC_COUNTER_BARRIER_BIT
                case GL_ATOMIC_COUNTER_BARRIER_BIT:
                    return {s_ATOMIC_COUNTER_BARRIER_BIT, 26};
#endif
#ifdef GL_BUFFER_UPDATE_BARRIER_BIT
                case GL_BUFFER_UPDATE_BARRIER_BIT:
                    return {s_BUFFER_UPDATE_BARRIER_BIT, 25};
#endif
#ifdef GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT
                case GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT:
                    return {s_CLIENT_MAPPED_BUFFER_BARRIER_BIT, 32};
#endif
#ifdef GL_COMMAND_BARRIER_BIT
                case GL_COMMAND_BARRIER_BIT:
                    return {s_COMMAND_BARRIER_BIT, 19};
#endif
#ifdef GL_ELEMENT_ARRAY_BARRIER_BIT
                case GL_ELEMENT_ARRAY_BARRIER_BIT:
                    return {s_ELEMENT_ARRAY_BARRIER_BIT, 25};
#endif
#ifdef GL_FRAMEBUFFER_BARRIER_BIT
                case GL_FRAMEBUFFER_BARRIER_BIT:
                    return {s_FRAMEBUFFER_BARRIER_BIT, 23};
#endif
#ifdef GL_PIXEL_BUFFER_BARRIER_BIT
                case GL_PIXEL_BUFFER_BARRIER_BIT:
                    return {s_PIXEL_BUFFER_BARRIER_BIT, 24};
#endif
#ifdef GL_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV
                case GL_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV:
                    return {s_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV, 35};
#endif
#ifdef GL_SHADER_IMAGE_ACCESS_BARRIER_BIT
                case GL_SHADER_IMAGE_ACCESS_BARRIER_BIT:
                    return {s_SHADER_IMAGE_ACCESS_BARRIER_BIT, 31};
#endif
#ifdef GL_SHADER_STORAGE_BARRIER_BIT
                case GL_SHADER_STORAGE_BARRIER_BIT:
                    return {s_SHADER_STORAGE_BARRIER_BIT, 26};
#endif
#ifdef GL_TEXTURE_FETCH_BARRIER_BIT
                case GL_TEXTURE_FETCH_BARRIER_BIT:
                    return {s_TEXTURE_FETCH_BARRIER_BIT, 25};
#endif
#ifdef GL_TEXTURE_UPDATE_BARRIER_BIT
                case GL_TEXTURE_UPDATE_BARRIER_BIT:
                    return {s_TEXTURE_UPDATE_BARRIER_BIT, 26};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BARRIER_BIT
                case GL_TRANSFORM_FEEDBACK_BARRIER_BIT:
                    return {s_TRANSFORM_FEEDBACK_BARRIER_BIT, 30};
#endif
#ifdef GL_UNIFORM_BARRIER_BIT
                case GL_UNIFORM_BARRIER_BIT:
                    return {s_UNIFORM_BARRIER_BIT, 19};
#endif
#ifdef GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT
                case GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT:
                    return {s_VERTEX_ATTRIB_ARRAY_BARRIER_BIT, 31};
#endif
                default:;
            }
            break;
        case 49: /* named_string_param */
            switch(GLenum(aev._value)) {
#ifdef GL_NAMED_STRING_LENGTH_ARB
                case GL_NAMED_STRING_LENGTH_ARB:
                    return {s_NAMED_STRING_LENGTH_ARB, 23};
#endif
#ifdef GL_NAMED_STRING_TYPE_ARB
                case GL_NAMED_STRING_TYPE_ARB:
                    return {s_NAMED_STRING_TYPE_ARB, 21};
#endif
                default:;
            }
            break;
        case 50: /* named_string_type */
            switch(GLenum(aev._value)) {
#ifdef GL_SHADER_INCLUDE_ARB
                case GL_SHADER_INCLUDE_ARB:
                    return {s_SHADER_INCLUDE_ARB, 18};
#endif
                default:;
            }
            break;
        case 51: /* numeric_query */
            switch(GLenum(aev._value)) {
#ifdef GL_ALIASED_LINE_WIDTH_RANGE
                case GL_ALIASED_LINE_WIDTH_RANGE:
                    return {s_ALIASED_LINE_WIDTH_RANGE, 24};
#endif
#ifdef GL_BLEND_COLOR
                case GL_BLEND_COLOR:
                    return {s_BLEND_COLOR, 11};
#endif
#ifdef GL_BLEND_DST_ALPHA
                case GL_BLEND_DST_ALPHA:
                    return {s_BLEND_DST_ALPHA, 15};
#endif
#ifdef GL_BLEND_DST_RGB
                case GL_BLEND_DST_RGB:
                    return {s_BLEND_DST_RGB, 13};
#endif
#ifdef GL_BLEND_EQUATION_ALPHA
                case GL_BLEND_EQUATION_ALPHA:
                    return {s_BLEND_EQUATION_ALPHA, 20};
#endif
#ifdef GL_BLEND_EQUATION_RGB
                case GL_BLEND_EQUATION_RGB:
                    return {s_BLEND_EQUATION_RGB, 18};
#endif
#ifdef GL_BLEND_SRC_ALPHA
                case GL_BLEND_SRC_ALPHA:
                    return {s_BLEND_SRC_ALPHA, 15};
#endif
#ifdef GL_BLEND_SRC_RGB
                case GL_BLEND_SRC_RGB:
                    return {s_BLEND_SRC_RGB, 13};
#endif
#ifdef GL_COLOR_CLEAR_VALUE
                case GL_COLOR_CLEAR_VALUE:
                    return {s_COLOR_CLEAR_VALUE, 17};
#endif
#ifdef GL_COLOR_WRITEMASK
                case GL_COLOR_WRITEMASK:
                    return {s_COLOR_WRITEMASK, 15};
#endif
#ifdef GL_COMPRESSED_TEXTURE_FORMATS
                case GL_COMPRESSED_TEXTURE_FORMATS:
                    return {s_COMPRESSED_TEXTURE_FORMATS, 26};
#endif
#ifdef GL_CONTEXT_FLAGS
                case GL_CONTEXT_FLAGS:
                    return {s_CONTEXT_FLAGS, 13};
#endif
#ifdef GL_DEBUG_GROUP_STACK_DEPTH
                case GL_DEBUG_GROUP_STACK_DEPTH:
                    return {s_DEBUG_GROUP_STACK_DEPTH, 23};
#endif
#ifdef GL_DEPTH_CLEAR_VALUE
                case GL_DEPTH_CLEAR_VALUE:
                    return {s_DEPTH_CLEAR_VALUE, 17};
#endif
#ifdef GL_DEPTH_FUNC
                case GL_DEPTH_FUNC:
                    return {s_DEPTH_FUNC, 10};
#endif
#ifdef GL_DEPTH_RANGE
                case GL_DEPTH_RANGE:
                    return {s_DEPTH_RANGE, 11};
#endif
#ifdef GL_DEPTH_WRITEMASK
                case GL_DEPTH_WRITEMASK:
                    return {s_DEPTH_WRITEMASK, 15};
#endif
#ifdef GL_DOUBLEBUFFER
                case GL_DOUBLEBUFFER:
                    return {s_DOUBLEBUFFER, 12};
#endif
#ifdef GL_DRAW_BUFFER
                case GL_DRAW_BUFFER:
                    return {s_DRAW_BUFFER, 11};
#endif
#ifdef GL_FRAGMENT_SHADER_DERIVATIVE_HINT
                case GL_FRAGMENT_SHADER_DERIVATIVE_HINT:
                    return {s_FRAGMENT_SHADER_DERIVATIVE_HINT, 31};
#endif
#ifdef GL_IMPLEMENTATION_COLOR_READ_FORMAT
                case GL_IMPLEMENTATION_COLOR_READ_FORMAT:
                    return {s_IMPLEMENTATION_COLOR_READ_FORMAT, 32};
#endif
#ifdef GL_IMPLEMENTATION_COLOR_READ_TYPE
                case GL_IMPLEMENTATION_COLOR_READ_TYPE:
                    return {s_IMPLEMENTATION_COLOR_READ_TYPE, 30};
#endif
#ifdef GL_LAYER_PROVOKING_VERTEX
                case GL_LAYER_PROVOKING_VERTEX:
                    return {s_LAYER_PROVOKING_VERTEX, 22};
#endif
#ifdef GL_LINE_SMOOTH_HINT
                case GL_LINE_SMOOTH_HINT:
                    return {s_LINE_SMOOTH_HINT, 16};
#endif
#ifdef GL_LINE_WIDTH
                case GL_LINE_WIDTH:
                    return {s_LINE_WIDTH, 10};
#endif
#ifdef GL_LOGIC_OP_MODE
                case GL_LOGIC_OP_MODE:
                    return {s_LOGIC_OP_MODE, 13};
#endif
#ifdef GL_NUM_COMPRESSED_TEXTURE_FORMATS
                case GL_NUM_COMPRESSED_TEXTURE_FORMATS:
                    return {s_NUM_COMPRESSED_TEXTURE_FORMATS, 30};
#endif
#ifdef GL_NUM_EXTENSIONS
                case GL_NUM_EXTENSIONS:
                    return {s_NUM_EXTENSIONS, 14};
#endif
#ifdef GL_NUM_PROGRAM_BINARY_FORMATS
                case GL_NUM_PROGRAM_BINARY_FORMATS:
                    return {s_NUM_PROGRAM_BINARY_FORMATS, 26};
#endif
#ifdef GL_NUM_SHADER_BINARY_FORMATS
                case GL_NUM_SHADER_BINARY_FORMATS:
                    return {s_NUM_SHADER_BINARY_FORMATS, 25};
#endif
#ifdef GL_PACK_ALIGNMENT
                case GL_PACK_ALIGNMENT:
                    return {s_PACK_ALIGNMENT, 14};
#endif
#ifdef GL_PACK_IMAGE_HEIGHT
                case GL_PACK_IMAGE_HEIGHT:
                    return {s_PACK_IMAGE_HEIGHT, 17};
#endif
#ifdef GL_PACK_LSB_FIRST
                case GL_PACK_LSB_FIRST:
                    return {s_PACK_LSB_FIRST, 14};
#endif
#ifdef GL_PACK_ROW_LENGTH
                case GL_PACK_ROW_LENGTH:
                    return {s_PACK_ROW_LENGTH, 15};
#endif
#ifdef GL_PACK_SKIP_IMAGES
                case GL_PACK_SKIP_IMAGES:
                    return {s_PACK_SKIP_IMAGES, 16};
#endif
#ifdef GL_PACK_SKIP_PIXELS
                case GL_PACK_SKIP_PIXELS:
                    return {s_PACK_SKIP_PIXELS, 16};
#endif
#ifdef GL_PACK_SKIP_ROWS
                case GL_PACK_SKIP_ROWS:
                    return {s_PACK_SKIP_ROWS, 14};
#endif
#ifdef GL_PACK_SWAP_BYTES
                case GL_PACK_SWAP_BYTES:
                    return {s_PACK_SWAP_BYTES, 15};
#endif
#ifdef GL_POINT_FADE_THRESHOLD_SIZE
                case GL_POINT_FADE_THRESHOLD_SIZE:
                    return {s_POINT_FADE_THRESHOLD_SIZE, 25};
#endif
#ifdef GL_POINT_SIZE
                case GL_POINT_SIZE:
                    return {s_POINT_SIZE, 10};
#endif
#ifdef GL_POINT_SIZE_GRANULARITY
                case GL_POINT_SIZE_GRANULARITY:
                    return {s_POINT_SIZE_GRANULARITY, 22};
#endif
#ifdef GL_POINT_SIZE_RANGE
                case GL_POINT_SIZE_RANGE:
                    return {s_POINT_SIZE_RANGE, 16};
#endif
#ifdef GL_POLYGON_OFFSET_FACTOR
                case GL_POLYGON_OFFSET_FACTOR:
                    return {s_POLYGON_OFFSET_FACTOR, 21};
#endif
#ifdef GL_POLYGON_OFFSET_UNITS
                case GL_POLYGON_OFFSET_UNITS:
                    return {s_POLYGON_OFFSET_UNITS, 20};
#endif
#ifdef GL_POLYGON_SMOOTH_HINT
                case GL_POLYGON_SMOOTH_HINT:
                    return {s_POLYGON_SMOOTH_HINT, 19};
#endif
#ifdef GL_PRIMITIVE_RESTART_INDEX
                case GL_PRIMITIVE_RESTART_INDEX:
                    return {s_PRIMITIVE_RESTART_INDEX, 23};
#endif
#ifdef GL_PROGRAM_BINARY_FORMATS
                case GL_PROGRAM_BINARY_FORMATS:
                    return {s_PROGRAM_BINARY_FORMATS, 22};
#endif
#ifdef GL_PROGRAM_POINT_SIZE
                case GL_PROGRAM_POINT_SIZE:
                    return {s_PROGRAM_POINT_SIZE, 18};
#endif
#ifdef GL_PROVOKING_VERTEX
                case GL_PROVOKING_VERTEX:
                    return {s_PROVOKING_VERTEX, 16};
#endif
#ifdef GL_READ_BUFFER
                case GL_READ_BUFFER:
                    return {s_READ_BUFFER, 11};
#endif
#ifdef GL_SAMPLES
                case GL_SAMPLES:
                    return {s_SAMPLES, 7};
#endif
#ifdef GL_SAMPLE_BUFFERS
                case GL_SAMPLE_BUFFERS:
                    return {s_SAMPLE_BUFFERS, 14};
#endif
#ifdef GL_SAMPLE_COVERAGE_INVERT
                case GL_SAMPLE_COVERAGE_INVERT:
                    return {s_SAMPLE_COVERAGE_INVERT, 22};
#endif
#ifdef GL_SAMPLE_COVERAGE_VALUE
                case GL_SAMPLE_COVERAGE_VALUE:
                    return {s_SAMPLE_COVERAGE_VALUE, 21};
#endif
#ifdef GL_SCISSOR_BOX
                case GL_SCISSOR_BOX:
                    return {s_SCISSOR_BOX, 11};
#endif
#ifdef GL_SHADER_COMPILER
                case GL_SHADER_COMPILER:
                    return {s_SHADER_COMPILER, 15};
#endif
#ifdef GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT
                case GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT:
                    return {s_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT, 38};
#endif
#ifdef GL_SHADER_STORAGE_BUFFER_SIZE
                case GL_SHADER_STORAGE_BUFFER_SIZE:
                    return {s_SHADER_STORAGE_BUFFER_SIZE, 26};
#endif
#ifdef GL_SHADER_STORAGE_BUFFER_START
                case GL_SHADER_STORAGE_BUFFER_START:
                    return {s_SHADER_STORAGE_BUFFER_START, 27};
#endif
#ifdef GL_SMOOTH_LINE_WIDTH_GRANULARITY
                case GL_SMOOTH_LINE_WIDTH_GRANULARITY:
                    return {s_SMOOTH_LINE_WIDTH_GRANULARITY, 29};
#endif
#ifdef GL_SMOOTH_LINE_WIDTH_RANGE
                case GL_SMOOTH_LINE_WIDTH_RANGE:
                    return {s_SMOOTH_LINE_WIDTH_RANGE, 23};
#endif
#ifdef GL_STENCIL_BACK_FAIL
                case GL_STENCIL_BACK_FAIL:
                    return {s_STENCIL_BACK_FAIL, 17};
#endif
#ifdef GL_STENCIL_BACK_FUNC
                case GL_STENCIL_BACK_FUNC:
                    return {s_STENCIL_BACK_FUNC, 17};
#endif
#ifdef GL_STENCIL_BACK_PASS_DEPTH_FAIL
                case GL_STENCIL_BACK_PASS_DEPTH_FAIL:
                    return {s_STENCIL_BACK_PASS_DEPTH_FAIL, 28};
#endif
#ifdef GL_STENCIL_BACK_PASS_DEPTH_PASS
                case GL_STENCIL_BACK_PASS_DEPTH_PASS:
                    return {s_STENCIL_BACK_PASS_DEPTH_PASS, 28};
#endif
#ifdef GL_STENCIL_BACK_REF
                case GL_STENCIL_BACK_REF:
                    return {s_STENCIL_BACK_REF, 16};
#endif
#ifdef GL_STENCIL_BACK_VALUE_MASK
                case GL_STENCIL_BACK_VALUE_MASK:
                    return {s_STENCIL_BACK_VALUE_MASK, 23};
#endif
#ifdef GL_STENCIL_BACK_WRITEMASK
                case GL_STENCIL_BACK_WRITEMASK:
                    return {s_STENCIL_BACK_WRITEMASK, 22};
#endif
#ifdef GL_STENCIL_CLEAR_VALUE
                case GL_STENCIL_CLEAR_VALUE:
                    return {s_STENCIL_CLEAR_VALUE, 19};
#endif
#ifdef GL_STENCIL_FAIL
                case GL_STENCIL_FAIL:
                    return {s_STENCIL_FAIL, 12};
#endif
#ifdef GL_STENCIL_FUNC
                case GL_STENCIL_FUNC:
                    return {s_STENCIL_FUNC, 12};
#endif
#ifdef GL_STENCIL_PASS_DEPTH_FAIL
                case GL_STENCIL_PASS_DEPTH_FAIL:
                    return {s_STENCIL_PASS_DEPTH_FAIL, 23};
#endif
#ifdef GL_STENCIL_PASS_DEPTH_PASS
                case GL_STENCIL_PASS_DEPTH_PASS:
                    return {s_STENCIL_PASS_DEPTH_PASS, 23};
#endif
#ifdef GL_STENCIL_REF
                case GL_STENCIL_REF:
                    return {s_STENCIL_REF, 11};
#endif
#ifdef GL_STENCIL_VALUE_MASK
                case GL_STENCIL_VALUE_MASK:
                    return {s_STENCIL_VALUE_MASK, 18};
#endif
#ifdef GL_STENCIL_WRITEMASK
                case GL_STENCIL_WRITEMASK:
                    return {s_STENCIL_WRITEMASK, 17};
#endif
#ifdef GL_STEREO
                case GL_STEREO:
                    return {s_STEREO, 6};
#endif
#ifdef GL_SUBPIXEL_BITS
                case GL_SUBPIXEL_BITS:
                    return {s_SUBPIXEL_BITS, 13};
#endif
#ifdef GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT
                case GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT:
                    return {s_TEXTURE_BUFFER_OFFSET_ALIGNMENT, 31};
#endif
#ifdef GL_TEXTURE_COMPRESSION_HINT
                case GL_TEXTURE_COMPRESSION_HINT:
                    return {s_TEXTURE_COMPRESSION_HINT, 24};
#endif
#ifdef GL_TIMESTAMP
                case GL_TIMESTAMP:
                    return {s_TIMESTAMP, 9};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_SIZE
                case GL_TRANSFORM_FEEDBACK_BUFFER_SIZE:
                    return {s_TRANSFORM_FEEDBACK_BUFFER_SIZE, 30};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_START
                case GL_TRANSFORM_FEEDBACK_BUFFER_START:
                    return {s_TRANSFORM_FEEDBACK_BUFFER_START, 31};
#endif
#ifdef GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT
                case GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT:
                    return {s_UNIFORM_BUFFER_OFFSET_ALIGNMENT, 31};
#endif
#ifdef GL_UNIFORM_BUFFER_SIZE
                case GL_UNIFORM_BUFFER_SIZE:
                    return {s_UNIFORM_BUFFER_SIZE, 19};
#endif
#ifdef GL_UNIFORM_BUFFER_START
                case GL_UNIFORM_BUFFER_START:
                    return {s_UNIFORM_BUFFER_START, 20};
#endif
#ifdef GL_UNPACK_ALIGNMENT
                case GL_UNPACK_ALIGNMENT:
                    return {s_UNPACK_ALIGNMENT, 16};
#endif
#ifdef GL_UNPACK_IMAGE_HEIGHT
                case GL_UNPACK_IMAGE_HEIGHT:
                    return {s_UNPACK_IMAGE_HEIGHT, 19};
#endif
#ifdef GL_UNPACK_LSB_FIRST
                case GL_UNPACK_LSB_FIRST:
                    return {s_UNPACK_LSB_FIRST, 16};
#endif
#ifdef GL_UNPACK_ROW_LENGTH
                case GL_UNPACK_ROW_LENGTH:
                    return {s_UNPACK_ROW_LENGTH, 17};
#endif
#ifdef GL_UNPACK_SKIP_IMAGES
                case GL_UNPACK_SKIP_IMAGES:
                    return {s_UNPACK_SKIP_IMAGES, 18};
#endif
#ifdef GL_UNPACK_SKIP_PIXELS
                case GL_UNPACK_SKIP_PIXELS:
                    return {s_UNPACK_SKIP_PIXELS, 18};
#endif
#ifdef GL_UNPACK_SKIP_ROWS
                case GL_UNPACK_SKIP_ROWS:
                    return {s_UNPACK_SKIP_ROWS, 16};
#endif
#ifdef GL_UNPACK_SWAP_BYTES
                case GL_UNPACK_SWAP_BYTES:
                    return {s_UNPACK_SWAP_BYTES, 17};
#endif
#ifdef GL_VIEWPORT
                case GL_VIEWPORT:
                    return {s_VIEWPORT, 8};
#endif
#ifdef GL_VIEWPORT_BOUNDS_RANGE
                case GL_VIEWPORT_BOUNDS_RANGE:
                    return {s_VIEWPORT_BOUNDS_RANGE, 21};
#endif
#ifdef GL_VIEWPORT_INDEX_PROVOKING_VERTEX
                case GL_VIEWPORT_INDEX_PROVOKING_VERTEX:
                    return {s_VIEWPORT_INDEX_PROVOKING_VERTEX, 31};
#endif
#ifdef GL_VIEWPORT_SUBPIXEL_BITS
                case GL_VIEWPORT_SUBPIXEL_BITS:
                    return {s_VIEWPORT_SUBPIXEL_BITS, 22};
#endif
                default:;
            }
            break;
        case 52: /* object_type */
            switch(GLenum(aev._value)) {
#ifdef GL_BUFFER
                case GL_BUFFER:
                    return {s_BUFFER, 6};
#endif
#ifdef GL_FRAMEBUFFER
                case GL_FRAMEBUFFER:
                    return {s_FRAMEBUFFER, 11};
#endif
#ifdef GL_NONE
                case GL_NONE:
                    return {s_NONE, 4};
#endif
#ifdef GL_PROGRAM
                case GL_PROGRAM:
                    return {s_PROGRAM, 7};
#endif
#ifdef GL_PROGRAM_PIPELINE
                case GL_PROGRAM_PIPELINE:
                    return {s_PROGRAM_PIPELINE, 16};
#endif
#ifdef GL_QUERY
                case GL_QUERY:
                    return {s_QUERY, 5};
#endif
#ifdef GL_RENDERBUFFER
                case GL_RENDERBUFFER:
                    return {s_RENDERBUFFER, 12};
#endif
#ifdef GL_SAMPLER
                case GL_SAMPLER:
                    return {s_SAMPLER, 7};
#endif
#ifdef GL_SHADER
                case GL_SHADER:
                    return {s_SHADER, 6};
#endif
#ifdef GL_TEXTURE
                case GL_TEXTURE:
                    return {s_TEXTURE, 7};
#endif
#ifdef GL_TRANSFORM_FEEDBACK
                case GL_TRANSFORM_FEEDBACK:
                    return {s_TRANSFORM_FEEDBACK, 18};
#endif
#ifdef GL_VERTEX_ARRAY
                case GL_VERTEX_ARRAY:
                    return {s_VERTEX_ARRAY, 12};
#endif
                default:;
            }
            break;
        case 53: /* old_matrix_mode */
            switch(GLenum(aev._value)) {
#ifdef GL_COLOR
                case GL_COLOR:
                    return {s_COLOR, 5};
#endif
#ifdef GL_MODELVIEW
                case GL_MODELVIEW:
                    return {s_MODELVIEW, 9};
#endif
#ifdef GL_PROJECTION
                case GL_PROJECTION:
                    return {s_PROJECTION, 10};
#endif
#ifdef GL_TEXTURE
                case GL_TEXTURE:
                    return {s_TEXTURE, 7};
#endif
                default:;
            }
            break;
        case 54: /* old_primitive_type */
            switch(GLenum(aev._value)) {
#ifdef GL_LINES
                case GL_LINES:
                    return {s_LINES, 5};
#endif
#ifdef GL_LINE_LOOP
                case GL_LINE_LOOP:
                    return {s_LINE_LOOP, 9};
#endif
#ifdef GL_LINE_STRIP
                case GL_LINE_STRIP:
                    return {s_LINE_STRIP, 10};
#endif
#ifdef GL_POINTS
                case GL_POINTS:
                    return {s_POINTS, 6};
#endif
#ifdef GL_POLYGON
                case GL_POLYGON:
                    return {s_POLYGON, 7};
#endif
#ifdef GL_QUADS
                case GL_QUADS:
                    return {s_QUADS, 5};
#endif
#ifdef GL_QUAD_STRIP
                case GL_QUAD_STRIP:
                    return {s_QUAD_STRIP, 10};
#endif
#ifdef GL_TRIANGLES
                case GL_TRIANGLES:
                    return {s_TRIANGLES, 9};
#endif
#ifdef GL_TRIANGLE_FAN
                case GL_TRIANGLE_FAN:
                    return {s_TRIANGLE_FAN, 12};
#endif
#ifdef GL_TRIANGLE_STRIP
                case GL_TRIANGLE_STRIP:
                    return {s_TRIANGLE_STRIP, 14};
#endif
                default:;
            }
            break;
        case 55: /* patch_parameter */
            switch(GLenum(aev._value)) {
#ifdef GL_PATCH_DEFAULT_INNER_LEVEL
                case GL_PATCH_DEFAULT_INNER_LEVEL:
                    return {s_PATCH_DEFAULT_INNER_LEVEL, 25};
#endif
#ifdef GL_PATCH_DEFAULT_OUTER_LEVEL
                case GL_PATCH_DEFAULT_OUTER_LEVEL:
                    return {s_PATCH_DEFAULT_OUTER_LEVEL, 25};
#endif
#ifdef GL_PATCH_VERTICES
                case GL_PATCH_VERTICES:
                    return {s_PATCH_VERTICES, 14};
#endif
                default:;
            }
            break;
        case 56: /* path_cap_style_nv */
            switch(GLenum(aev._value)) {
#ifdef GL_FLAT
                case GL_FLAT:
                    return {s_FLAT, 4};
#endif
#ifdef GL_ROUND_NV
                case GL_ROUND_NV:
                    return {s_ROUND_NV, 8};
#endif
#ifdef GL_SQUARE_NV
                case GL_SQUARE_NV:
                    return {s_SQUARE_NV, 9};
#endif
#ifdef GL_TRIANGULAR_NV
                case GL_TRIANGULAR_NV:
                    return {s_TRIANGULAR_NV, 13};
#endif
                default:;
            }
            break;
        case 57: /* path_color_format_nv */
            switch(GLenum(aev._value)) {
#ifdef GL_ALPHA
                case GL_ALPHA:
                    return {s_ALPHA, 5};
#endif
#ifdef GL_INTENSITY
                case GL_INTENSITY:
                    return {s_INTENSITY, 9};
#endif
#ifdef GL_LUMINANCE
                case GL_LUMINANCE:
                    return {s_LUMINANCE, 9};
#endif
#ifdef GL_LUMINANCE_ALPHA
                case GL_LUMINANCE_ALPHA:
                    return {s_LUMINANCE_ALPHA, 15};
#endif
#ifdef GL_RGB
                case GL_RGB:
                    return {s_RGB, 3};
#endif
#ifdef GL_RGBA
                case GL_RGBA:
                    return {s_RGBA, 4};
#endif
                default:;
            }
            break;
        case 58: /* path_color_nv */
            switch(GLenum(aev._value)) {
#ifdef GL_PRIMARY_COLOR_NV
                case GL_PRIMARY_COLOR_NV:
                    return {s_PRIMARY_COLOR_NV, 16};
#endif
#ifdef GL_SECONDARY_COLOR_NV
                case GL_SECONDARY_COLOR_NV:
                    return {s_SECONDARY_COLOR_NV, 18};
#endif
                default:;
            }
            break;
        case 59: /* path_command_nv */
            switch(GLubyte(aev._value)) {
#ifdef GL_ARC_TO_NV
                case GL_ARC_TO_NV:
                    return {s_ARC_TO_NV, 9};
#endif
#ifdef GL_CIRCULAR_CCW_ARC_TO_NV
                case GL_CIRCULAR_CCW_ARC_TO_NV:
                    return {s_CIRCULAR_CCW_ARC_TO_NV, 22};
#endif
#ifdef GL_CIRCULAR_CW_ARC_TO_NV
                case GL_CIRCULAR_CW_ARC_TO_NV:
                    return {s_CIRCULAR_CW_ARC_TO_NV, 21};
#endif
#ifdef GL_CIRCULAR_TANGENT_ARC_TO_NV
                case GL_CIRCULAR_TANGENT_ARC_TO_NV:
                    return {s_CIRCULAR_TANGENT_ARC_TO_NV, 26};
#endif
#ifdef GL_CLOSE_PATH_NV
                case GL_CLOSE_PATH_NV:
                    return {s_CLOSE_PATH_NV, 13};
#endif
#ifdef GL_CUBIC_CURVE_TO_NV
                case GL_CUBIC_CURVE_TO_NV:
                    return {s_CUBIC_CURVE_TO_NV, 17};
#endif
#ifdef GL_DUP_FIRST_CUBIC_CURVE_TO_NV
                case GL_DUP_FIRST_CUBIC_CURVE_TO_NV:
                    return {s_DUP_FIRST_CUBIC_CURVE_TO_NV, 27};
#endif
#ifdef GL_DUP_LAST_CUBIC_CURVE_TO_NV
                case GL_DUP_LAST_CUBIC_CURVE_TO_NV:
                    return {s_DUP_LAST_CUBIC_CURVE_TO_NV, 26};
#endif
#ifdef GL_HORIZONTAL_LINE_TO_NV
                case GL_HORIZONTAL_LINE_TO_NV:
                    return {s_HORIZONTAL_LINE_TO_NV, 21};
#endif
#ifdef GL_LARGE_CCW_ARC_TO_NV
                case GL_LARGE_CCW_ARC_TO_NV:
                    return {s_LARGE_CCW_ARC_TO_NV, 19};
#endif
#ifdef GL_LARGE_CW_ARC_TO_NV
                case GL_LARGE_CW_ARC_TO_NV:
                    return {s_LARGE_CW_ARC_TO_NV, 18};
#endif
#ifdef GL_LINE_TO_NV
                case GL_LINE_TO_NV:
                    return {s_LINE_TO_NV, 10};
#endif
#ifdef GL_MOVE_TO_NV
                case GL_MOVE_TO_NV:
                    return {s_MOVE_TO_NV, 10};
#endif
#ifdef GL_QUADRATIC_CURVE_TO_NV
                case GL_QUADRATIC_CURVE_TO_NV:
                    return {s_QUADRATIC_CURVE_TO_NV, 21};
#endif
#ifdef GL_RECT_NV
                case GL_RECT_NV:
                    return {s_RECT_NV, 7};
#endif
#ifdef GL_RELATIVE_ARC_TO_NV
                case GL_RELATIVE_ARC_TO_NV:
                    return {s_RELATIVE_ARC_TO_NV, 18};
#endif
#ifdef GL_RELATIVE_CUBIC_CURVE_TO_NV
                case GL_RELATIVE_CUBIC_CURVE_TO_NV:
                    return {s_RELATIVE_CUBIC_CURVE_TO_NV, 26};
#endif
#ifdef GL_RELATIVE_HORIZONTAL_LINE_TO_NV
                case GL_RELATIVE_HORIZONTAL_LINE_TO_NV:
                    return {s_RELATIVE_HORIZONTAL_LINE_TO_NV, 30};
#endif
#ifdef GL_RELATIVE_LARGE_CCW_ARC_TO_NV
                case GL_RELATIVE_LARGE_CCW_ARC_TO_NV:
                    return {s_RELATIVE_LARGE_CCW_ARC_TO_NV, 28};
#endif
#ifdef GL_RELATIVE_LARGE_CW_ARC_TO_NV
                case GL_RELATIVE_LARGE_CW_ARC_TO_NV:
                    return {s_RELATIVE_LARGE_CW_ARC_TO_NV, 27};
#endif
#ifdef GL_RELATIVE_LINE_TO_NV
                case GL_RELATIVE_LINE_TO_NV:
                    return {s_RELATIVE_LINE_TO_NV, 19};
#endif
#ifdef GL_RELATIVE_MOVE_TO_NV
                case GL_RELATIVE_MOVE_TO_NV:
                    return {s_RELATIVE_MOVE_TO_NV, 19};
#endif
#ifdef GL_RELATIVE_QUADRATIC_CURVE_TO_NV
                case GL_RELATIVE_QUADRATIC_CURVE_TO_NV:
                    return {s_RELATIVE_QUADRATIC_CURVE_TO_NV, 30};
#endif
#ifdef GL_RELATIVE_SMALL_CCW_ARC_TO_NV
                case GL_RELATIVE_SMALL_CCW_ARC_TO_NV:
                    return {s_RELATIVE_SMALL_CCW_ARC_TO_NV, 28};
#endif
#ifdef GL_RELATIVE_SMALL_CW_ARC_TO_NV
                case GL_RELATIVE_SMALL_CW_ARC_TO_NV:
                    return {s_RELATIVE_SMALL_CW_ARC_TO_NV, 27};
#endif
#ifdef GL_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV
                case GL_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV:
                    return {s_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV, 33};
#endif
#ifdef GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV
                case GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV:
                    return {s_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV, 37};
#endif
#ifdef GL_RELATIVE_VERTICAL_LINE_TO_NV
                case GL_RELATIVE_VERTICAL_LINE_TO_NV:
                    return {s_RELATIVE_VERTICAL_LINE_TO_NV, 28};
#endif
#ifdef GL_RESTART_PATH_NV
                case GL_RESTART_PATH_NV:
                    return {s_RESTART_PATH_NV, 15};
#endif
#ifdef GL_SMALL_CCW_ARC_TO_NV
                case GL_SMALL_CCW_ARC_TO_NV:
                    return {s_SMALL_CCW_ARC_TO_NV, 19};
#endif
#ifdef GL_SMALL_CW_ARC_TO_NV
                case GL_SMALL_CW_ARC_TO_NV:
                    return {s_SMALL_CW_ARC_TO_NV, 18};
#endif
#ifdef GL_SMOOTH_CUBIC_CURVE_TO_NV
                case GL_SMOOTH_CUBIC_CURVE_TO_NV:
                    return {s_SMOOTH_CUBIC_CURVE_TO_NV, 24};
#endif
#ifdef GL_SMOOTH_QUADRATIC_CURVE_TO_NV
                case GL_SMOOTH_QUADRATIC_CURVE_TO_NV:
                    return {s_SMOOTH_QUADRATIC_CURVE_TO_NV, 28};
#endif
#ifdef GL_VERTICAL_LINE_TO_NV
                case GL_VERTICAL_LINE_TO_NV:
                    return {s_VERTICAL_LINE_TO_NV, 19};
#endif
                default:;
            }
            break;
        case 60: /* path_dash_offset_reset_nv */
            switch(GLenum(aev._value)) {
#ifdef GL_MOVE_TO_CONTINUES_NV
                case GL_MOVE_TO_CONTINUES_NV:
                    return {s_MOVE_TO_CONTINUES_NV, 20};
#endif
#ifdef GL_MOVE_TO_RESET_NV
                case GL_MOVE_TO_RESET_NV:
                    return {s_MOVE_TO_RESET_NV, 16};
#endif
                default:;
            }
            break;
        case 61: /* path_fill_cover_mode_nv */
            switch(GLenum(aev._value)) {
#ifdef GL_BOUNDING_BOX_NV
                case GL_BOUNDING_BOX_NV:
                    return {s_BOUNDING_BOX_NV, 15};
#endif
#ifdef GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV
                case GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV:
                    return {s_BOUNDING_BOX_OF_BOUNDING_BOXES_NV, 33};
#endif
#ifdef GL_CONVEX_HULL_NV
                case GL_CONVEX_HULL_NV:
                    return {s_CONVEX_HULL_NV, 14};
#endif
#ifdef GL_PATH_FILL_COVER_MODE_NV
                case GL_PATH_FILL_COVER_MODE_NV:
                    return {s_PATH_FILL_COVER_MODE_NV, 23};
#endif
                default:;
            }
            break;
        case 62: /* path_fill_mode_nv */
            switch(GLenum(aev._value)) {
#ifdef GL_COUNT_DOWN_NV
                case GL_COUNT_DOWN_NV:
                    return {s_COUNT_DOWN_NV, 13};
#endif
#ifdef GL_COUNT_UP_NV
                case GL_COUNT_UP_NV:
                    return {s_COUNT_UP_NV, 11};
#endif
#ifdef GL_INVERT
                case GL_INVERT:
                    return {s_INVERT, 6};
#endif
#ifdef GL_PATH_FILL_MODE_NV
                case GL_PATH_FILL_MODE_NV:
                    return {s_PATH_FILL_MODE_NV, 17};
#endif
                default:;
            }
            break;
        case 63: /* path_font_style_nv */
            switch(GLbitfield(aev._value)) {
#ifdef GL_BOLD_BIT_NV
                case GL_BOLD_BIT_NV:
                    return {s_BOLD_BIT_NV, 11};
#endif
#ifdef GL_ITALIC_BIT_NV
                case GL_ITALIC_BIT_NV:
                    return {s_ITALIC_BIT_NV, 13};
#endif
                default:;
            }
            break;
        case 64: /* path_font_target_nv */
            switch(GLenum(aev._value)) {
#ifdef GL_FILE_NAME_NV
                case GL_FILE_NAME_NV:
                    return {s_FILE_NAME_NV, 12};
#endif
#ifdef GL_STANDARD_FONT_NAME_NV
                case GL_STANDARD_FONT_NAME_NV:
                    return {s_STANDARD_FONT_NAME_NV, 21};
#endif
#ifdef GL_SYSTEM_FONT_NAME_NV
                case GL_SYSTEM_FONT_NAME_NV:
                    return {s_SYSTEM_FONT_NAME_NV, 19};
#endif
                default:;
            }
            break;
        case 65: /* path_format_nv */
            switch(GLenum(aev._value)) {
#ifdef GL_PATH_FORMAT_PS_NV
                case GL_PATH_FORMAT_PS_NV:
                    return {s_PATH_FORMAT_PS_NV, 17};
#endif
#ifdef GL_PATH_FORMAT_SVG_NV
                case GL_PATH_FORMAT_SVG_NV:
                    return {s_PATH_FORMAT_SVG_NV, 18};
#endif
                default:;
            }
            break;
        case 66: /* path_gen_mode_nv */
            switch(GLenum(aev._value)) {
#ifdef GL_EYE_LINEAR
                case GL_EYE_LINEAR:
                    return {s_EYE_LINEAR, 10};
#endif
#ifdef GL_NONE
                case GL_NONE:
                    return {s_NONE, 4};
#endif
#ifdef GL_OBJECT_LINEAR
                case GL_OBJECT_LINEAR:
                    return {s_OBJECT_LINEAR, 13};
#endif
#ifdef GL_PATH_OBJECT_BOUNDING_BOX_NV
                case GL_PATH_OBJECT_BOUNDING_BOX_NV:
                    return {s_PATH_OBJECT_BOUNDING_BOX_NV, 27};
#endif
                default:;
            }
            break;
        case 67: /* path_join_style_nv */
            switch(GLenum(aev._value)) {
#ifdef GL_BEVEL_NV
                case GL_BEVEL_NV:
                    return {s_BEVEL_NV, 8};
#endif
#ifdef GL_MITER_REVERT_NV
                case GL_MITER_REVERT_NV:
                    return {s_MITER_REVERT_NV, 15};
#endif
#ifdef GL_MITER_TRUNCATE_NV
                case GL_MITER_TRUNCATE_NV:
                    return {s_MITER_TRUNCATE_NV, 17};
#endif
#ifdef GL_NONE
                case GL_NONE:
                    return {s_NONE, 4};
#endif
#ifdef GL_ROUND_NV
                case GL_ROUND_NV:
                    return {s_ROUND_NV, 8};
#endif
                default:;
            }
            break;
        case 68: /* path_list_mode_nv */
            switch(GLenum(aev._value)) {
#ifdef GL_ACCUM_ADJACENT_PAIRS_NV
                case GL_ACCUM_ADJACENT_PAIRS_NV:
                    return {s_ACCUM_ADJACENT_PAIRS_NV, 23};
#endif
#ifdef GL_ADJACENT_PAIRS_NV
                case GL_ADJACENT_PAIRS_NV:
                    return {s_ADJACENT_PAIRS_NV, 17};
#endif
#ifdef GL_FIRST_TO_REST_NV
                case GL_FIRST_TO_REST_NV:
                    return {s_FIRST_TO_REST_NV, 16};
#endif
                default:;
            }
            break;
        case 69: /* path_metric_query_nv */
            switch(GLbitfield(aev._value)) {
#ifdef GL_FONT_ASCENDER_BIT_NV
                case GL_FONT_ASCENDER_BIT_NV:
                    return {s_FONT_ASCENDER_BIT_NV, 20};
#endif
#ifdef GL_FONT_DESCENDER_BIT_NV
                case GL_FONT_DESCENDER_BIT_NV:
                    return {s_FONT_DESCENDER_BIT_NV, 21};
#endif
#ifdef GL_FONT_HAS_KERNING_BIT_NV
                case GL_FONT_HAS_KERNING_BIT_NV:
                    return {s_FONT_HAS_KERNING_BIT_NV, 23};
#endif
#ifdef GL_FONT_HEIGHT_BIT_NV
                case GL_FONT_HEIGHT_BIT_NV:
                    return {s_FONT_HEIGHT_BIT_NV, 18};
#endif
#ifdef GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV
                case GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV:
                    return {s_FONT_MAX_ADVANCE_HEIGHT_BIT_NV, 30};
#endif
#ifdef GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV
                case GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV:
                    return {s_FONT_MAX_ADVANCE_WIDTH_BIT_NV, 29};
#endif
#ifdef GL_FONT_UNDERLINE_POSITION_BIT_NV
                case GL_FONT_UNDERLINE_POSITION_BIT_NV:
                    return {s_FONT_UNDERLINE_POSITION_BIT_NV, 30};
#endif
#ifdef GL_FONT_UNDERLINE_THICKNESS_BIT_NV
                case GL_FONT_UNDERLINE_THICKNESS_BIT_NV:
                    return {s_FONT_UNDERLINE_THICKNESS_BIT_NV, 31};
#endif
#ifdef GL_FONT_UNITS_PER_EM_BIT_NV
                case GL_FONT_UNITS_PER_EM_BIT_NV:
                    return {s_FONT_UNITS_PER_EM_BIT_NV, 24};
#endif
#ifdef GL_FONT_X_MAX_BOUNDS_BIT_NV
                case GL_FONT_X_MAX_BOUNDS_BIT_NV:
                    return {s_FONT_X_MAX_BOUNDS_BIT_NV, 24};
#endif
#ifdef GL_FONT_X_MIN_BOUNDS_BIT_NV
                case GL_FONT_X_MIN_BOUNDS_BIT_NV:
                    return {s_FONT_X_MIN_BOUNDS_BIT_NV, 24};
#endif
#ifdef GL_FONT_Y_MAX_BOUNDS_BIT_NV
                case GL_FONT_Y_MAX_BOUNDS_BIT_NV:
                    return {s_FONT_Y_MAX_BOUNDS_BIT_NV, 24};
#endif
#ifdef GL_FONT_Y_MIN_BOUNDS_BIT_NV
                case GL_FONT_Y_MIN_BOUNDS_BIT_NV:
                    return {s_FONT_Y_MIN_BOUNDS_BIT_NV, 24};
#endif
#ifdef GL_GLYPH_HAS_KERNING_BIT_NV
                case GL_GLYPH_HAS_KERNING_BIT_NV:
                    return {s_GLYPH_HAS_KERNING_BIT_NV, 24};
#endif
#ifdef GL_GLYPH_HEIGHT_BIT_NV
                case GL_GLYPH_HEIGHT_BIT_NV:
                    return {s_GLYPH_HEIGHT_BIT_NV, 19};
#endif
#ifdef GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV
                case GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV:
                    return {s_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV, 39};
#endif
#ifdef GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV
                case GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV:
                    return {s_GLYPH_HORIZONTAL_BEARING_X_BIT_NV, 33};
#endif
#ifdef GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV
                case GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV:
                    return {s_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV, 33};
#endif
#ifdef GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV
                case GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV:
                    return {s_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV, 37};
#endif
#ifdef GL_GLYPH_VERTICAL_BEARING_X_BIT_NV
                case GL_GLYPH_VERTICAL_BEARING_X_BIT_NV:
                    return {s_GLYPH_VERTICAL_BEARING_X_BIT_NV, 31};
#endif
#ifdef GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV
                case GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV:
                    return {s_GLYPH_VERTICAL_BEARING_Y_BIT_NV, 31};
#endif
#ifdef GL_GLYPH_WIDTH_BIT_NV
                case GL_GLYPH_WIDTH_BIT_NV:
                    return {s_GLYPH_WIDTH_BIT_NV, 18};
#endif
                default:;
            }
            break;
        case 70: /* path_missing_glyph_nv */
            switch(GLenum(aev._value)) {
#ifdef GL_SKIP_MISSING_GLYPH_NV
                case GL_SKIP_MISSING_GLYPH_NV:
                    return {s_SKIP_MISSING_GLYPH_NV, 21};
#endif
#ifdef GL_USE_MISSING_GLYPH_NV
                case GL_USE_MISSING_GLYPH_NV:
                    return {s_USE_MISSING_GLYPH_NV, 20};
#endif
                default:;
            }
            break;
        case 71: /* path_parameter_nv */
            switch(GLenum(aev._value)) {
#ifdef GL_PATH_CLIENT_LENGTH_NV
                case GL_PATH_CLIENT_LENGTH_NV:
                    return {s_PATH_CLIENT_LENGTH_NV, 21};
#endif
#ifdef GL_PATH_COMMAND_COUNT_NV
                case GL_PATH_COMMAND_COUNT_NV:
                    return {s_PATH_COMMAND_COUNT_NV, 21};
#endif
#ifdef GL_PATH_COMPUTED_LENGTH_NV
                case GL_PATH_COMPUTED_LENGTH_NV:
                    return {s_PATH_COMPUTED_LENGTH_NV, 23};
#endif
#ifdef GL_PATH_COORD_COUNT_NV
                case GL_PATH_COORD_COUNT_NV:
                    return {s_PATH_COORD_COUNT_NV, 19};
#endif
#ifdef GL_PATH_DASH_ARRAY_COUNT_NV
                case GL_PATH_DASH_ARRAY_COUNT_NV:
                    return {s_PATH_DASH_ARRAY_COUNT_NV, 24};
#endif
#ifdef GL_PATH_DASH_OFFSET_NV
                case GL_PATH_DASH_OFFSET_NV:
                    return {s_PATH_DASH_OFFSET_NV, 19};
#endif
#ifdef GL_PATH_DASH_OFFSET_RESET_NV
                case GL_PATH_DASH_OFFSET_RESET_NV:
                    return {s_PATH_DASH_OFFSET_RESET_NV, 25};
#endif
#ifdef GL_PATH_FILL_BOUNDING_BOX_NV
                case GL_PATH_FILL_BOUNDING_BOX_NV:
                    return {s_PATH_FILL_BOUNDING_BOX_NV, 25};
#endif
#ifdef GL_PATH_FILL_COVER_MODE_NV
                case GL_PATH_FILL_COVER_MODE_NV:
                    return {s_PATH_FILL_COVER_MODE_NV, 23};
#endif
#ifdef GL_PATH_FILL_MASK_NV
                case GL_PATH_FILL_MASK_NV:
                    return {s_PATH_FILL_MASK_NV, 17};
#endif
#ifdef GL_PATH_FILL_MODE_NV
                case GL_PATH_FILL_MODE_NV:
                    return {s_PATH_FILL_MODE_NV, 17};
#endif
#ifdef GL_PATH_INITIAL_DASH_CAP_NV
                case GL_PATH_INITIAL_DASH_CAP_NV:
                    return {s_PATH_INITIAL_DASH_CAP_NV, 24};
#endif
#ifdef GL_PATH_INITIAL_END_CAP_NV
                case GL_PATH_INITIAL_END_CAP_NV:
                    return {s_PATH_INITIAL_END_CAP_NV, 23};
#endif
#ifdef GL_PATH_JOIN_STYLE_NV
                case GL_PATH_JOIN_STYLE_NV:
                    return {s_PATH_JOIN_STYLE_NV, 18};
#endif
#ifdef GL_PATH_MITER_LIMIT_NV
                case GL_PATH_MITER_LIMIT_NV:
                    return {s_PATH_MITER_LIMIT_NV, 19};
#endif
#ifdef GL_PATH_OBJECT_BOUNDING_BOX_NV
                case GL_PATH_OBJECT_BOUNDING_BOX_NV:
                    return {s_PATH_OBJECT_BOUNDING_BOX_NV, 27};
#endif
#ifdef GL_PATH_STROKE_BOUNDING_BOX_NV
                case GL_PATH_STROKE_BOUNDING_BOX_NV:
                    return {s_PATH_STROKE_BOUNDING_BOX_NV, 27};
#endif
#ifdef GL_PATH_STROKE_BOUND_NV
                case GL_PATH_STROKE_BOUND_NV:
                    return {s_PATH_STROKE_BOUND_NV, 20};
#endif
#ifdef GL_PATH_STROKE_COVER_MODE_NV
                case GL_PATH_STROKE_COVER_MODE_NV:
                    return {s_PATH_STROKE_COVER_MODE_NV, 25};
#endif
#ifdef GL_PATH_STROKE_MASK_NV
                case GL_PATH_STROKE_MASK_NV:
                    return {s_PATH_STROKE_MASK_NV, 19};
#endif
#ifdef GL_PATH_STROKE_WIDTH_NV
                case GL_PATH_STROKE_WIDTH_NV:
                    return {s_PATH_STROKE_WIDTH_NV, 20};
#endif
#ifdef GL_PATH_TERMINAL_DASH_CAP_NV
                case GL_PATH_TERMINAL_DASH_CAP_NV:
                    return {s_PATH_TERMINAL_DASH_CAP_NV, 25};
#endif
#ifdef GL_PATH_TERMINAL_END_CAP_NV
                case GL_PATH_TERMINAL_END_CAP_NV:
                    return {s_PATH_TERMINAL_END_CAP_NV, 24};
#endif
                default:;
            }
            break;
        case 72: /* path_stroke_cover_mode_nv */
            switch(GLenum(aev._value)) {
#ifdef GL_BOUNDING_BOX_NV
                case GL_BOUNDING_BOX_NV:
                    return {s_BOUNDING_BOX_NV, 15};
#endif
#ifdef GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV
                case GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV:
                    return {s_BOUNDING_BOX_OF_BOUNDING_BOXES_NV, 33};
#endif
#ifdef GL_CONVEX_HULL_NV
                case GL_CONVEX_HULL_NV:
                    return {s_CONVEX_HULL_NV, 14};
#endif
#ifdef GL_PATH_STROKE_COVER_MODE_NV
                case GL_PATH_STROKE_COVER_MODE_NV:
                    return {s_PATH_STROKE_COVER_MODE_NV, 25};
#endif
                default:;
            }
            break;
        case 73: /* path_text_encoding_nv */
            switch(GLenum(aev._value)) {
#ifdef GL_UTF16_NV
                case GL_UTF16_NV:
                    return {s_UTF16_NV, 8};
#endif
#ifdef GL_UTF8_NV
                case GL_UTF8_NV:
                    return {s_UTF8_NV, 7};
#endif
                default:;
            }
            break;
        case 74: /* path_transform_type_nv */
            switch(GLenum(aev._value)) {
#ifdef GL_AFFINE_2D_NV
                case GL_AFFINE_2D_NV:
                    return {s_AFFINE_2D_NV, 12};
#endif
#ifdef GL_AFFINE_3D_NV
                case GL_AFFINE_3D_NV:
                    return {s_AFFINE_3D_NV, 12};
#endif
#ifdef GL_NONE
                case GL_NONE:
                    return {s_NONE, 4};
#endif
#ifdef GL_TRANSLATE_2D_NV
                case GL_TRANSLATE_2D_NV:
                    return {s_TRANSLATE_2D_NV, 15};
#endif
#ifdef GL_TRANSLATE_3D_NV
                case GL_TRANSLATE_3D_NV:
                    return {s_TRANSLATE_3D_NV, 15};
#endif
#ifdef GL_TRANSLATE_X_NV
                case GL_TRANSLATE_X_NV:
                    return {s_TRANSLATE_X_NV, 14};
#endif
#ifdef GL_TRANSLATE_Y_NV
                case GL_TRANSLATE_Y_NV:
                    return {s_TRANSLATE_Y_NV, 14};
#endif
#ifdef GL_TRANSPOSE_AFFINE_2D_NV
                case GL_TRANSPOSE_AFFINE_2D_NV:
                    return {s_TRANSPOSE_AFFINE_2D_NV, 22};
#endif
#ifdef GL_TRANSPOSE_AFFINE_3D_NV
                case GL_TRANSPOSE_AFFINE_3D_NV:
                    return {s_TRANSPOSE_AFFINE_3D_NV, 22};
#endif
                default:;
            }
            break;
        case 75: /* pixel_data_format */
            switch(GLenum(aev._value)) {
#ifdef GL_BGR
                case GL_BGR:
                    return {s_BGR, 3};
#endif
#ifdef GL_BGRA
                case GL_BGRA:
                    return {s_BGRA, 4};
#endif
#ifdef GL_BGRA_INTEGER
                case GL_BGRA_INTEGER:
                    return {s_BGRA_INTEGER, 12};
#endif
#ifdef GL_BGR_INTEGER
                case GL_BGR_INTEGER:
                    return {s_BGR_INTEGER, 11};
#endif
#ifdef GL_BLUE
                case GL_BLUE:
                    return {s_BLUE, 4};
#endif
#ifdef GL_BLUE_INTEGER
                case GL_BLUE_INTEGER:
                    return {s_BLUE_INTEGER, 12};
#endif
#ifdef GL_DEPTH_COMPONENT
                case GL_DEPTH_COMPONENT:
                    return {s_DEPTH_COMPONENT, 15};
#endif
#ifdef GL_DEPTH_STENCIL
                case GL_DEPTH_STENCIL:
                    return {s_DEPTH_STENCIL, 13};
#endif
#ifdef GL_GREEN
                case GL_GREEN:
                    return {s_GREEN, 5};
#endif
#ifdef GL_GREEN_INTEGER
                case GL_GREEN_INTEGER:
                    return {s_GREEN_INTEGER, 13};
#endif
#ifdef GL_RED
                case GL_RED:
                    return {s_RED, 3};
#endif
#ifdef GL_RED_INTEGER
                case GL_RED_INTEGER:
                    return {s_RED_INTEGER, 11};
#endif
#ifdef GL_RG
                case GL_RG:
                    return {s_RG, 2};
#endif
#ifdef GL_RGB
                case GL_RGB:
                    return {s_RGB, 3};
#endif
#ifdef GL_RGBA
                case GL_RGBA:
                    return {s_RGBA, 4};
#endif
#ifdef GL_RGBA_INTEGER
                case GL_RGBA_INTEGER:
                    return {s_RGBA_INTEGER, 12};
#endif
#ifdef GL_RGB_INTEGER
                case GL_RGB_INTEGER:
                    return {s_RGB_INTEGER, 11};
#endif
#ifdef GL_RG_INTEGER
                case GL_RG_INTEGER:
                    return {s_RG_INTEGER, 10};
#endif
#ifdef GL_STENCIL_INDEX
                case GL_STENCIL_INDEX:
                    return {s_STENCIL_INDEX, 13};
#endif
                default:;
            }
            break;
        case 76: /* pixel_data_internal_format */
            switch(GLenum(aev._value)) {
#ifdef GL_COMPRESSED_R11_EAC
                case GL_COMPRESSED_R11_EAC:
                    return {s_COMPRESSED_R11_EAC, 18};
#endif
#ifdef GL_COMPRESSED_RED
                case GL_COMPRESSED_RED:
                    return {s_COMPRESSED_RED, 14};
#endif
#ifdef GL_COMPRESSED_RED_RGTC1
                case GL_COMPRESSED_RED_RGTC1:
                    return {s_COMPRESSED_RED_RGTC1, 20};
#endif
#ifdef GL_COMPRESSED_RG
                case GL_COMPRESSED_RG:
                    return {s_COMPRESSED_RG, 13};
#endif
#ifdef GL_COMPRESSED_RG11_EAC
                case GL_COMPRESSED_RG11_EAC:
                    return {s_COMPRESSED_RG11_EAC, 19};
#endif
#ifdef GL_COMPRESSED_RGB
                case GL_COMPRESSED_RGB:
                    return {s_COMPRESSED_RGB, 14};
#endif
#ifdef GL_COMPRESSED_RGB8_ETC2
                case GL_COMPRESSED_RGB8_ETC2:
                    return {s_COMPRESSED_RGB8_ETC2, 20};
#endif
#ifdef GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2
                case GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
                    return {s_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, 40};
#endif
#ifdef GL_COMPRESSED_RGBA
                case GL_COMPRESSED_RGBA:
                    return {s_COMPRESSED_RGBA, 15};
#endif
#ifdef GL_COMPRESSED_RGBA8_ETC2_EAC
                case GL_COMPRESSED_RGBA8_ETC2_EAC:
                    return {s_COMPRESSED_RGBA8_ETC2_EAC, 25};
#endif
#ifdef GL_COMPRESSED_RGBA_BPTC_UNORM
                case GL_COMPRESSED_RGBA_BPTC_UNORM:
                    return {s_COMPRESSED_RGBA_BPTC_UNORM, 26};
#endif
#ifdef GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT
                case GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:
                    return {s_COMPRESSED_RGB_BPTC_SIGNED_FLOAT, 32};
#endif
#ifdef GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT
                case GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:
                    return {s_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT, 34};
#endif
#ifdef GL_COMPRESSED_RG_RGTC2
                case GL_COMPRESSED_RG_RGTC2:
                    return {s_COMPRESSED_RG_RGTC2, 19};
#endif
#ifdef GL_COMPRESSED_SIGNED_R11_EAC
                case GL_COMPRESSED_SIGNED_R11_EAC:
                    return {s_COMPRESSED_SIGNED_R11_EAC, 25};
#endif
#ifdef GL_COMPRESSED_SIGNED_RED_RGTC1
                case GL_COMPRESSED_SIGNED_RED_RGTC1:
                    return {s_COMPRESSED_SIGNED_RED_RGTC1, 27};
#endif
#ifdef GL_COMPRESSED_SIGNED_RG11_EAC
                case GL_COMPRESSED_SIGNED_RG11_EAC:
                    return {s_COMPRESSED_SIGNED_RG11_EAC, 26};
#endif
#ifdef GL_COMPRESSED_SIGNED_RG_RGTC2
                case GL_COMPRESSED_SIGNED_RG_RGTC2:
                    return {s_COMPRESSED_SIGNED_RG_RGTC2, 26};
#endif
#ifdef GL_COMPRESSED_SRGB
                case GL_COMPRESSED_SRGB:
                    return {s_COMPRESSED_SRGB, 15};
#endif
#ifdef GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                case GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
                    return {s_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, 32};
#endif
#ifdef GL_COMPRESSED_SRGB8_ETC2
                case GL_COMPRESSED_SRGB8_ETC2:
                    return {s_COMPRESSED_SRGB8_ETC2, 21};
#endif
#ifdef GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2
                case GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
                    return {s_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, 41};
#endif
#ifdef GL_COMPRESSED_SRGB_ALPHA
                case GL_COMPRESSED_SRGB_ALPHA:
                    return {s_COMPRESSED_SRGB_ALPHA, 21};
#endif
#ifdef GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM
                case GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:
                    return {s_COMPRESSED_SRGB_ALPHA_BPTC_UNORM, 32};
#endif
#ifdef GL_DEPTH24_STENCIL8
                case GL_DEPTH24_STENCIL8:
                    return {s_DEPTH24_STENCIL8, 16};
#endif
#ifdef GL_DEPTH32F_STENCIL8
                case GL_DEPTH32F_STENCIL8:
                    return {s_DEPTH32F_STENCIL8, 17};
#endif
#ifdef GL_DEPTH_COMPONENT
                case GL_DEPTH_COMPONENT:
                    return {s_DEPTH_COMPONENT, 15};
#endif
#ifdef GL_DEPTH_COMPONENT16
                case GL_DEPTH_COMPONENT16:
                    return {s_DEPTH_COMPONENT16, 17};
#endif
#ifdef GL_DEPTH_COMPONENT24
                case GL_DEPTH_COMPONENT24:
                    return {s_DEPTH_COMPONENT24, 17};
#endif
#ifdef GL_DEPTH_COMPONENT32
                case GL_DEPTH_COMPONENT32:
                    return {s_DEPTH_COMPONENT32, 17};
#endif
#ifdef GL_DEPTH_COMPONENT32F
                case GL_DEPTH_COMPONENT32F:
                    return {s_DEPTH_COMPONENT32F, 18};
#endif
#ifdef GL_DEPTH_STENCIL
                case GL_DEPTH_STENCIL:
                    return {s_DEPTH_STENCIL, 13};
#endif
#ifdef GL_R11F_G11F_B10F
                case GL_R11F_G11F_B10F:
                    return {s_R11F_G11F_B10F, 14};
#endif
#ifdef GL_R16
                case GL_R16:
                    return {s_R16, 3};
#endif
#ifdef GL_R16F
                case GL_R16F:
                    return {s_R16F, 4};
#endif
#ifdef GL_R16I
                case GL_R16I:
                    return {s_R16I, 4};
#endif
#ifdef GL_R16UI
                case GL_R16UI:
                    return {s_R16UI, 5};
#endif
#ifdef GL_R16_SNORM
                case GL_R16_SNORM:
                    return {s_R16_SNORM, 9};
#endif
#ifdef GL_R32F
                case GL_R32F:
                    return {s_R32F, 4};
#endif
#ifdef GL_R32I
                case GL_R32I:
                    return {s_R32I, 4};
#endif
#ifdef GL_R32UI
                case GL_R32UI:
                    return {s_R32UI, 5};
#endif
#ifdef GL_R3_G3_B2
                case GL_R3_G3_B2:
                    return {s_R3_G3_B2, 8};
#endif
#ifdef GL_R8
                case GL_R8:
                    return {s_R8, 2};
#endif
#ifdef GL_R8I
                case GL_R8I:
                    return {s_R8I, 3};
#endif
#ifdef GL_R8UI
                case GL_R8UI:
                    return {s_R8UI, 4};
#endif
#ifdef GL_R8_SNORM
                case GL_R8_SNORM:
                    return {s_R8_SNORM, 8};
#endif
#ifdef GL_RED
                case GL_RED:
                    return {s_RED, 3};
#endif
#ifdef GL_RG
                case GL_RG:
                    return {s_RG, 2};
#endif
#ifdef GL_RG16
                case GL_RG16:
                    return {s_RG16, 4};
#endif
#ifdef GL_RG16F
                case GL_RG16F:
                    return {s_RG16F, 5};
#endif
#ifdef GL_RG16I
                case GL_RG16I:
                    return {s_RG16I, 5};
#endif
#ifdef GL_RG16UI
                case GL_RG16UI:
                    return {s_RG16UI, 6};
#endif
#ifdef GL_RG16_SNORM
                case GL_RG16_SNORM:
                    return {s_RG16_SNORM, 10};
#endif
#ifdef GL_RG32F
                case GL_RG32F:
                    return {s_RG32F, 5};
#endif
#ifdef GL_RG32I
                case GL_RG32I:
                    return {s_RG32I, 5};
#endif
#ifdef GL_RG32UI
                case GL_RG32UI:
                    return {s_RG32UI, 6};
#endif
#ifdef GL_RG8
                case GL_RG8:
                    return {s_RG8, 3};
#endif
#ifdef GL_RG8I
                case GL_RG8I:
                    return {s_RG8I, 4};
#endif
#ifdef GL_RG8UI
                case GL_RG8UI:
                    return {s_RG8UI, 5};
#endif
#ifdef GL_RG8_SNORM
                case GL_RG8_SNORM:
                    return {s_RG8_SNORM, 9};
#endif
#ifdef GL_RGB
                case GL_RGB:
                    return {s_RGB, 3};
#endif
#ifdef GL_RGB10
                case GL_RGB10:
                    return {s_RGB10, 5};
#endif
#ifdef GL_RGB10_A2
                case GL_RGB10_A2:
                    return {s_RGB10_A2, 8};
#endif
#ifdef GL_RGB10_A2UI
                case GL_RGB10_A2UI:
                    return {s_RGB10_A2UI, 10};
#endif
#ifdef GL_RGB12
                case GL_RGB12:
                    return {s_RGB12, 5};
#endif
#ifdef GL_RGB16
                case GL_RGB16:
                    return {s_RGB16, 5};
#endif
#ifdef GL_RGB16F
                case GL_RGB16F:
                    return {s_RGB16F, 6};
#endif
#ifdef GL_RGB16I
                case GL_RGB16I:
                    return {s_RGB16I, 6};
#endif
#ifdef GL_RGB16UI
                case GL_RGB16UI:
                    return {s_RGB16UI, 7};
#endif
#ifdef GL_RGB16_SNORM
                case GL_RGB16_SNORM:
                    return {s_RGB16_SNORM, 11};
#endif
#ifdef GL_RGB32F
                case GL_RGB32F:
                    return {s_RGB32F, 6};
#endif
#ifdef GL_RGB32I
                case GL_RGB32I:
                    return {s_RGB32I, 6};
#endif
#ifdef GL_RGB32UI
                case GL_RGB32UI:
                    return {s_RGB32UI, 7};
#endif
#ifdef GL_RGB4
                case GL_RGB4:
                    return {s_RGB4, 4};
#endif
#ifdef GL_RGB5
                case GL_RGB5:
                    return {s_RGB5, 4};
#endif
#ifdef GL_RGB5_A1
                case GL_RGB5_A1:
                    return {s_RGB5_A1, 7};
#endif
#ifdef GL_RGB8
                case GL_RGB8:
                    return {s_RGB8, 4};
#endif
#ifdef GL_RGB8I
                case GL_RGB8I:
                    return {s_RGB8I, 5};
#endif
#ifdef GL_RGB8UI
                case GL_RGB8UI:
                    return {s_RGB8UI, 6};
#endif
#ifdef GL_RGB8_SNORM
                case GL_RGB8_SNORM:
                    return {s_RGB8_SNORM, 10};
#endif
#ifdef GL_RGB9_E5
                case GL_RGB9_E5:
                    return {s_RGB9_E5, 7};
#endif
#ifdef GL_RGBA
                case GL_RGBA:
                    return {s_RGBA, 4};
#endif
#ifdef GL_RGBA12
                case GL_RGBA12:
                    return {s_RGBA12, 6};
#endif
#ifdef GL_RGBA16
                case GL_RGBA16:
                    return {s_RGBA16, 6};
#endif
#ifdef GL_RGBA16F
                case GL_RGBA16F:
                    return {s_RGBA16F, 7};
#endif
#ifdef GL_RGBA16I
                case GL_RGBA16I:
                    return {s_RGBA16I, 7};
#endif
#ifdef GL_RGBA16UI
                case GL_RGBA16UI:
                    return {s_RGBA16UI, 8};
#endif
#ifdef GL_RGBA16_SNORM
                case GL_RGBA16_SNORM:
                    return {s_RGBA16_SNORM, 12};
#endif
#ifdef GL_RGBA2
                case GL_RGBA2:
                    return {s_RGBA2, 5};
#endif
#ifdef GL_RGBA32F
                case GL_RGBA32F:
                    return {s_RGBA32F, 7};
#endif
#ifdef GL_RGBA32I
                case GL_RGBA32I:
                    return {s_RGBA32I, 7};
#endif
#ifdef GL_RGBA32UI
                case GL_RGBA32UI:
                    return {s_RGBA32UI, 8};
#endif
#ifdef GL_RGBA4
                case GL_RGBA4:
                    return {s_RGBA4, 5};
#endif
#ifdef GL_RGBA8
                case GL_RGBA8:
                    return {s_RGBA8, 5};
#endif
#ifdef GL_RGBA8I
                case GL_RGBA8I:
                    return {s_RGBA8I, 6};
#endif
#ifdef GL_RGBA8UI
                case GL_RGBA8UI:
                    return {s_RGBA8UI, 7};
#endif
#ifdef GL_RGBA8_SNORM
                case GL_RGBA8_SNORM:
                    return {s_RGBA8_SNORM, 11};
#endif
#ifdef GL_SRGB8
                case GL_SRGB8:
                    return {s_SRGB8, 5};
#endif
#ifdef GL_SRGB8_ALPHA8
                case GL_SRGB8_ALPHA8:
                    return {s_SRGB8_ALPHA8, 12};
#endif
#ifdef GL_STENCIL_INDEX8
                case GL_STENCIL_INDEX8:
                    return {s_STENCIL_INDEX8, 14};
#endif
                default:;
            }
            break;
        case 77: /* pixel_data_type */
            switch(GLenum(aev._value)) {
#ifdef GL_BYTE
                case GL_BYTE:
                    return {s_BYTE, 4};
#endif
#ifdef GL_DOUBLE
                case GL_DOUBLE:
                    return {s_DOUBLE, 6};
#endif
#ifdef GL_FLOAT
                case GL_FLOAT:
                    return {s_FLOAT, 5};
#endif
#ifdef GL_FLOAT_32_UNSIGNED_INT_24_8_REV
                case GL_FLOAT_32_UNSIGNED_INT_24_8_REV:
                    return {s_FLOAT_32_UNSIGNED_INT_24_8_REV, 30};
#endif
#ifdef GL_HALF_FLOAT
                case GL_HALF_FLOAT:
                    return {s_HALF_FLOAT, 10};
#endif
#ifdef GL_INT
                case GL_INT:
                    return {s_INT, 3};
#endif
#ifdef GL_SHORT
                case GL_SHORT:
                    return {s_SHORT, 5};
#endif
#ifdef GL_UNSIGNED_BYTE
                case GL_UNSIGNED_BYTE:
                    return {s_UNSIGNED_BYTE, 13};
#endif
#ifdef GL_UNSIGNED_BYTE_2_3_3_REV
                case GL_UNSIGNED_BYTE_2_3_3_REV:
                    return {s_UNSIGNED_BYTE_2_3_3_REV, 23};
#endif
#ifdef GL_UNSIGNED_BYTE_3_3_2
                case GL_UNSIGNED_BYTE_3_3_2:
                    return {s_UNSIGNED_BYTE_3_3_2, 19};
#endif
#ifdef GL_UNSIGNED_INT
                case GL_UNSIGNED_INT:
                    return {s_UNSIGNED_INT, 12};
#endif
#ifdef GL_UNSIGNED_INT_10F_11F_11F_REV
                case GL_UNSIGNED_INT_10F_11F_11F_REV:
                    return {s_UNSIGNED_INT_10F_11F_11F_REV, 28};
#endif
#ifdef GL_UNSIGNED_INT_10_10_10_2
                case GL_UNSIGNED_INT_10_10_10_2:
                    return {s_UNSIGNED_INT_10_10_10_2, 23};
#endif
#ifdef GL_UNSIGNED_INT_24_8
                case GL_UNSIGNED_INT_24_8:
                    return {s_UNSIGNED_INT_24_8, 17};
#endif
#ifdef GL_UNSIGNED_INT_2_10_10_10_REV
                case GL_UNSIGNED_INT_2_10_10_10_REV:
                    return {s_UNSIGNED_INT_2_10_10_10_REV, 27};
#endif
#ifdef GL_UNSIGNED_INT_5_9_9_9_REV
                case GL_UNSIGNED_INT_5_9_9_9_REV:
                    return {s_UNSIGNED_INT_5_9_9_9_REV, 24};
#endif
#ifdef GL_UNSIGNED_INT_8_8_8_8
                case GL_UNSIGNED_INT_8_8_8_8:
                    return {s_UNSIGNED_INT_8_8_8_8, 20};
#endif
#ifdef GL_UNSIGNED_INT_8_8_8_8_REV
                case GL_UNSIGNED_INT_8_8_8_8_REV:
                    return {s_UNSIGNED_INT_8_8_8_8_REV, 24};
#endif
#ifdef GL_UNSIGNED_SHORT
                case GL_UNSIGNED_SHORT:
                    return {s_UNSIGNED_SHORT, 14};
#endif
#ifdef GL_UNSIGNED_SHORT_1_5_5_5_REV
                case GL_UNSIGNED_SHORT_1_5_5_5_REV:
                    return {s_UNSIGNED_SHORT_1_5_5_5_REV, 26};
#endif
#ifdef GL_UNSIGNED_SHORT_4_4_4_4
                case GL_UNSIGNED_SHORT_4_4_4_4:
                    return {s_UNSIGNED_SHORT_4_4_4_4, 22};
#endif
#ifdef GL_UNSIGNED_SHORT_4_4_4_4_REV
                case GL_UNSIGNED_SHORT_4_4_4_4_REV:
                    return {s_UNSIGNED_SHORT_4_4_4_4_REV, 26};
#endif
#ifdef GL_UNSIGNED_SHORT_5_5_5_1
                case GL_UNSIGNED_SHORT_5_5_5_1:
                    return {s_UNSIGNED_SHORT_5_5_5_1, 22};
#endif
#ifdef GL_UNSIGNED_SHORT_5_6_5
                case GL_UNSIGNED_SHORT_5_6_5:
                    return {s_UNSIGNED_SHORT_5_6_5, 20};
#endif
#ifdef GL_UNSIGNED_SHORT_5_6_5_REV
                case GL_UNSIGNED_SHORT_5_6_5_REV:
                    return {s_UNSIGNED_SHORT_5_6_5_REV, 24};
#endif
                default:;
            }
            break;
        case 78: /* pixel_parameter */
            switch(GLenum(aev._value)) {
#ifdef GL_PACK_ALIGNMENT
                case GL_PACK_ALIGNMENT:
                    return {s_PACK_ALIGNMENT, 14};
#endif
#ifdef GL_PACK_COMPRESSED_BLOCK_DEPTH
                case GL_PACK_COMPRESSED_BLOCK_DEPTH:
                    return {s_PACK_COMPRESSED_BLOCK_DEPTH, 27};
#endif
#ifdef GL_PACK_COMPRESSED_BLOCK_HEIGHT
                case GL_PACK_COMPRESSED_BLOCK_HEIGHT:
                    return {s_PACK_COMPRESSED_BLOCK_HEIGHT, 28};
#endif
#ifdef GL_PACK_COMPRESSED_BLOCK_SIZE
                case GL_PACK_COMPRESSED_BLOCK_SIZE:
                    return {s_PACK_COMPRESSED_BLOCK_SIZE, 26};
#endif
#ifdef GL_PACK_COMPRESSED_BLOCK_WIDTH
                case GL_PACK_COMPRESSED_BLOCK_WIDTH:
                    return {s_PACK_COMPRESSED_BLOCK_WIDTH, 27};
#endif
#ifdef GL_PACK_IMAGE_HEIGHT
                case GL_PACK_IMAGE_HEIGHT:
                    return {s_PACK_IMAGE_HEIGHT, 17};
#endif
#ifdef GL_PACK_LSB_FIRST
                case GL_PACK_LSB_FIRST:
                    return {s_PACK_LSB_FIRST, 14};
#endif
#ifdef GL_PACK_ROW_LENGTH
                case GL_PACK_ROW_LENGTH:
                    return {s_PACK_ROW_LENGTH, 15};
#endif
#ifdef GL_PACK_SKIP_IMAGES
                case GL_PACK_SKIP_IMAGES:
                    return {s_PACK_SKIP_IMAGES, 16};
#endif
#ifdef GL_PACK_SKIP_PIXELS
                case GL_PACK_SKIP_PIXELS:
                    return {s_PACK_SKIP_PIXELS, 16};
#endif
#ifdef GL_PACK_SKIP_ROWS
                case GL_PACK_SKIP_ROWS:
                    return {s_PACK_SKIP_ROWS, 14};
#endif
#ifdef GL_PACK_SWAP_BYTES
                case GL_PACK_SWAP_BYTES:
                    return {s_PACK_SWAP_BYTES, 15};
#endif
#ifdef GL_UNPACK_ALIGNMENT
                case GL_UNPACK_ALIGNMENT:
                    return {s_UNPACK_ALIGNMENT, 16};
#endif
#ifdef GL_UNPACK_COMPRESSED_BLOCK_DEPTH
                case GL_UNPACK_COMPRESSED_BLOCK_DEPTH:
                    return {s_UNPACK_COMPRESSED_BLOCK_DEPTH, 29};
#endif
#ifdef GL_UNPACK_COMPRESSED_BLOCK_HEIGHT
                case GL_UNPACK_COMPRESSED_BLOCK_HEIGHT:
                    return {s_UNPACK_COMPRESSED_BLOCK_HEIGHT, 30};
#endif
#ifdef GL_UNPACK_COMPRESSED_BLOCK_SIZE
                case GL_UNPACK_COMPRESSED_BLOCK_SIZE:
                    return {s_UNPACK_COMPRESSED_BLOCK_SIZE, 28};
#endif
#ifdef GL_UNPACK_COMPRESSED_BLOCK_WIDTH
                case GL_UNPACK_COMPRESSED_BLOCK_WIDTH:
                    return {s_UNPACK_COMPRESSED_BLOCK_WIDTH, 29};
#endif
#ifdef GL_UNPACK_IMAGE_HEIGHT
                case GL_UNPACK_IMAGE_HEIGHT:
                    return {s_UNPACK_IMAGE_HEIGHT, 19};
#endif
#ifdef GL_UNPACK_LSB_FIRST
                case GL_UNPACK_LSB_FIRST:
                    return {s_UNPACK_LSB_FIRST, 16};
#endif
#ifdef GL_UNPACK_ROW_LENGTH
                case GL_UNPACK_ROW_LENGTH:
                    return {s_UNPACK_ROW_LENGTH, 17};
#endif
#ifdef GL_UNPACK_SKIP_IMAGES
                case GL_UNPACK_SKIP_IMAGES:
                    return {s_UNPACK_SKIP_IMAGES, 18};
#endif
#ifdef GL_UNPACK_SKIP_PIXELS
                case GL_UNPACK_SKIP_PIXELS:
                    return {s_UNPACK_SKIP_PIXELS, 18};
#endif
#ifdef GL_UNPACK_SKIP_ROWS
                case GL_UNPACK_SKIP_ROWS:
                    return {s_UNPACK_SKIP_ROWS, 16};
#endif
#ifdef GL_UNPACK_SWAP_BYTES
                case GL_UNPACK_SWAP_BYTES:
                    return {s_UNPACK_SWAP_BYTES, 17};
#endif
                default:;
            }
            break;
        case 79: /* pixel_transfer_parameter */
            switch(GLenum(aev._value)) {
#ifdef GL_ALPHA_BIAS
                case GL_ALPHA_BIAS:
                    return {s_ALPHA_BIAS, 10};
#endif
#ifdef GL_ALPHA_SCALE
                case GL_ALPHA_SCALE:
                    return {s_ALPHA_SCALE, 11};
#endif
#ifdef GL_BLUE_BIAS
                case GL_BLUE_BIAS:
                    return {s_BLUE_BIAS, 9};
#endif
#ifdef GL_BLUE_SCALE
                case GL_BLUE_SCALE:
                    return {s_BLUE_SCALE, 10};
#endif
#ifdef GL_DEPTH_BIAS
                case GL_DEPTH_BIAS:
                    return {s_DEPTH_BIAS, 10};
#endif
#ifdef GL_DEPTH_SCALE
                case GL_DEPTH_SCALE:
                    return {s_DEPTH_SCALE, 11};
#endif
#ifdef GL_GREEN_BIAS
                case GL_GREEN_BIAS:
                    return {s_GREEN_BIAS, 10};
#endif
#ifdef GL_GREEN_SCALE
                case GL_GREEN_SCALE:
                    return {s_GREEN_SCALE, 11};
#endif
#ifdef GL_INDEX_OFFSET
                case GL_INDEX_OFFSET:
                    return {s_INDEX_OFFSET, 12};
#endif
#ifdef GL_INDEX_SHIFT
                case GL_INDEX_SHIFT:
                    return {s_INDEX_SHIFT, 11};
#endif
#ifdef GL_MAP_COLOR
                case GL_MAP_COLOR:
                    return {s_MAP_COLOR, 9};
#endif
#ifdef GL_MAP_STENCIL
                case GL_MAP_STENCIL:
                    return {s_MAP_STENCIL, 11};
#endif
#ifdef GL_POST_COLOR_MATRIX_ALPHA_BIAS
                case GL_POST_COLOR_MATRIX_ALPHA_BIAS:
                    return {s_POST_COLOR_MATRIX_ALPHA_BIAS, 28};
#endif
#ifdef GL_POST_COLOR_MATRIX_ALPHA_SCALE
                case GL_POST_COLOR_MATRIX_ALPHA_SCALE:
                    return {s_POST_COLOR_MATRIX_ALPHA_SCALE, 29};
#endif
#ifdef GL_POST_COLOR_MATRIX_BLUE_BIAS
                case GL_POST_COLOR_MATRIX_BLUE_BIAS:
                    return {s_POST_COLOR_MATRIX_BLUE_BIAS, 27};
#endif
#ifdef GL_POST_COLOR_MATRIX_BLUE_SCALE
                case GL_POST_COLOR_MATRIX_BLUE_SCALE:
                    return {s_POST_COLOR_MATRIX_BLUE_SCALE, 28};
#endif
#ifdef GL_POST_COLOR_MATRIX_GREEN_BIAS
                case GL_POST_COLOR_MATRIX_GREEN_BIAS:
                    return {s_POST_COLOR_MATRIX_GREEN_BIAS, 28};
#endif
#ifdef GL_POST_COLOR_MATRIX_GREEN_SCALE
                case GL_POST_COLOR_MATRIX_GREEN_SCALE:
                    return {s_POST_COLOR_MATRIX_GREEN_SCALE, 29};
#endif
#ifdef GL_POST_COLOR_MATRIX_RED_BIAS
                case GL_POST_COLOR_MATRIX_RED_BIAS:
                    return {s_POST_COLOR_MATRIX_RED_BIAS, 26};
#endif
#ifdef GL_POST_COLOR_MATRIX_RED_SCALE
                case GL_POST_COLOR_MATRIX_RED_SCALE:
                    return {s_POST_COLOR_MATRIX_RED_SCALE, 27};
#endif
#ifdef GL_POST_CONVOLUTION_ALPHA_BIAS
                case GL_POST_CONVOLUTION_ALPHA_BIAS:
                    return {s_POST_CONVOLUTION_ALPHA_BIAS, 27};
#endif
#ifdef GL_POST_CONVOLUTION_ALPHA_SCALE
                case GL_POST_CONVOLUTION_ALPHA_SCALE:
                    return {s_POST_CONVOLUTION_ALPHA_SCALE, 28};
#endif
#ifdef GL_POST_CONVOLUTION_BLUE_BIAS
                case GL_POST_CONVOLUTION_BLUE_BIAS:
                    return {s_POST_CONVOLUTION_BLUE_BIAS, 26};
#endif
#ifdef GL_POST_CONVOLUTION_BLUE_SCALE
                case GL_POST_CONVOLUTION_BLUE_SCALE:
                    return {s_POST_CONVOLUTION_BLUE_SCALE, 27};
#endif
#ifdef GL_POST_CONVOLUTION_GREEN_BIAS
                case GL_POST_CONVOLUTION_GREEN_BIAS:
                    return {s_POST_CONVOLUTION_GREEN_BIAS, 27};
#endif
#ifdef GL_POST_CONVOLUTION_GREEN_SCALE
                case GL_POST_CONVOLUTION_GREEN_SCALE:
                    return {s_POST_CONVOLUTION_GREEN_SCALE, 28};
#endif
#ifdef GL_POST_CONVOLUTION_RED_BIAS
                case GL_POST_CONVOLUTION_RED_BIAS:
                    return {s_POST_CONVOLUTION_RED_BIAS, 25};
#endif
#ifdef GL_POST_CONVOLUTION_RED_SCALE
                case GL_POST_CONVOLUTION_RED_SCALE:
                    return {s_POST_CONVOLUTION_RED_SCALE, 26};
#endif
#ifdef GL_RED_BIAS
                case GL_RED_BIAS:
                    return {s_RED_BIAS, 8};
#endif
#ifdef GL_RED_SCALE
                case GL_RED_SCALE:
                    return {s_RED_SCALE, 9};
#endif
                default:;
            }
            break;
        case 80: /* point_parameter */
            switch(GLenum(aev._value)) {
#ifdef GL_POINT_FADE_THRESHOLD_SIZE
                case GL_POINT_FADE_THRESHOLD_SIZE:
                    return {s_POINT_FADE_THRESHOLD_SIZE, 25};
#endif
#ifdef GL_POINT_SIZE_MAX
                case GL_POINT_SIZE_MAX:
                    return {s_POINT_SIZE_MAX, 14};
#endif
#ifdef GL_POINT_SIZE_MIN
                case GL_POINT_SIZE_MIN:
                    return {s_POINT_SIZE_MIN, 14};
#endif
#ifdef GL_POINT_SPRITE_COORD_ORIGIN
                case GL_POINT_SPRITE_COORD_ORIGIN:
                    return {s_POINT_SPRITE_COORD_ORIGIN, 25};
#endif
                default:;
            }
            break;
        case 81: /* polygon_mode */
            switch(GLenum(aev._value)) {
#ifdef GL_FILL
                case GL_FILL:
                    return {s_FILL, 4};
#endif
#ifdef GL_FILL_RECTANGLE_NV
                case GL_FILL_RECTANGLE_NV:
                    return {s_FILL_RECTANGLE_NV, 17};
#endif
#ifdef GL_LINE
                case GL_LINE:
                    return {s_LINE, 4};
#endif
#ifdef GL_POINT
                case GL_POINT:
                    return {s_POINT, 5};
#endif
                default:;
            }
            break;
        case 82: /* precision_type */
            switch(GLenum(aev._value)) {
#ifdef GL_HIGH_FLOAT
                case GL_HIGH_FLOAT:
                    return {s_HIGH_FLOAT, 10};
#endif
#ifdef GL_HIGH_INT
                case GL_HIGH_INT:
                    return {s_HIGH_INT, 8};
#endif
#ifdef GL_LOW_FLOAT
                case GL_LOW_FLOAT:
                    return {s_LOW_FLOAT, 9};
#endif
#ifdef GL_LOW_INT
                case GL_LOW_INT:
                    return {s_LOW_INT, 7};
#endif
#ifdef GL_MEDIUM_FLOAT
                case GL_MEDIUM_FLOAT:
                    return {s_MEDIUM_FLOAT, 12};
#endif
#ifdef GL_MEDIUM_INT
                case GL_MEDIUM_INT:
                    return {s_MEDIUM_INT, 10};
#endif
                default:;
            }
            break;
        case 83: /* primitive_type */
            switch(GLenum(aev._value)) {
#ifdef GL_LINES
                case GL_LINES:
                    return {s_LINES, 5};
#endif
#ifdef GL_LINES_ADJACENCY
                case GL_LINES_ADJACENCY:
                    return {s_LINES_ADJACENCY, 15};
#endif
#ifdef GL_LINE_LOOP
                case GL_LINE_LOOP:
                    return {s_LINE_LOOP, 9};
#endif
#ifdef GL_LINE_STRIP
                case GL_LINE_STRIP:
                    return {s_LINE_STRIP, 10};
#endif
#ifdef GL_LINE_STRIP_ADJACENCY
                case GL_LINE_STRIP_ADJACENCY:
                    return {s_LINE_STRIP_ADJACENCY, 20};
#endif
#ifdef GL_PATCHES
                case GL_PATCHES:
                    return {s_PATCHES, 7};
#endif
#ifdef GL_POINTS
                case GL_POINTS:
                    return {s_POINTS, 6};
#endif
#ifdef GL_TRIANGLES
                case GL_TRIANGLES:
                    return {s_TRIANGLES, 9};
#endif
#ifdef GL_TRIANGLES_ADJACENCY
                case GL_TRIANGLES_ADJACENCY:
                    return {s_TRIANGLES_ADJACENCY, 19};
#endif
#ifdef GL_TRIANGLE_FAN
                case GL_TRIANGLE_FAN:
                    return {s_TRIANGLE_FAN, 12};
#endif
#ifdef GL_TRIANGLE_STRIP
                case GL_TRIANGLE_STRIP:
                    return {s_TRIANGLE_STRIP, 14};
#endif
#ifdef GL_TRIANGLE_STRIP_ADJACENCY
                case GL_TRIANGLE_STRIP_ADJACENCY:
                    return {s_TRIANGLE_STRIP_ADJACENCY, 24};
#endif
                default:;
            }
            break;
        case 84: /* program_interface */
            switch(GLenum(aev._value)) {
#ifdef GL_ATOMIC_COUNTER_BUFFER
                case GL_ATOMIC_COUNTER_BUFFER:
                    return {s_ATOMIC_COUNTER_BUFFER, 21};
#endif
#ifdef GL_BUFFER_VARIABLE
                case GL_BUFFER_VARIABLE:
                    return {s_BUFFER_VARIABLE, 15};
#endif
#ifdef GL_COMPUTE_SUBROUTINE
                case GL_COMPUTE_SUBROUTINE:
                    return {s_COMPUTE_SUBROUTINE, 18};
#endif
#ifdef GL_COMPUTE_SUBROUTINE_UNIFORM
                case GL_COMPUTE_SUBROUTINE_UNIFORM:
                    return {s_COMPUTE_SUBROUTINE_UNIFORM, 26};
#endif
#ifdef GL_FRAGMENT_SUBROUTINE
                case GL_FRAGMENT_SUBROUTINE:
                    return {s_FRAGMENT_SUBROUTINE, 19};
#endif
#ifdef GL_FRAGMENT_SUBROUTINE_UNIFORM
                case GL_FRAGMENT_SUBROUTINE_UNIFORM:
                    return {s_FRAGMENT_SUBROUTINE_UNIFORM, 27};
#endif
#ifdef GL_GEOMETRY_SUBROUTINE
                case GL_GEOMETRY_SUBROUTINE:
                    return {s_GEOMETRY_SUBROUTINE, 19};
#endif
#ifdef GL_GEOMETRY_SUBROUTINE_UNIFORM
                case GL_GEOMETRY_SUBROUTINE_UNIFORM:
                    return {s_GEOMETRY_SUBROUTINE_UNIFORM, 27};
#endif
#ifdef GL_PROGRAM_INPUT
                case GL_PROGRAM_INPUT:
                    return {s_PROGRAM_INPUT, 13};
#endif
#ifdef GL_PROGRAM_OUTPUT
                case GL_PROGRAM_OUTPUT:
                    return {s_PROGRAM_OUTPUT, 14};
#endif
#ifdef GL_SHADER_STORAGE_BLOCK
                case GL_SHADER_STORAGE_BLOCK:
                    return {s_SHADER_STORAGE_BLOCK, 20};
#endif
#ifdef GL_TESS_CONTROL_SUBROUTINE
                case GL_TESS_CONTROL_SUBROUTINE:
                    return {s_TESS_CONTROL_SUBROUTINE, 23};
#endif
#ifdef GL_TESS_CONTROL_SUBROUTINE_UNIFORM
                case GL_TESS_CONTROL_SUBROUTINE_UNIFORM:
                    return {s_TESS_CONTROL_SUBROUTINE_UNIFORM, 31};
#endif
#ifdef GL_TESS_EVALUATION_SUBROUTINE
                case GL_TESS_EVALUATION_SUBROUTINE:
                    return {s_TESS_EVALUATION_SUBROUTINE, 26};
#endif
#ifdef GL_TESS_EVALUATION_SUBROUTINE_UNIFORM
                case GL_TESS_EVALUATION_SUBROUTINE_UNIFORM:
                    return {s_TESS_EVALUATION_SUBROUTINE_UNIFORM, 34};
#endif
#ifdef GL_TRANSFORM_FEEDEBACK_VARYING
                case GL_TRANSFORM_FEEDEBACK_VARYING:
                    return {s_TRANSFORM_FEEDEBACK_VARYING, 27};
#endif
#ifdef GL_UNIFORM
                case GL_UNIFORM:
                    return {s_UNIFORM, 7};
#endif
#ifdef GL_UNIFORM_BLOCK
                case GL_UNIFORM_BLOCK:
                    return {s_UNIFORM_BLOCK, 13};
#endif
#ifdef GL_VERTEX_SUBROUTINE
                case GL_VERTEX_SUBROUTINE:
                    return {s_VERTEX_SUBROUTINE, 17};
#endif
#ifdef GL_VERTEX_SUBROUTINE_UNIFORM
                case GL_VERTEX_SUBROUTINE_UNIFORM:
                    return {s_VERTEX_SUBROUTINE_UNIFORM, 25};
#endif
                default:;
            }
            break;
        case 85: /* program_parameter */
            switch(GLenum(aev._value)) {
#ifdef GL_ACTIVE_ATOMIC_COUNTER_BUFFERS
                case GL_ACTIVE_ATOMIC_COUNTER_BUFFERS:
                    return {s_ACTIVE_ATOMIC_COUNTER_BUFFERS, 29};
#endif
#ifdef GL_ACTIVE_ATTRIBUTES
                case GL_ACTIVE_ATTRIBUTES:
                    return {s_ACTIVE_ATTRIBUTES, 17};
#endif
#ifdef GL_ACTIVE_ATTRIBUTE_MAX_LENGTH
                case GL_ACTIVE_ATTRIBUTE_MAX_LENGTH:
                    return {s_ACTIVE_ATTRIBUTE_MAX_LENGTH, 27};
#endif
#ifdef GL_ACTIVE_UNIFORMS
                case GL_ACTIVE_UNIFORMS:
                    return {s_ACTIVE_UNIFORMS, 15};
#endif
#ifdef GL_ACTIVE_UNIFORM_MAX_LENGTH
                case GL_ACTIVE_UNIFORM_MAX_LENGTH:
                    return {s_ACTIVE_UNIFORM_MAX_LENGTH, 25};
#endif
#ifdef GL_ATTACHED_SHADERS
                case GL_ATTACHED_SHADERS:
                    return {s_ATTACHED_SHADERS, 16};
#endif
#ifdef GL_COMPUTE_WORK_GROUP_SIZE
                case GL_COMPUTE_WORK_GROUP_SIZE:
                    return {s_COMPUTE_WORK_GROUP_SIZE, 23};
#endif
#ifdef GL_DELETE_STATUS
                case GL_DELETE_STATUS:
                    return {s_DELETE_STATUS, 13};
#endif
#ifdef GL_GEOMETRY_INPUT_TYPE
                case GL_GEOMETRY_INPUT_TYPE:
                    return {s_GEOMETRY_INPUT_TYPE, 19};
#endif
#ifdef GL_GEOMETRY_OUTPUT_TYPE
                case GL_GEOMETRY_OUTPUT_TYPE:
                    return {s_GEOMETRY_OUTPUT_TYPE, 20};
#endif
#ifdef GL_GEOMETRY_VERTICES_OUT
                case GL_GEOMETRY_VERTICES_OUT:
                    return {s_GEOMETRY_VERTICES_OUT, 21};
#endif
#ifdef GL_INFO_LOG_LENGTH
                case GL_INFO_LOG_LENGTH:
                    return {s_INFO_LOG_LENGTH, 15};
#endif
#ifdef GL_LINK_STATUS
                case GL_LINK_STATUS:
                    return {s_LINK_STATUS, 11};
#endif
#ifdef GL_PROGRAM_BINARY_LENGTH
                case GL_PROGRAM_BINARY_LENGTH:
                    return {s_PROGRAM_BINARY_LENGTH, 21};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_MODE
                case GL_TRANSFORM_FEEDBACK_BUFFER_MODE:
                    return {s_TRANSFORM_FEEDBACK_BUFFER_MODE, 30};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_VARYINGS
                case GL_TRANSFORM_FEEDBACK_VARYINGS:
                    return {s_TRANSFORM_FEEDBACK_VARYINGS, 27};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH
                case GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH:
                    return {s_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, 37};
#endif
#ifdef GL_VALIDATE_STATUS
                case GL_VALIDATE_STATUS:
                    return {s_VALIDATE_STATUS, 15};
#endif
                default:;
            }
            break;
        case 86: /* program_pipeline_parameter */
            switch(GLenum(aev._value)) {
#ifdef GL_ACTIVE_PROGRAM
                case GL_ACTIVE_PROGRAM:
                    return {s_ACTIVE_PROGRAM, 14};
#endif
#ifdef GL_FRAGMENT_SHADER
                case GL_FRAGMENT_SHADER:
                    return {s_FRAGMENT_SHADER, 15};
#endif
#ifdef GL_GEOMETRY_SHADER
                case GL_GEOMETRY_SHADER:
                    return {s_GEOMETRY_SHADER, 15};
#endif
#ifdef GL_INFO_LOG_LENGTH
                case GL_INFO_LOG_LENGTH:
                    return {s_INFO_LOG_LENGTH, 15};
#endif
#ifdef GL_TESS_CONTROL_SHADER
                case GL_TESS_CONTROL_SHADER:
                    return {s_TESS_CONTROL_SHADER, 19};
#endif
#ifdef GL_TESS_EVALUATION_SHADER
                case GL_TESS_EVALUATION_SHADER:
                    return {s_TESS_EVALUATION_SHADER, 22};
#endif
#ifdef GL_VERTEX_SHADER
                case GL_VERTEX_SHADER:
                    return {s_VERTEX_SHADER, 13};
#endif
                default:;
            }
            break;
        case 87: /* program_pipeline_stage */
            switch(GLbitfield(aev._value)) {
#ifdef GL_ALL_SHADER_BITS
                case GL_ALL_SHADER_BITS:
                    return {s_ALL_SHADER_BITS, 15};
#endif
#ifdef GL_COMPUTE_SHADER_BIT
                case GL_COMPUTE_SHADER_BIT:
                    return {s_COMPUTE_SHADER_BIT, 18};
#endif
#ifdef GL_FRAGMENT_SHADER_BIT
                case GL_FRAGMENT_SHADER_BIT:
                    return {s_FRAGMENT_SHADER_BIT, 19};
#endif
#ifdef GL_GEOMETRY_SHADER_BIT
                case GL_GEOMETRY_SHADER_BIT:
                    return {s_GEOMETRY_SHADER_BIT, 19};
#endif
#ifdef GL_TESS_CONTROL_SHADER_BIT
                case GL_TESS_CONTROL_SHADER_BIT:
                    return {s_TESS_CONTROL_SHADER_BIT, 23};
#endif
#ifdef GL_TESS_EVALUATION_SHADER_BIT
                case GL_TESS_EVALUATION_SHADER_BIT:
                    return {s_TESS_EVALUATION_SHADER_BIT, 26};
#endif
#ifdef GL_VERTEX_SHADER_BIT
                case GL_VERTEX_SHADER_BIT:
                    return {s_VERTEX_SHADER_BIT, 17};
#endif
                default:;
            }
            break;
        case 88: /* program_resource_property */
            switch(GLenum(aev._value)) {
#ifdef GL_ACTIVE_VARIABLES
                case GL_ACTIVE_VARIABLES:
                    return {s_ACTIVE_VARIABLES, 16};
#endif
#ifdef GL_ARRAY_SIZE
                case GL_ARRAY_SIZE:
                    return {s_ARRAY_SIZE, 10};
#endif
#ifdef GL_ARRAY_STRIDE
                case GL_ARRAY_STRIDE:
                    return {s_ARRAY_STRIDE, 12};
#endif
#ifdef GL_ATOMIC_COUNTER_BUFFER_INDEX
                case GL_ATOMIC_COUNTER_BUFFER_INDEX:
                    return {s_ATOMIC_COUNTER_BUFFER_INDEX, 27};
#endif
#ifdef GL_BLOCK_INDEX
                case GL_BLOCK_INDEX:
                    return {s_BLOCK_INDEX, 11};
#endif
#ifdef GL_BUFFER_BINDING
                case GL_BUFFER_BINDING:
                    return {s_BUFFER_BINDING, 14};
#endif
#ifdef GL_BUFFER_DATA_SIZE
                case GL_BUFFER_DATA_SIZE:
                    return {s_BUFFER_DATA_SIZE, 16};
#endif
#ifdef GL_COMPATIBLE_SUBROUTINES
                case GL_COMPATIBLE_SUBROUTINES:
                    return {s_COMPATIBLE_SUBROUTINES, 22};
#endif
#ifdef GL_IS_PER_PATCH
                case GL_IS_PER_PATCH:
                    return {s_IS_PER_PATCH, 12};
#endif
#ifdef GL_IS_ROW_MAJOR
                case GL_IS_ROW_MAJOR:
                    return {s_IS_ROW_MAJOR, 12};
#endif
#ifdef GL_LOCATION
                case GL_LOCATION:
                    return {s_LOCATION, 8};
#endif
#ifdef GL_LOCATION_COMPONENT
                case GL_LOCATION_COMPONENT:
                    return {s_LOCATION_COMPONENT, 18};
#endif
#ifdef GL_LOCATION_INDEX
                case GL_LOCATION_INDEX:
                    return {s_LOCATION_INDEX, 14};
#endif
#ifdef GL_MATRIX_STRIDE
                case GL_MATRIX_STRIDE:
                    return {s_MATRIX_STRIDE, 13};
#endif
#ifdef GL_NUM_ACTIVE_VARIABLES
                case GL_NUM_ACTIVE_VARIABLES:
                    return {s_NUM_ACTIVE_VARIABLES, 20};
#endif
#ifdef GL_NUM_COMPATIBLE_SUBROUTINES
                case GL_NUM_COMPATIBLE_SUBROUTINES:
                    return {s_NUM_COMPATIBLE_SUBROUTINES, 26};
#endif
#ifdef GL_OFFSET
                case GL_OFFSET:
                    return {s_OFFSET, 6};
#endif
#ifdef GL_REFERENCED_BY_COMPUTE_SHADER
                case GL_REFERENCED_BY_COMPUTE_SHADER:
                    return {s_REFERENCED_BY_COMPUTE_SHADER, 28};
#endif
#ifdef GL_REFERENCED_BY_FRAGMENT_SHADER
                case GL_REFERENCED_BY_FRAGMENT_SHADER:
                    return {s_REFERENCED_BY_FRAGMENT_SHADER, 29};
#endif
#ifdef GL_REFERENCED_BY_GEOMETRY_SHADER
                case GL_REFERENCED_BY_GEOMETRY_SHADER:
                    return {s_REFERENCED_BY_GEOMETRY_SHADER, 29};
#endif
#ifdef GL_REFERENCED_BY_TESS_CONTROL_SHADER
                case GL_REFERENCED_BY_TESS_CONTROL_SHADER:
                    return {s_REFERENCED_BY_TESS_CONTROL_SHADER, 33};
#endif
#ifdef GL_REFERENCED_BY_TESS_EVALUATION_SHADER
                case GL_REFERENCED_BY_TESS_EVALUATION_SHADER:
                    return {s_REFERENCED_BY_TESS_EVALUATION_SHADER, 36};
#endif
#ifdef GL_REFERENCED_BY_VERTEX_SHADER
                case GL_REFERENCED_BY_VERTEX_SHADER:
                    return {s_REFERENCED_BY_VERTEX_SHADER, 27};
#endif
#ifdef GL_TOP_LEVEL_ARRAY_SIZE
                case GL_TOP_LEVEL_ARRAY_SIZE:
                    return {s_TOP_LEVEL_ARRAY_SIZE, 20};
#endif
#ifdef GL_TOP_LEVEL_ARRAY_STRIDE
                case GL_TOP_LEVEL_ARRAY_STRIDE:
                    return {s_TOP_LEVEL_ARRAY_STRIDE, 22};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_INDEX
                case GL_TRANSFORM_FEEDBACK_BUFFER_INDEX:
                    return {s_TRANSFORM_FEEDBACK_BUFFER_INDEX, 31};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE
                case GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE:
                    return {s_TRANSFORM_FEEDBACK_BUFFER_STRIDE, 32};
#endif
                default:;
            }
            break;
        case 89: /* provoke_mode */
            switch(GLenum(aev._value)) {
#ifdef GL_FIRST_VERTEX_CONVENTION
                case GL_FIRST_VERTEX_CONVENTION:
                    return {s_FIRST_VERTEX_CONVENTION, 23};
#endif
#ifdef GL_LAST_VERTEX_CONVENTION
                case GL_LAST_VERTEX_CONVENTION:
                    return {s_LAST_VERTEX_CONVENTION, 22};
#endif
                default:;
            }
            break;
        case 90: /* query_parameter */
            switch(GLenum(aev._value)) {
#ifdef GL_QUERY_RESULT
                case GL_QUERY_RESULT:
                    return {s_QUERY_RESULT, 12};
#endif
#ifdef GL_QUERY_RESULT_AVAILABLE
                case GL_QUERY_RESULT_AVAILABLE:
                    return {s_QUERY_RESULT_AVAILABLE, 22};
#endif
                default:;
            }
            break;
        case 91: /* query_target */
            switch(GLenum(aev._value)) {
#ifdef GL_ANY_SAMPLES_PASSED
                case GL_ANY_SAMPLES_PASSED:
                    return {s_ANY_SAMPLES_PASSED, 18};
#endif
#ifdef GL_ANY_SAMPLES_PASSED_CONSERVATIVE
                case GL_ANY_SAMPLES_PASSED_CONSERVATIVE:
                    return {s_ANY_SAMPLES_PASSED_CONSERVATIVE, 31};
#endif
#ifdef GL_CLIPPING_INPUT_PRIMITIVES_ARB
                case GL_CLIPPING_INPUT_PRIMITIVES_ARB:
                    return {s_CLIPPING_INPUT_PRIMITIVES_ARB, 29};
#endif
#ifdef GL_CLIPPING_OUTPUT_PRIMITIVES_ARB
                case GL_CLIPPING_OUTPUT_PRIMITIVES_ARB:
                    return {s_CLIPPING_OUTPUT_PRIMITIVES_ARB, 30};
#endif
#ifdef GL_COMPUTE_SHADER_INVOCATIONS_ARB
                case GL_COMPUTE_SHADER_INVOCATIONS_ARB:
                    return {s_COMPUTE_SHADER_INVOCATIONS_ARB, 30};
#endif
#ifdef GL_FRAGMENT_SHADER_INVOCATIONS_ARB
                case GL_FRAGMENT_SHADER_INVOCATIONS_ARB:
                    return {s_FRAGMENT_SHADER_INVOCATIONS_ARB, 31};
#endif
#ifdef GL_GEOMETRY_SHADER_INVOCATIONS
                case GL_GEOMETRY_SHADER_INVOCATIONS:
                    return {s_GEOMETRY_SHADER_INVOCATIONS, 27};
#endif
#ifdef GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED_ARB
                case GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED_ARB:
                    return {s_GEOMETRY_SHADER_PRIMITIVES_EMITTED_ARB, 38};
#endif
#ifdef GL_PRIMITIVES_GENERATED
                case GL_PRIMITIVES_GENERATED:
                    return {s_PRIMITIVES_GENERATED, 20};
#endif
#ifdef GL_PRIMITIVES_SUBMITTED_ARB
                case GL_PRIMITIVES_SUBMITTED_ARB:
                    return {s_PRIMITIVES_SUBMITTED_ARB, 24};
#endif
#ifdef GL_SAMPLES_PASSED
                case GL_SAMPLES_PASSED:
                    return {s_SAMPLES_PASSED, 14};
#endif
#ifdef GL_TESS_CONTROL_SHADER_PATCHES_ARB
                case GL_TESS_CONTROL_SHADER_PATCHES_ARB:
                    return {s_TESS_CONTROL_SHADER_PATCHES_ARB, 31};
#endif
#ifdef GL_TESS_EVALUATION_SHADER_INVOCATIONS_ARB
                case GL_TESS_EVALUATION_SHADER_INVOCATIONS_ARB:
                    return {s_TESS_EVALUATION_SHADER_INVOCATIONS_ARB, 38};
#endif
#ifdef GL_TIMESTAMP
                case GL_TIMESTAMP:
                    return {s_TIMESTAMP, 9};
#endif
#ifdef GL_TIME_ELAPSED
                case GL_TIME_ELAPSED:
                    return {s_TIME_ELAPSED, 12};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_OVERFLOW_ARB
                case GL_TRANSFORM_FEEDBACK_OVERFLOW_ARB:
                    return {s_TRANSFORM_FEEDBACK_OVERFLOW_ARB, 31};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
                case GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:
                    return {s_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, 37};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW_ARB
                case GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW_ARB:
                    return {s_TRANSFORM_FEEDBACK_STREAM_OVERFLOW_ARB, 38};
#endif
#ifdef GL_VERTEX_SHADER_INVOCATIONS_ARB
                case GL_VERTEX_SHADER_INVOCATIONS_ARB:
                    return {s_VERTEX_SHADER_INVOCATIONS_ARB, 29};
#endif
#ifdef GL_VERTICES_SUBMITTED_ARB
                case GL_VERTICES_SUBMITTED_ARB:
                    return {s_VERTICES_SUBMITTED_ARB, 22};
#endif
                default:;
            }
            break;
        case 92: /* renderbuffer_parameter */
            switch(GLenum(aev._value)) {
#ifdef GL_RENDERBUFFER_ALPHA_SIZE
                case GL_RENDERBUFFER_ALPHA_SIZE:
                    return {s_RENDERBUFFER_ALPHA_SIZE, 23};
#endif
#ifdef GL_RENDERBUFFER_BLUE_SIZE
                case GL_RENDERBUFFER_BLUE_SIZE:
                    return {s_RENDERBUFFER_BLUE_SIZE, 22};
#endif
#ifdef GL_RENDERBUFFER_DEPTH_SIZE
                case GL_RENDERBUFFER_DEPTH_SIZE:
                    return {s_RENDERBUFFER_DEPTH_SIZE, 23};
#endif
#ifdef GL_RENDERBUFFER_GREEN_SIZE
                case GL_RENDERBUFFER_GREEN_SIZE:
                    return {s_RENDERBUFFER_GREEN_SIZE, 23};
#endif
#ifdef GL_RENDERBUFFER_HEIGHT
                case GL_RENDERBUFFER_HEIGHT:
                    return {s_RENDERBUFFER_HEIGHT, 19};
#endif
#ifdef GL_RENDERBUFFER_INTERNAL_FORMAT
                case GL_RENDERBUFFER_INTERNAL_FORMAT:
                    return {s_RENDERBUFFER_INTERNAL_FORMAT, 28};
#endif
#ifdef GL_RENDERBUFFER_RED_SIZE
                case GL_RENDERBUFFER_RED_SIZE:
                    return {s_RENDERBUFFER_RED_SIZE, 21};
#endif
#ifdef GL_RENDERBUFFER_SAMPLES
                case GL_RENDERBUFFER_SAMPLES:
                    return {s_RENDERBUFFER_SAMPLES, 20};
#endif
#ifdef GL_RENDERBUFFER_STENCIL_SIZE
                case GL_RENDERBUFFER_STENCIL_SIZE:
                    return {s_RENDERBUFFER_STENCIL_SIZE, 25};
#endif
#ifdef GL_RENDERBUFFER_WIDTH
                case GL_RENDERBUFFER_WIDTH:
                    return {s_RENDERBUFFER_WIDTH, 18};
#endif
                default:;
            }
            break;
        case 93: /* renderbuffer_target */
            switch(GLenum(aev._value)) {
#ifdef GL_RENDERBUFFER
                case GL_RENDERBUFFER:
                    return {s_RENDERBUFFER, 12};
#endif
                default:;
            }
            break;
        case 94: /* reset_notification_strategy */
            switch(GLenum(aev._value)) {
#ifdef GL_LOSE_CONTEXT_ON_RESET
                case GL_LOSE_CONTEXT_ON_RESET:
                    return {s_LOSE_CONTEXT_ON_RESET, 21};
#endif
#ifdef GL_NO_RESET_NOTIFICATION
                case GL_NO_RESET_NOTIFICATION:
                    return {s_NO_RESET_NOTIFICATION, 21};
#endif
                default:;
            }
            break;
        case 95: /* sampler_parameter */
            switch(GLenum(aev._value)) {
#ifdef GL_TEXTURE_BORDER_COLOR
                case GL_TEXTURE_BORDER_COLOR:
                    return {s_TEXTURE_BORDER_COLOR, 20};
#endif
#ifdef GL_TEXTURE_COMPARE_FUNC
                case GL_TEXTURE_COMPARE_FUNC:
                    return {s_TEXTURE_COMPARE_FUNC, 20};
#endif
#ifdef GL_TEXTURE_COMPARE_MODE
                case GL_TEXTURE_COMPARE_MODE:
                    return {s_TEXTURE_COMPARE_MODE, 20};
#endif
#ifdef GL_TEXTURE_LOD_BIAS
                case GL_TEXTURE_LOD_BIAS:
                    return {s_TEXTURE_LOD_BIAS, 16};
#endif
#ifdef GL_TEXTURE_MAG_FILTER
                case GL_TEXTURE_MAG_FILTER:
                    return {s_TEXTURE_MAG_FILTER, 18};
#endif
#ifdef GL_TEXTURE_MAX_LOD
                case GL_TEXTURE_MAX_LOD:
                    return {s_TEXTURE_MAX_LOD, 15};
#endif
#ifdef GL_TEXTURE_MIN_FILTER
                case GL_TEXTURE_MIN_FILTER:
                    return {s_TEXTURE_MIN_FILTER, 18};
#endif
#ifdef GL_TEXTURE_MIN_LOD
                case GL_TEXTURE_MIN_LOD:
                    return {s_TEXTURE_MIN_LOD, 15};
#endif
#ifdef GL_TEXTURE_WRAP_R
                case GL_TEXTURE_WRAP_R:
                    return {s_TEXTURE_WRAP_R, 14};
#endif
#ifdef GL_TEXTURE_WRAP_S
                case GL_TEXTURE_WRAP_S:
                    return {s_TEXTURE_WRAP_S, 14};
#endif
#ifdef GL_TEXTURE_WRAP_T
                case GL_TEXTURE_WRAP_T:
                    return {s_TEXTURE_WRAP_T, 14};
#endif
                default:;
            }
            break;
        case 96: /* shader_parameter */
            switch(GLenum(aev._value)) {
#ifdef GL_COMPILE_STATUS
                case GL_COMPILE_STATUS:
                    return {s_COMPILE_STATUS, 14};
#endif
#ifdef GL_DELETE_STATUS
                case GL_DELETE_STATUS:
                    return {s_DELETE_STATUS, 13};
#endif
#ifdef GL_INFO_LOG_LENGTH
                case GL_INFO_LOG_LENGTH:
                    return {s_INFO_LOG_LENGTH, 15};
#endif
#ifdef GL_SHADER_SOURCE_LENGTH
                case GL_SHADER_SOURCE_LENGTH:
                    return {s_SHADER_SOURCE_LENGTH, 20};
#endif
#ifdef GL_SHADER_TYPE
                case GL_SHADER_TYPE:
                    return {s_SHADER_TYPE, 11};
#endif
                default:;
            }
            break;
        case 97: /* shader_type */
            switch(GLenum(aev._value)) {
#ifdef GL_COMPUTE_SHADER
                case GL_COMPUTE_SHADER:
                    return {s_COMPUTE_SHADER, 14};
#endif
#ifdef GL_FRAGMENT_SHADER
                case GL_FRAGMENT_SHADER:
                    return {s_FRAGMENT_SHADER, 15};
#endif
#ifdef GL_GEOMETRY_SHADER
                case GL_GEOMETRY_SHADER:
                    return {s_GEOMETRY_SHADER, 15};
#endif
#ifdef GL_TESS_CONTROL_SHADER
                case GL_TESS_CONTROL_SHADER:
                    return {s_TESS_CONTROL_SHADER, 19};
#endif
#ifdef GL_TESS_EVALUATION_SHADER
                case GL_TESS_EVALUATION_SHADER:
                    return {s_TESS_EVALUATION_SHADER, 22};
#endif
#ifdef GL_VERTEX_SHADER
                case GL_VERTEX_SHADER:
                    return {s_VERTEX_SHADER, 13};
#endif
                default:;
            }
            break;
        case 98: /* single_face */
            switch(GLenum(aev._value)) {
#ifdef GL_BACK
                case GL_BACK:
                    return {s_BACK, 4};
#endif
#ifdef GL_FRONT
                case GL_FRONT:
                    return {s_FRONT, 5};
#endif
                default:;
            }
            break;
        case 99: /* sl_data_type */
            switch(GLenum(aev._value)) {
#ifdef GL_BOOL
                case GL_BOOL:
                    return {s_BOOL, 4};
#endif
#ifdef GL_BOOL_VEC2
                case GL_BOOL_VEC2:
                    return {s_BOOL_VEC2, 9};
#endif
#ifdef GL_BOOL_VEC3
                case GL_BOOL_VEC3:
                    return {s_BOOL_VEC3, 9};
#endif
#ifdef GL_BOOL_VEC4
                case GL_BOOL_VEC4:
                    return {s_BOOL_VEC4, 9};
#endif
#ifdef GL_DOUBLE
                case GL_DOUBLE:
                    return {s_DOUBLE, 6};
#endif
#ifdef GL_DOUBLE_MAT2
                case GL_DOUBLE_MAT2:
                    return {s_DOUBLE_MAT2, 11};
#endif
#ifdef GL_DOUBLE_MAT2x3
                case GL_DOUBLE_MAT2x3:
                    return {s_DOUBLE_MAT2x3, 13};
#endif
#ifdef GL_DOUBLE_MAT2x4
                case GL_DOUBLE_MAT2x4:
                    return {s_DOUBLE_MAT2x4, 13};
#endif
#ifdef GL_DOUBLE_MAT3
                case GL_DOUBLE_MAT3:
                    return {s_DOUBLE_MAT3, 11};
#endif
#ifdef GL_DOUBLE_MAT3x2
                case GL_DOUBLE_MAT3x2:
                    return {s_DOUBLE_MAT3x2, 13};
#endif
#ifdef GL_DOUBLE_MAT3x4
                case GL_DOUBLE_MAT3x4:
                    return {s_DOUBLE_MAT3x4, 13};
#endif
#ifdef GL_DOUBLE_MAT4
                case GL_DOUBLE_MAT4:
                    return {s_DOUBLE_MAT4, 11};
#endif
#ifdef GL_DOUBLE_MAT4x2
                case GL_DOUBLE_MAT4x2:
                    return {s_DOUBLE_MAT4x2, 13};
#endif
#ifdef GL_DOUBLE_MAT4x3
                case GL_DOUBLE_MAT4x3:
                    return {s_DOUBLE_MAT4x3, 13};
#endif
#ifdef GL_DOUBLE_VEC2
                case GL_DOUBLE_VEC2:
                    return {s_DOUBLE_VEC2, 11};
#endif
#ifdef GL_DOUBLE_VEC3
                case GL_DOUBLE_VEC3:
                    return {s_DOUBLE_VEC3, 11};
#endif
#ifdef GL_DOUBLE_VEC4
                case GL_DOUBLE_VEC4:
                    return {s_DOUBLE_VEC4, 11};
#endif
#ifdef GL_FLOAT
                case GL_FLOAT:
                    return {s_FLOAT, 5};
#endif
#ifdef GL_FLOAT_MAT2
                case GL_FLOAT_MAT2:
                    return {s_FLOAT_MAT2, 10};
#endif
#ifdef GL_FLOAT_MAT2x3
                case GL_FLOAT_MAT2x3:
                    return {s_FLOAT_MAT2x3, 12};
#endif
#ifdef GL_FLOAT_MAT2x4
                case GL_FLOAT_MAT2x4:
                    return {s_FLOAT_MAT2x4, 12};
#endif
#ifdef GL_FLOAT_MAT3
                case GL_FLOAT_MAT3:
                    return {s_FLOAT_MAT3, 10};
#endif
#ifdef GL_FLOAT_MAT3x2
                case GL_FLOAT_MAT3x2:
                    return {s_FLOAT_MAT3x2, 12};
#endif
#ifdef GL_FLOAT_MAT3x4
                case GL_FLOAT_MAT3x4:
                    return {s_FLOAT_MAT3x4, 12};
#endif
#ifdef GL_FLOAT_MAT4
                case GL_FLOAT_MAT4:
                    return {s_FLOAT_MAT4, 10};
#endif
#ifdef GL_FLOAT_MAT4x2
                case GL_FLOAT_MAT4x2:
                    return {s_FLOAT_MAT4x2, 12};
#endif
#ifdef GL_FLOAT_MAT4x3
                case GL_FLOAT_MAT4x3:
                    return {s_FLOAT_MAT4x3, 12};
#endif
#ifdef GL_FLOAT_VEC2
                case GL_FLOAT_VEC2:
                    return {s_FLOAT_VEC2, 10};
#endif
#ifdef GL_FLOAT_VEC3
                case GL_FLOAT_VEC3:
                    return {s_FLOAT_VEC3, 10};
#endif
#ifdef GL_FLOAT_VEC4
                case GL_FLOAT_VEC4:
                    return {s_FLOAT_VEC4, 10};
#endif
#ifdef GL_IMAGE_1D
                case GL_IMAGE_1D:
                    return {s_IMAGE_1D, 8};
#endif
#ifdef GL_IMAGE_1D_ARRAY
                case GL_IMAGE_1D_ARRAY:
                    return {s_IMAGE_1D_ARRAY, 14};
#endif
#ifdef GL_IMAGE_2D
                case GL_IMAGE_2D:
                    return {s_IMAGE_2D, 8};
#endif
#ifdef GL_IMAGE_2D_ARRAY
                case GL_IMAGE_2D_ARRAY:
                    return {s_IMAGE_2D_ARRAY, 14};
#endif
#ifdef GL_IMAGE_2D_MULTISAMPLE
                case GL_IMAGE_2D_MULTISAMPLE:
                    return {s_IMAGE_2D_MULTISAMPLE, 20};
#endif
#ifdef GL_IMAGE_2D_MULTISAMPLE_ARRAY
                case GL_IMAGE_2D_MULTISAMPLE_ARRAY:
                    return {s_IMAGE_2D_MULTISAMPLE_ARRAY, 26};
#endif
#ifdef GL_IMAGE_2D_RECT
                case GL_IMAGE_2D_RECT:
                    return {s_IMAGE_2D_RECT, 13};
#endif
#ifdef GL_IMAGE_3D
                case GL_IMAGE_3D:
                    return {s_IMAGE_3D, 8};
#endif
#ifdef GL_IMAGE_BUFFER
                case GL_IMAGE_BUFFER:
                    return {s_IMAGE_BUFFER, 12};
#endif
#ifdef GL_IMAGE_CUBE
                case GL_IMAGE_CUBE:
                    return {s_IMAGE_CUBE, 10};
#endif
#ifdef GL_INT
                case GL_INT:
                    return {s_INT, 3};
#endif
#ifdef GL_INT_IMAGE_1D
                case GL_INT_IMAGE_1D:
                    return {s_INT_IMAGE_1D, 12};
#endif
#ifdef GL_INT_IMAGE_1D_ARRAY
                case GL_INT_IMAGE_1D_ARRAY:
                    return {s_INT_IMAGE_1D_ARRAY, 18};
#endif
#ifdef GL_INT_IMAGE_2D
                case GL_INT_IMAGE_2D:
                    return {s_INT_IMAGE_2D, 12};
#endif
#ifdef GL_INT_IMAGE_2D_ARRAY
                case GL_INT_IMAGE_2D_ARRAY:
                    return {s_INT_IMAGE_2D_ARRAY, 18};
#endif
#ifdef GL_INT_IMAGE_2D_MULTISAMPLE
                case GL_INT_IMAGE_2D_MULTISAMPLE:
                    return {s_INT_IMAGE_2D_MULTISAMPLE, 24};
#endif
#ifdef GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY
                case GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY:
                    return {s_INT_IMAGE_2D_MULTISAMPLE_ARRAY, 30};
#endif
#ifdef GL_INT_IMAGE_2D_RECT
                case GL_INT_IMAGE_2D_RECT:
                    return {s_INT_IMAGE_2D_RECT, 17};
#endif
#ifdef GL_INT_IMAGE_3D
                case GL_INT_IMAGE_3D:
                    return {s_INT_IMAGE_3D, 12};
#endif
#ifdef GL_INT_IMAGE_BUFFER
                case GL_INT_IMAGE_BUFFER:
                    return {s_INT_IMAGE_BUFFER, 16};
#endif
#ifdef GL_INT_IMAGE_CUBE
                case GL_INT_IMAGE_CUBE:
                    return {s_INT_IMAGE_CUBE, 14};
#endif
#ifdef GL_INT_SAMPLER_1D
                case GL_INT_SAMPLER_1D:
                    return {s_INT_SAMPLER_1D, 14};
#endif
#ifdef GL_INT_SAMPLER_1D_ARRAY
                case GL_INT_SAMPLER_1D_ARRAY:
                    return {s_INT_SAMPLER_1D_ARRAY, 20};
#endif
#ifdef GL_INT_SAMPLER_2D
                case GL_INT_SAMPLER_2D:
                    return {s_INT_SAMPLER_2D, 14};
#endif
#ifdef GL_INT_SAMPLER_2D_ARRAY
                case GL_INT_SAMPLER_2D_ARRAY:
                    return {s_INT_SAMPLER_2D_ARRAY, 20};
#endif
#ifdef GL_INT_SAMPLER_2D_MULTISAMPLE
                case GL_INT_SAMPLER_2D_MULTISAMPLE:
                    return {s_INT_SAMPLER_2D_MULTISAMPLE, 26};
#endif
#ifdef GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY
                case GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY:
                    return {s_INT_SAMPLER_2D_MULTISAMPLE_ARRAY, 32};
#endif
#ifdef GL_INT_SAMPLER_2D_RECT
                case GL_INT_SAMPLER_2D_RECT:
                    return {s_INT_SAMPLER_2D_RECT, 19};
#endif
#ifdef GL_INT_SAMPLER_3D
                case GL_INT_SAMPLER_3D:
                    return {s_INT_SAMPLER_3D, 14};
#endif
#ifdef GL_INT_SAMPLER_BUFFER
                case GL_INT_SAMPLER_BUFFER:
                    return {s_INT_SAMPLER_BUFFER, 18};
#endif
#ifdef GL_INT_SAMPLER_CUBE
                case GL_INT_SAMPLER_CUBE:
                    return {s_INT_SAMPLER_CUBE, 16};
#endif
#ifdef GL_INT_SAMPLER_CUBE_MAP_ARRAY
                case GL_INT_SAMPLER_CUBE_MAP_ARRAY:
                    return {s_INT_SAMPLER_CUBE_MAP_ARRAY, 26};
#endif
#ifdef GL_INT_VEC2
                case GL_INT_VEC2:
                    return {s_INT_VEC2, 8};
#endif
#ifdef GL_INT_VEC3
                case GL_INT_VEC3:
                    return {s_INT_VEC3, 8};
#endif
#ifdef GL_INT_VEC4
                case GL_INT_VEC4:
                    return {s_INT_VEC4, 8};
#endif
#ifdef GL_NONE
                case GL_NONE:
                    return {s_NONE, 4};
#endif
#ifdef GL_SAMPLER_1D
                case GL_SAMPLER_1D:
                    return {s_SAMPLER_1D, 10};
#endif
#ifdef GL_SAMPLER_1D_ARRAY
                case GL_SAMPLER_1D_ARRAY:
                    return {s_SAMPLER_1D_ARRAY, 16};
#endif
#ifdef GL_SAMPLER_1D_ARRAY_SHADOW
                case GL_SAMPLER_1D_ARRAY_SHADOW:
                    return {s_SAMPLER_1D_ARRAY_SHADOW, 23};
#endif
#ifdef GL_SAMPLER_1D_SHADOW
                case GL_SAMPLER_1D_SHADOW:
                    return {s_SAMPLER_1D_SHADOW, 17};
#endif
#ifdef GL_SAMPLER_2D
                case GL_SAMPLER_2D:
                    return {s_SAMPLER_2D, 10};
#endif
#ifdef GL_SAMPLER_2D_ARRAY
                case GL_SAMPLER_2D_ARRAY:
                    return {s_SAMPLER_2D_ARRAY, 16};
#endif
#ifdef GL_SAMPLER_2D_ARRAY_SHADOW
                case GL_SAMPLER_2D_ARRAY_SHADOW:
                    return {s_SAMPLER_2D_ARRAY_SHADOW, 23};
#endif
#ifdef GL_SAMPLER_2D_MULTISAMPLE
                case GL_SAMPLER_2D_MULTISAMPLE:
                    return {s_SAMPLER_2D_MULTISAMPLE, 22};
#endif
#ifdef GL_SAMPLER_2D_MULTISAMPLE_ARRAY
                case GL_SAMPLER_2D_MULTISAMPLE_ARRAY:
                    return {s_SAMPLER_2D_MULTISAMPLE_ARRAY, 28};
#endif
#ifdef GL_SAMPLER_2D_RECT
                case GL_SAMPLER_2D_RECT:
                    return {s_SAMPLER_2D_RECT, 15};
#endif
#ifdef GL_SAMPLER_2D_RECT_SHADOW
                case GL_SAMPLER_2D_RECT_SHADOW:
                    return {s_SAMPLER_2D_RECT_SHADOW, 22};
#endif
#ifdef GL_SAMPLER_2D_SHADOW
                case GL_SAMPLER_2D_SHADOW:
                    return {s_SAMPLER_2D_SHADOW, 17};
#endif
#ifdef GL_SAMPLER_3D
                case GL_SAMPLER_3D:
                    return {s_SAMPLER_3D, 10};
#endif
#ifdef GL_SAMPLER_BUFFER
                case GL_SAMPLER_BUFFER:
                    return {s_SAMPLER_BUFFER, 14};
#endif
#ifdef GL_SAMPLER_CUBE
                case GL_SAMPLER_CUBE:
                    return {s_SAMPLER_CUBE, 12};
#endif
#ifdef GL_SAMPLER_CUBE_MAP_ARRAY
                case GL_SAMPLER_CUBE_MAP_ARRAY:
                    return {s_SAMPLER_CUBE_MAP_ARRAY, 22};
#endif
#ifdef GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW
                case GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW:
                    return {s_SAMPLER_CUBE_MAP_ARRAY_SHADOW, 29};
#endif
#ifdef GL_SAMPLER_CUBE_SHADOW
                case GL_SAMPLER_CUBE_SHADOW:
                    return {s_SAMPLER_CUBE_SHADOW, 19};
#endif
#ifdef GL_UNSIGNED_INT
                case GL_UNSIGNED_INT:
                    return {s_UNSIGNED_INT, 12};
#endif
#ifdef GL_UNSIGNED_INT_ATOMIC_COUNTER
                case GL_UNSIGNED_INT_ATOMIC_COUNTER:
                    return {s_UNSIGNED_INT_ATOMIC_COUNTER, 27};
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_1D
                case GL_UNSIGNED_INT_IMAGE_1D:
                    return {s_UNSIGNED_INT_IMAGE_1D, 21};
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_1D_ARRAY
                case GL_UNSIGNED_INT_IMAGE_1D_ARRAY:
                    return {s_UNSIGNED_INT_IMAGE_1D_ARRAY, 27};
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_2D
                case GL_UNSIGNED_INT_IMAGE_2D:
                    return {s_UNSIGNED_INT_IMAGE_2D, 21};
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_2D_ARRAY
                case GL_UNSIGNED_INT_IMAGE_2D_ARRAY:
                    return {s_UNSIGNED_INT_IMAGE_2D_ARRAY, 27};
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE
                case GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE:
                    return {s_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE, 33};
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY
                case GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY:
                    return {s_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY, 39};
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_2D_RECT
                case GL_UNSIGNED_INT_IMAGE_2D_RECT:
                    return {s_UNSIGNED_INT_IMAGE_2D_RECT, 26};
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_3D
                case GL_UNSIGNED_INT_IMAGE_3D:
                    return {s_UNSIGNED_INT_IMAGE_3D, 21};
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_BUFFER
                case GL_UNSIGNED_INT_IMAGE_BUFFER:
                    return {s_UNSIGNED_INT_IMAGE_BUFFER, 25};
#endif
#ifdef GL_UNSIGNED_INT_IMAGE_CUBE
                case GL_UNSIGNED_INT_IMAGE_CUBE:
                    return {s_UNSIGNED_INT_IMAGE_CUBE, 23};
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_1D
                case GL_UNSIGNED_INT_SAMPLER_1D:
                    return {s_UNSIGNED_INT_SAMPLER_1D, 23};
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_1D_ARRAY
                case GL_UNSIGNED_INT_SAMPLER_1D_ARRAY:
                    return {s_UNSIGNED_INT_SAMPLER_1D_ARRAY, 29};
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_2D
                case GL_UNSIGNED_INT_SAMPLER_2D:
                    return {s_UNSIGNED_INT_SAMPLER_2D, 23};
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_2D_ARRAY
                case GL_UNSIGNED_INT_SAMPLER_2D_ARRAY:
                    return {s_UNSIGNED_INT_SAMPLER_2D_ARRAY, 29};
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE
                case GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE:
                    return {s_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE, 35};
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY
                case GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY:
                    return {s_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY, 41};
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_2D_RECT
                case GL_UNSIGNED_INT_SAMPLER_2D_RECT:
                    return {s_UNSIGNED_INT_SAMPLER_2D_RECT, 28};
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_3D
                case GL_UNSIGNED_INT_SAMPLER_3D:
                    return {s_UNSIGNED_INT_SAMPLER_3D, 23};
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_BUFFER
                case GL_UNSIGNED_INT_SAMPLER_BUFFER:
                    return {s_UNSIGNED_INT_SAMPLER_BUFFER, 27};
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_CUBE
                case GL_UNSIGNED_INT_SAMPLER_CUBE:
                    return {s_UNSIGNED_INT_SAMPLER_CUBE, 25};
#endif
#ifdef GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY
                case GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY:
                    return {s_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY, 35};
#endif
#ifdef GL_UNSIGNED_INT_VEC2
                case GL_UNSIGNED_INT_VEC2:
                    return {s_UNSIGNED_INT_VEC2, 17};
#endif
#ifdef GL_UNSIGNED_INT_VEC3
                case GL_UNSIGNED_INT_VEC3:
                    return {s_UNSIGNED_INT_VEC3, 17};
#endif
#ifdef GL_UNSIGNED_INT_VEC4
                case GL_UNSIGNED_INT_VEC4:
                    return {s_UNSIGNED_INT_VEC4, 17};
#endif
                default:;
            }
            break;
        case 100: /* stencil_operation */
            switch(GLenum(aev._value)) {
#ifdef GL_DECR
                case GL_DECR:
                    return {s_DECR, 4};
#endif
#ifdef GL_DECR_WRAP
                case GL_DECR_WRAP:
                    return {s_DECR_WRAP, 9};
#endif
#ifdef GL_INCR
                case GL_INCR:
                    return {s_INCR, 4};
#endif
#ifdef GL_INCR_WRAP
                case GL_INCR_WRAP:
                    return {s_INCR_WRAP, 9};
#endif
#ifdef GL_INVERT
                case GL_INVERT:
                    return {s_INVERT, 6};
#endif
#ifdef GL_KEEP
                case GL_KEEP:
                    return {s_KEEP, 4};
#endif
#ifdef GL_REPLACE
                case GL_REPLACE:
                    return {s_REPLACE, 7};
#endif
#ifdef GL_ZERO
                case GL_ZERO:
                    return {s_ZERO, 4};
#endif
                default:;
            }
            break;
        case 101: /* string_query */
            switch(GLenum(aev._value)) {
#ifdef GL_RENDERER
                case GL_RENDERER:
                    return {s_RENDERER, 8};
#endif
#ifdef GL_SHADING_LANGUAGE_VERSION
                case GL_SHADING_LANGUAGE_VERSION:
                    return {s_SHADING_LANGUAGE_VERSION, 24};
#endif
#ifdef GL_VENDOR
                case GL_VENDOR:
                    return {s_VENDOR, 6};
#endif
#ifdef GL_VERSION
                case GL_VERSION:
                    return {s_VERSION, 7};
#endif
                default:;
            }
            break;
        case 102: /* support_level */
            switch(GLenum(aev._value)) {
#ifdef GL_CAVEAT_SUPPORT
                case GL_CAVEAT_SUPPORT:
                    return {s_CAVEAT_SUPPORT, 14};
#endif
#ifdef GL_FULL_SUPPORT
                case GL_FULL_SUPPORT:
                    return {s_FULL_SUPPORT, 12};
#endif
#ifdef GL_NONE
                case GL_NONE:
                    return {s_NONE, 4};
#endif
                default:;
            }
            break;
        case 103: /* sync_condition */
            switch(GLenum(aev._value)) {
#ifdef GL_SYNC_GPU_COMMANDS_COMPLETE
                case GL_SYNC_GPU_COMMANDS_COMPLETE:
                    return {s_SYNC_GPU_COMMANDS_COMPLETE, 26};
#endif
                default:;
            }
            break;
        case 104: /* sync_parameter */
            switch(GLenum(aev._value)) {
#ifdef GL_OBJECT_TYPE
                case GL_OBJECT_TYPE:
                    return {s_OBJECT_TYPE, 11};
#endif
#ifdef GL_SYNC_CONDITION
                case GL_SYNC_CONDITION:
                    return {s_SYNC_CONDITION, 14};
#endif
#ifdef GL_SYNC_GPU_COMMANDS_COMPLETE
                case GL_SYNC_GPU_COMMANDS_COMPLETE:
                    return {s_SYNC_GPU_COMMANDS_COMPLETE, 26};
#endif
#ifdef GL_SYNC_STATUS
                case GL_SYNC_STATUS:
                    return {s_SYNC_STATUS, 11};
#endif
                default:;
            }
            break;
        case 105: /* sync_status */
            switch(GLenum(aev._value)) {
#ifdef GL_SIGNALED
                case GL_SIGNALED:
                    return {s_SIGNALED, 8};
#endif
#ifdef GL_UNSIGNALED
                case GL_UNSIGNALED:
                    return {s_UNSIGNALED, 10};
#endif
                default:;
            }
            break;
        case 106: /* sync_type */
            switch(GLenum(aev._value)) {
#ifdef GL_SYNC_FENCE
                case GL_SYNC_FENCE:
                    return {s_SYNC_FENCE, 10};
#endif
                default:;
            }
            break;
        case 107: /* sync_wait_result */
            switch(GLenum(aev._value)) {
#ifdef GL_ALREADY_SIGNALED
                case GL_ALREADY_SIGNALED:
                    return {s_ALREADY_SIGNALED, 16};
#endif
#ifdef GL_CONDITION_SATISFIED
                case GL_CONDITION_SATISFIED:
                    return {s_CONDITION_SATISFIED, 19};
#endif
#ifdef GL_TIMEOUT_EXPIRED
                case GL_TIMEOUT_EXPIRED:
                    return {s_TIMEOUT_EXPIRED, 15};
#endif
#ifdef GL_WAIT_FAILED
                case GL_WAIT_FAILED:
                    return {s_WAIT_FAILED, 11};
#endif
                default:;
            }
            break;
        case 108: /* tess_gen_primitive_spacing */
            switch(GLenum(aev._value)) {
#ifdef GL_EQUAL
                case GL_EQUAL:
                    return {s_EQUAL, 5};
#endif
#ifdef GL_FRACTIONAL_EVEN
                case GL_FRACTIONAL_EVEN:
                    return {s_FRACTIONAL_EVEN, 15};
#endif
#ifdef GL_FRACTIONAL_ODD
                case GL_FRACTIONAL_ODD:
                    return {s_FRACTIONAL_ODD, 14};
#endif
                default:;
            }
            break;
        case 109: /* tess_gen_primitive_type */
            switch(GLenum(aev._value)) {
#ifdef GL_ISOLINES
                case GL_ISOLINES:
                    return {s_ISOLINES, 8};
#endif
#ifdef GL_QUADS
                case GL_QUADS:
                    return {s_QUADS, 5};
#endif
#ifdef GL_TRIANGLES
                case GL_TRIANGLES:
                    return {s_TRIANGLES, 9};
#endif
                default:;
            }
            break;
        case 110: /* texture_compare_mode */
            switch(GLenum(aev._value)) {
#ifdef GL_COMPARE_REF_TO_TEXTURE
                case GL_COMPARE_REF_TO_TEXTURE:
                    return {s_COMPARE_REF_TO_TEXTURE, 22};
#endif
#ifdef GL_NONE
                case GL_NONE:
                    return {s_NONE, 4};
#endif
                default:;
            }
            break;
        case 111: /* texture_filter */
            switch(GLenum(aev._value)) {
#ifdef GL_LINEAR
                case GL_LINEAR:
                    return {s_LINEAR, 6};
#endif
#ifdef GL_NEAREST
                case GL_NEAREST:
                    return {s_NEAREST, 7};
#endif
                default:;
            }
            break;
        case 112: /* texture_mag_filter */
            switch(GLenum(aev._value)) {
#ifdef GL_LINEAR
                case GL_LINEAR:
                    return {s_LINEAR, 6};
#endif
#ifdef GL_NEAREST
                case GL_NEAREST:
                    return {s_NEAREST, 7};
#endif
                default:;
            }
            break;
        case 113: /* texture_min_filter */
            switch(GLenum(aev._value)) {
#ifdef GL_LINEAR
                case GL_LINEAR:
                    return {s_LINEAR, 6};
#endif
#ifdef GL_LINEAR_MIPMAP_LINEAR
                case GL_LINEAR_MIPMAP_LINEAR:
                    return {s_LINEAR_MIPMAP_LINEAR, 20};
#endif
#ifdef GL_LINEAR_MIPMAP_NEAREST
                case GL_LINEAR_MIPMAP_NEAREST:
                    return {s_LINEAR_MIPMAP_NEAREST, 21};
#endif
#ifdef GL_NEAREST
                case GL_NEAREST:
                    return {s_NEAREST, 7};
#endif
#ifdef GL_NEAREST_MIPMAP_LINEAR
                case GL_NEAREST_MIPMAP_LINEAR:
                    return {s_NEAREST_MIPMAP_LINEAR, 21};
#endif
#ifdef GL_NEAREST_MIPMAP_NEAREST
                case GL_NEAREST_MIPMAP_NEAREST:
                    return {s_NEAREST_MIPMAP_NEAREST, 22};
#endif
                default:;
            }
            break;
        case 114: /* texture_parameter */
            switch(GLenum(aev._value)) {
#ifdef GL_DEPTH_STENCIL_TEXTURE_MODE
                case GL_DEPTH_STENCIL_TEXTURE_MODE:
                    return {s_DEPTH_STENCIL_TEXTURE_MODE, 26};
#endif
#ifdef GL_IMAGE_FORMAT_COMPATIBILITY_TYPE
                case GL_IMAGE_FORMAT_COMPATIBILITY_TYPE:
                    return {s_IMAGE_FORMAT_COMPATIBILITY_TYPE, 31};
#endif
#ifdef GL_TEXTURE_BASE_LEVEL
                case GL_TEXTURE_BASE_LEVEL:
                    return {s_TEXTURE_BASE_LEVEL, 18};
#endif
#ifdef GL_TEXTURE_BORDER_COLOR
                case GL_TEXTURE_BORDER_COLOR:
                    return {s_TEXTURE_BORDER_COLOR, 20};
#endif
#ifdef GL_TEXTURE_COMPARE_FUNC
                case GL_TEXTURE_COMPARE_FUNC:
                    return {s_TEXTURE_COMPARE_FUNC, 20};
#endif
#ifdef GL_TEXTURE_COMPARE_MODE
                case GL_TEXTURE_COMPARE_MODE:
                    return {s_TEXTURE_COMPARE_MODE, 20};
#endif
#ifdef GL_TEXTURE_IMMUTABLE_FORMAT
                case GL_TEXTURE_IMMUTABLE_FORMAT:
                    return {s_TEXTURE_IMMUTABLE_FORMAT, 24};
#endif
#ifdef GL_TEXTURE_IMMUTABLE_LEVELS
                case GL_TEXTURE_IMMUTABLE_LEVELS:
                    return {s_TEXTURE_IMMUTABLE_LEVELS, 24};
#endif
#ifdef GL_TEXTURE_LOD_BIAS
                case GL_TEXTURE_LOD_BIAS:
                    return {s_TEXTURE_LOD_BIAS, 16};
#endif
#ifdef GL_TEXTURE_MAG_FILTER
                case GL_TEXTURE_MAG_FILTER:
                    return {s_TEXTURE_MAG_FILTER, 18};
#endif
#ifdef GL_TEXTURE_MAX_LEVEL
                case GL_TEXTURE_MAX_LEVEL:
                    return {s_TEXTURE_MAX_LEVEL, 17};
#endif
#ifdef GL_TEXTURE_MAX_LOD
                case GL_TEXTURE_MAX_LOD:
                    return {s_TEXTURE_MAX_LOD, 15};
#endif
#ifdef GL_TEXTURE_MIN_FILTER
                case GL_TEXTURE_MIN_FILTER:
                    return {s_TEXTURE_MIN_FILTER, 18};
#endif
#ifdef GL_TEXTURE_MIN_LOD
                case GL_TEXTURE_MIN_LOD:
                    return {s_TEXTURE_MIN_LOD, 15};
#endif
#ifdef GL_TEXTURE_SWIZZLE_A
                case GL_TEXTURE_SWIZZLE_A:
                    return {s_TEXTURE_SWIZZLE_A, 17};
#endif
#ifdef GL_TEXTURE_SWIZZLE_B
                case GL_TEXTURE_SWIZZLE_B:
                    return {s_TEXTURE_SWIZZLE_B, 17};
#endif
#ifdef GL_TEXTURE_SWIZZLE_G
                case GL_TEXTURE_SWIZZLE_G:
                    return {s_TEXTURE_SWIZZLE_G, 17};
#endif
#ifdef GL_TEXTURE_SWIZZLE_R
                case GL_TEXTURE_SWIZZLE_R:
                    return {s_TEXTURE_SWIZZLE_R, 17};
#endif
#ifdef GL_TEXTURE_SWIZZLE_RGBA
                case GL_TEXTURE_SWIZZLE_RGBA:
                    return {s_TEXTURE_SWIZZLE_RGBA, 20};
#endif
#ifdef GL_TEXTURE_TARGET
                case GL_TEXTURE_TARGET:
                    return {s_TEXTURE_TARGET, 14};
#endif
#ifdef GL_TEXTURE_VIEW_MIN_LAYER
                case GL_TEXTURE_VIEW_MIN_LAYER:
                    return {s_TEXTURE_VIEW_MIN_LAYER, 22};
#endif
#ifdef GL_TEXTURE_VIEW_MIN_LEVEL
                case GL_TEXTURE_VIEW_MIN_LEVEL:
                    return {s_TEXTURE_VIEW_MIN_LEVEL, 22};
#endif
#ifdef GL_TEXTURE_VIEW_NUM_LAYERS
                case GL_TEXTURE_VIEW_NUM_LAYERS:
                    return {s_TEXTURE_VIEW_NUM_LAYERS, 23};
#endif
#ifdef GL_TEXTURE_VIEW_NUM_LEVELS
                case GL_TEXTURE_VIEW_NUM_LEVELS:
                    return {s_TEXTURE_VIEW_NUM_LEVELS, 23};
#endif
#ifdef GL_TEXTURE_WRAP_R
                case GL_TEXTURE_WRAP_R:
                    return {s_TEXTURE_WRAP_R, 14};
#endif
#ifdef GL_TEXTURE_WRAP_S
                case GL_TEXTURE_WRAP_S:
                    return {s_TEXTURE_WRAP_S, 14};
#endif
#ifdef GL_TEXTURE_WRAP_T
                case GL_TEXTURE_WRAP_T:
                    return {s_TEXTURE_WRAP_T, 14};
#endif
                default:;
            }
            break;
        case 115: /* texture_swizzle_coord */
            switch(GLenum(aev._value)) {
#ifdef GL_TEXTURE_SWIZZLE_A
                case GL_TEXTURE_SWIZZLE_A:
                    return {s_TEXTURE_SWIZZLE_A, 17};
#endif
#ifdef GL_TEXTURE_SWIZZLE_B
                case GL_TEXTURE_SWIZZLE_B:
                    return {s_TEXTURE_SWIZZLE_B, 17};
#endif
#ifdef GL_TEXTURE_SWIZZLE_G
                case GL_TEXTURE_SWIZZLE_G:
                    return {s_TEXTURE_SWIZZLE_G, 17};
#endif
#ifdef GL_TEXTURE_SWIZZLE_R
                case GL_TEXTURE_SWIZZLE_R:
                    return {s_TEXTURE_SWIZZLE_R, 17};
#endif
#ifdef GL_TEXTURE_SWIZZLE_RGBA
                case GL_TEXTURE_SWIZZLE_RGBA:
                    return {s_TEXTURE_SWIZZLE_RGBA, 20};
#endif
                default:;
            }
            break;
        case 116: /* texture_swizzle_mode */
            switch(GLenum(aev._value)) {
#ifdef GL_ALPHA
                case GL_ALPHA:
                    return {s_ALPHA, 5};
#endif
#ifdef GL_BLUE
                case GL_BLUE:
                    return {s_BLUE, 4};
#endif
#ifdef GL_GREEN
                case GL_GREEN:
                    return {s_GREEN, 5};
#endif
#ifdef GL_ONE
                case GL_ONE:
                    return {s_ONE, 3};
#endif
#ifdef GL_RED
                case GL_RED:
                    return {s_RED, 3};
#endif
#ifdef GL_ZERO
                case GL_ZERO:
                    return {s_ZERO, 4};
#endif
                default:;
            }
            break;
        case 117: /* texture_target */
            switch(GLenum(aev._value)) {
#ifdef GL_TEXTURE_1D
                case GL_TEXTURE_1D:
                    return {s_TEXTURE_1D, 10};
#endif
#ifdef GL_TEXTURE_1D_ARRAY
                case GL_TEXTURE_1D_ARRAY:
                    return {s_TEXTURE_1D_ARRAY, 16};
#endif
#ifdef GL_TEXTURE_2D
                case GL_TEXTURE_2D:
                    return {s_TEXTURE_2D, 10};
#endif
#ifdef GL_TEXTURE_2D_ARRAY
                case GL_TEXTURE_2D_ARRAY:
                    return {s_TEXTURE_2D_ARRAY, 16};
#endif
#ifdef GL_TEXTURE_2D_MULTISAMPLE
                case GL_TEXTURE_2D_MULTISAMPLE:
                    return {s_TEXTURE_2D_MULTISAMPLE, 22};
#endif
#ifdef GL_TEXTURE_2D_MULTISAMPLE_ARRAY
                case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
                    return {s_TEXTURE_2D_MULTISAMPLE_ARRAY, 28};
#endif
#ifdef GL_TEXTURE_3D
                case GL_TEXTURE_3D:
                    return {s_TEXTURE_3D, 10};
#endif
#ifdef GL_TEXTURE_BUFFER
                case GL_TEXTURE_BUFFER:
                    return {s_TEXTURE_BUFFER, 14};
#endif
#ifdef GL_TEXTURE_CUBE_MAP
                case GL_TEXTURE_CUBE_MAP:
                    return {s_TEXTURE_CUBE_MAP, 16};
#endif
#ifdef GL_TEXTURE_CUBE_MAP_ARRAY
                case GL_TEXTURE_CUBE_MAP_ARRAY:
                    return {s_TEXTURE_CUBE_MAP_ARRAY, 22};
#endif
#ifdef GL_TEXTURE_CUBE_MAP_NEGATIVE_X
                case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
                    return {s_TEXTURE_CUBE_MAP_NEGATIVE_X, 27};
#endif
#ifdef GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
                case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
                    return {s_TEXTURE_CUBE_MAP_NEGATIVE_Y, 27};
#endif
#ifdef GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
                case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
                    return {s_TEXTURE_CUBE_MAP_NEGATIVE_Z, 27};
#endif
#ifdef GL_TEXTURE_CUBE_MAP_POSITIVE_X
                case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
                    return {s_TEXTURE_CUBE_MAP_POSITIVE_X, 27};
#endif
#ifdef GL_TEXTURE_CUBE_MAP_POSITIVE_Y
                case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
                    return {s_TEXTURE_CUBE_MAP_POSITIVE_Y, 27};
#endif
#ifdef GL_TEXTURE_CUBE_MAP_POSITIVE_Z
                case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
                    return {s_TEXTURE_CUBE_MAP_POSITIVE_Z, 27};
#endif
#ifdef GL_TEXTURE_RECTANGLE
                case GL_TEXTURE_RECTANGLE:
                    return {s_TEXTURE_RECTANGLE, 17};
#endif
                default:;
            }
            break;
        case 118: /* texture_wrap_coord */
            switch(GLenum(aev._value)) {
#ifdef GL_TEXTURE_WRAP_R
                case GL_TEXTURE_WRAP_R:
                    return {s_TEXTURE_WRAP_R, 14};
#endif
#ifdef GL_TEXTURE_WRAP_S
                case GL_TEXTURE_WRAP_S:
                    return {s_TEXTURE_WRAP_S, 14};
#endif
#ifdef GL_TEXTURE_WRAP_T
                case GL_TEXTURE_WRAP_T:
                    return {s_TEXTURE_WRAP_T, 14};
#endif
                default:;
            }
            break;
        case 119: /* texture_wrap_mode */
            switch(GLenum(aev._value)) {
#ifdef GL_CLAMP_TO_BORDER
                case GL_CLAMP_TO_BORDER:
                    return {s_CLAMP_TO_BORDER, 15};
#endif
#ifdef GL_CLAMP_TO_EDGE
                case GL_CLAMP_TO_EDGE:
                    return {s_CLAMP_TO_EDGE, 13};
#endif
#ifdef GL_MIRRORED_REPEAT
                case GL_MIRRORED_REPEAT:
                    return {s_MIRRORED_REPEAT, 15};
#endif
#ifdef GL_MIRROR_CLAMP_TO_EDGE
                case GL_MIRROR_CLAMP_TO_EDGE:
                    return {s_MIRROR_CLAMP_TO_EDGE, 20};
#endif
#ifdef GL_REPEAT
                case GL_REPEAT:
                    return {s_REPEAT, 6};
#endif
                default:;
            }
            break;
        case 120: /* transform_feedback_mode */
            switch(GLenum(aev._value)) {
#ifdef GL_INTERLEAVED_ATTRIBS
                case GL_INTERLEAVED_ATTRIBS:
                    return {s_INTERLEAVED_ATTRIBS, 19};
#endif
#ifdef GL_SEPARATE_ATTRIBS
                case GL_SEPARATE_ATTRIBS:
                    return {s_SEPARATE_ATTRIBS, 16};
#endif
                default:;
            }
            break;
        case 121: /* transform_feedback_parameter */
            switch(GLenum(aev._value)) {
#ifdef GL_TRANSFORM_FEEDBACK_ACTIVE
                case GL_TRANSFORM_FEEDBACK_ACTIVE:
                    return {s_TRANSFORM_FEEDBACK_ACTIVE, 25};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_BINDING
                case GL_TRANSFORM_FEEDBACK_BUFFER_BINDING:
                    return {s_TRANSFORM_FEEDBACK_BUFFER_BINDING, 33};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_SIZE
                case GL_TRANSFORM_FEEDBACK_BUFFER_SIZE:
                    return {s_TRANSFORM_FEEDBACK_BUFFER_SIZE, 30};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_START
                case GL_TRANSFORM_FEEDBACK_BUFFER_START:
                    return {s_TRANSFORM_FEEDBACK_BUFFER_START, 31};
#endif
#ifdef GL_TRANSFORM_FEEDBACK_PAUSED
                case GL_TRANSFORM_FEEDBACK_PAUSED:
                    return {s_TRANSFORM_FEEDBACK_PAUSED, 25};
#endif
                default:;
            }
            break;
        case 122: /* transform_feedback_primitive_type */
            switch(GLenum(aev._value)) {
#ifdef GL_LINES
                case GL_LINES:
                    return {s_LINES, 5};
#endif
#ifdef GL_POINTS
                case GL_POINTS:
                    return {s_POINTS, 6};
#endif
#ifdef GL_TRIANGLES
                case GL_TRIANGLES:
                    return {s_TRIANGLES, 9};
#endif
                default:;
            }
            break;
        case 123: /* transform_feedback_target */
            switch(GLenum(aev._value)) {
#ifdef GL_TRANSFORM_FEEDBACK
                case GL_TRANSFORM_FEEDBACK:
                    return {s_TRANSFORM_FEEDBACK, 18};
#endif
                default:;
            }
            break;
        case 124: /* true_false */
            switch(GLboolean(aev._value)) {
#ifdef GL_FALSE
                case GL_FALSE:
                    return {s_FALSE, 5};
#endif
#ifdef GL_TRUE
                case GL_TRUE:
                    return {s_TRUE, 4};
#endif
                default:;
            }
            break;
        case 125: /* unified_array_address_nv */
            switch(GLenum(aev._value)) {
#ifdef GL_COLOR_ARRAY_ADDRESS_NV
                case GL_COLOR_ARRAY_ADDRESS_NV:
                    return {s_COLOR_ARRAY_ADDRESS_NV, 22};
#endif
#ifdef GL_EDGE_FLAG_ARRAY_ADDRESS_NV
                case GL_EDGE_FLAG_ARRAY_ADDRESS_NV:
                    return {s_EDGE_FLAG_ARRAY_ADDRESS_NV, 26};
#endif
#ifdef GL_ELEMENT_ARRAY_ADDRESS_NV
                case GL_ELEMENT_ARRAY_ADDRESS_NV:
                    return {s_ELEMENT_ARRAY_ADDRESS_NV, 24};
#endif
#ifdef GL_FOG_COORD_ARRAY_ADDRESS_NV
                case GL_FOG_COORD_ARRAY_ADDRESS_NV:
                    return {s_FOG_COORD_ARRAY_ADDRESS_NV, 26};
#endif
#ifdef GL_INDEX_ARRAY_ADDRESS_NV
                case GL_INDEX_ARRAY_ADDRESS_NV:
                    return {s_INDEX_ARRAY_ADDRESS_NV, 22};
#endif
#ifdef GL_NORMAL_ARRAY_ADDRESS_NV
                case GL_NORMAL_ARRAY_ADDRESS_NV:
                    return {s_NORMAL_ARRAY_ADDRESS_NV, 23};
#endif
#ifdef GL_SECONDARY_COLOR_ARRAY_ADDRESS_NV
                case GL_SECONDARY_COLOR_ARRAY_ADDRESS_NV:
                    return {s_SECONDARY_COLOR_ARRAY_ADDRESS_NV, 32};
#endif
#ifdef GL_TEXTURE_COORD_ARRAY_ADDRESS_NV
                case GL_TEXTURE_COORD_ARRAY_ADDRESS_NV:
                    return {s_TEXTURE_COORD_ARRAY_ADDRESS_NV, 30};
#endif
#ifdef GL_UNIFORM_BUFFER_ADDRESS_NV
                case GL_UNIFORM_BUFFER_ADDRESS_NV:
                    return {s_UNIFORM_BUFFER_ADDRESS_NV, 25};
#endif
#ifdef GL_VERTEX_ARRAY_ADDRESS_NV
                case GL_VERTEX_ARRAY_ADDRESS_NV:
                    return {s_VERTEX_ARRAY_ADDRESS_NV, 23};
#endif
#ifdef GL_VERTEX_ATTRIB_ARRAY_ADDRESS_NV
                case GL_VERTEX_ATTRIB_ARRAY_ADDRESS_NV:
                    return {s_VERTEX_ATTRIB_ARRAY_ADDRESS_NV, 30};
#endif
                default:;
            }
            break;
        case 126: /* view_compatibility_class */
            switch(GLenum(aev._value)) {
#ifdef GL_VIEW_CLASS_128_BITS
                case GL_VIEW_CLASS_128_BITS:
                    return {s_VIEW_CLASS_128_BITS, 19};
#endif
#ifdef GL_VIEW_CLASS_16_BITS
                case GL_VIEW_CLASS_16_BITS:
                    return {s_VIEW_CLASS_16_BITS, 18};
#endif
#ifdef GL_VIEW_CLASS_24_BITS
                case GL_VIEW_CLASS_24_BITS:
                    return {s_VIEW_CLASS_24_BITS, 18};
#endif
#ifdef GL_VIEW_CLASS_32_BITS
                case GL_VIEW_CLASS_32_BITS:
                    return {s_VIEW_CLASS_32_BITS, 18};
#endif
#ifdef GL_VIEW_CLASS_48_BITS
                case GL_VIEW_CLASS_48_BITS:
                    return {s_VIEW_CLASS_48_BITS, 18};
#endif
#ifdef GL_VIEW_CLASS_64_BITS
                case GL_VIEW_CLASS_64_BITS:
                    return {s_VIEW_CLASS_64_BITS, 18};
#endif
#ifdef GL_VIEW_CLASS_8_BITS
                case GL_VIEW_CLASS_8_BITS:
                    return {s_VIEW_CLASS_8_BITS, 17};
#endif
#ifdef GL_VIEW_CLASS_96_BITS
                case GL_VIEW_CLASS_96_BITS:
                    return {s_VIEW_CLASS_96_BITS, 18};
#endif
#ifdef GL_VIEW_CLASS_BPTC_FLOAT
                case GL_VIEW_CLASS_BPTC_FLOAT:
                    return {s_VIEW_CLASS_BPTC_FLOAT, 21};
#endif
#ifdef GL_VIEW_CLASS_BPTC_UNORM
                case GL_VIEW_CLASS_BPTC_UNORM:
                    return {s_VIEW_CLASS_BPTC_UNORM, 21};
#endif
#ifdef GL_VIEW_CLASS_RGTC1_RED
                case GL_VIEW_CLASS_RGTC1_RED:
                    return {s_VIEW_CLASS_RGTC1_RED, 20};
#endif
#ifdef GL_VIEW_CLASS_RGTC2_RG
                case GL_VIEW_CLASS_RGTC2_RG:
                    return {s_VIEW_CLASS_RGTC2_RG, 19};
#endif
#ifdef GL_VIEW_CLASS_S3TC_DXT1_RGB
                case GL_VIEW_CLASS_S3TC_DXT1_RGB:
                    return {s_VIEW_CLASS_S3TC_DXT1_RGB, 24};
#endif
#ifdef GL_VIEW_CLASS_S3TC_DXT1_RGBA
                case GL_VIEW_CLASS_S3TC_DXT1_RGBA:
                    return {s_VIEW_CLASS_S3TC_DXT1_RGBA, 25};
#endif
#ifdef GL_VIEW_CLASS_S3TC_DXT3_RGBA
                case GL_VIEW_CLASS_S3TC_DXT3_RGBA:
                    return {s_VIEW_CLASS_S3TC_DXT3_RGBA, 25};
#endif
#ifdef GL_VIEW_CLASS_S3TC_DXT5_RGBA
                case GL_VIEW_CLASS_S3TC_DXT5_RGBA:
                    return {s_VIEW_CLASS_S3TC_DXT5_RGBA, 25};
#endif
                default:;
            }
            break;
        default:;
    }

    EAGINE_MAYBE_UNUSED(aev);
    return {};
}

} // namespace oglplus
#ifdef _MSC_VER
#pragma warning(pop)
#endif //_MSC_VER
